{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport \"lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary ExecutorOptions {\n    using CalldataBytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 1;\n\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\n    uint8 internal constant OPTION_TYPE_LZREAD = 5;\n\n    error Executor_InvalidLzReceiveOption();\n    error Executor_InvalidNativeDropOption();\n    error Executor_InvalidLzComposeOption();\n    error Executor_InvalidLzReadOption();\n\n    /// @dev decode the next executor option from the options starting from the specified cursor\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\n    ///        executor_option = [option_size][option_type][option]\n    ///        option_size = len(option_type) + len(option)\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @param _cursor the cursor to start decoding from\n    /// @return optionType the type of the option\n    /// @return option the option of the executor\n    /// @return cursor the cursor to start decoding the next executor option\n    function nextExecutorOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor);\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 1; // skip option type\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\n        gas = _option.toU128(0);\n        value = _option.length == 32 ? _option.toU128(16) : 0;\n    }\n\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\n        amount = _option.toU128(0);\n        receiver = _option.toB32(16);\n    }\n\n    function decodeLzComposeOption(\n        bytes calldata _option\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\n        index = _option.toU16(0);\n        gas = _option.toU128(2);\n        value = _option.length == 34 ? _option.toU128(18) : 0;\n    }\n\n    function decodeLzReadOption(\n        bytes calldata _option\n    ) internal pure returns (uint128 gas, uint32 calldataSize, uint128 value) {\n        if (_option.length != 20 && _option.length != 36) revert Executor_InvalidLzReadOption();\n        gas = _option.toU128(0);\n        calldataSize = _option.toU32(16);\n        value = _option.length == 36 ? _option.toU128(20) : 0;\n    }\n\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\n    }\n\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\n        return abi.encodePacked(_amount, _receiver);\n    }\n\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\n    }\n\n    function encodeLzReadOption(\n        uint128 _gas,\n        uint32 _calldataSize,\n        uint128 _value\n    ) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas, _calldataSize) : abi.encodePacked(_gas, _calldataSize, _value);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport { BitMap256 } from \"lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/messagelib/libs/BitMaps.sol\";\nimport { CalldataBytesLib } from \"lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary DVNOptions {\n    using CalldataBytesLib for bytes;\n    using BytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 2;\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\n\n    error DVN_InvalidDVNIdx();\n    error DVN_InvalidDVNOptions(uint256 cursor);\n\n    /// @dev group dvn options by its idx\n    /// @param _options [dvn_id][dvn_option][dvn_id][dvn_option]...\n    ///        dvn_option = [option_size][dvn_idx][option_type][option]\n    ///        option_size = len(dvn_idx) + len(option_type) + len(option)\n    ///        dvn_id: uint8, dvn_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @return dvnOptions the grouped options, still share the same format of _options\n    /// @return dvnIndices the dvn indices\n    function groupDVNOptionsByIdx(\n        bytes memory _options\n    ) internal pure returns (bytes[] memory dvnOptions, uint8[] memory dvnIndices) {\n        if (_options.length == 0) return (dvnOptions, dvnIndices);\n\n        uint8 numDVNs = getNumDVNs(_options);\n\n        // if there is only 1 dvn, we can just return the whole options\n        if (numDVNs == 1) {\n            dvnOptions = new bytes[](1);\n            dvnOptions[0] = _options;\n\n            dvnIndices = new uint8[](1);\n            dvnIndices[0] = _options.toUint8(3); // dvn idx\n            return (dvnOptions, dvnIndices);\n        }\n\n        // otherwise, we need to group the options by dvn_idx\n        dvnIndices = new uint8[](numDVNs);\n        dvnOptions = new bytes[](numDVNs);\n        unchecked {\n            uint256 cursor = 0;\n            uint256 start = 0;\n            uint8 lastDVNIdx = 255; // 255 is an invalid dvn_idx\n\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                // optionLength asserted in getNumDVNs (skip check)\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n\n                // dvnIdx asserted in getNumDVNs (skip check)\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // dvnIdx must equal to the lastDVNIdx for the first option\n                // so it is always skipped in the first option\n                // this operation slices out options whenever the scan finds a different lastDVNIdx\n                if (lastDVNIdx == 255) {\n                    lastDVNIdx = dvnIdx;\n                } else if (dvnIdx != lastDVNIdx) {\n                    uint256 len = cursor - start - 3; // 3 is for worker_id and option_length\n                    bytes memory opt = _options.slice(start, len);\n                    _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, opt);\n\n                    // reset the start and lastDVNIdx\n                    start += len;\n                    lastDVNIdx = dvnIdx;\n                }\n\n                cursor += optionLength;\n            }\n\n            // skip check the cursor here because the cursor is asserted in getNumDVNs\n            // if we have reached the end of the options, we need to process the last dvn\n            uint256 size = cursor - start;\n            bytes memory op = _options.slice(start, size);\n            _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, op);\n\n            // revert dvnIndices to start from 0\n            for (uint8 i = 0; i < numDVNs; ++i) {\n                --dvnIndices[i];\n            }\n        }\n    }\n\n    function _insertDVNOptions(\n        bytes[] memory _dvnOptions,\n        uint8[] memory _dvnIndices,\n        uint8 _dvnIdx,\n        bytes memory _newOptions\n    ) internal pure {\n        // dvnIdx starts from 0 but default value of dvnIndices is 0,\n        // so we tell if the slot is empty by adding 1 to dvnIdx\n        if (_dvnIdx == 255) revert DVN_InvalidDVNIdx();\n        uint8 dvnIdxAdj = _dvnIdx + 1;\n\n        for (uint256 j = 0; j < _dvnIndices.length; ++j) {\n            uint8 index = _dvnIndices[j];\n            if (dvnIdxAdj == index) {\n                _dvnOptions[j] = abi.encodePacked(_dvnOptions[j], _newOptions);\n                break;\n            } else if (index == 0) {\n                // empty slot, that means it is the first time we see this dvn\n                _dvnIndices[j] = dvnIdxAdj;\n                _dvnOptions[j] = _newOptions;\n                break;\n            }\n        }\n    }\n\n    /// @dev get the number of unique dvns\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    function getNumDVNs(bytes memory _options) internal pure returns (uint8 numDVNs) {\n        uint256 cursor = 0;\n        BitMap256 bitmap;\n\n        // find number of unique dvn_idx\n        unchecked {\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n                if (optionLength < 2) revert DVN_InvalidDVNOptions(cursor); // at least 1 byte for dvn_idx and 1 byte for option_type\n\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // if dvnIdx is not set, increment numDVNs\n                // max num of dvns is 255, 255 is an invalid dvn_idx\n                // The order of the dvnIdx is not required to be sequential, as enforcing the order may weaken\n                // the composability of the options. e.g. if we refrain from enforcing the order, an OApp that has\n                // already enforced certain options can append additional options to the end of the enforced\n                // ones without restrictions.\n                if (dvnIdx == 255) revert DVN_InvalidDVNIdx();\n                if (!bitmap.get(dvnIdx)) {\n                    ++numDVNs;\n                    bitmap = bitmap.set(dvnIdx);\n                }\n\n                cursor += optionLength;\n            }\n        }\n        if (cursor != _options.length) revert DVN_InvalidDVNOptions(cursor);\n    }\n\n    /// @dev decode the next dvn option from _options starting from the specified cursor\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    /// @param _cursor the cursor to start decoding\n    /// @return optionType the type of the option\n    /// @return option the option\n    /// @return cursor the cursor to start decoding the next option\n    function nextDVNOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor + 1); // skip dvn_idx\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 2; // skip option type and dvn_idx\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n}\n"
    },
    "contracts/core/external/chainlink/ChainlinkVRFIntegratorV2_5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n/**\n * @title ChainlinkVRFIntegratorV2_5 - OmniDragon Cross-Chain VRF System\n * @dev Sonic-based contract that receives random words requests and forwards them to Arbitrum\n *      for Chainlink VRF 2.5 processing. Part of the OmniDragon ecosystem's cross-chain lottery\n *      and random words infrastructure.\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { OApp, MessagingFee, Origin } from \"../../../../lib/devtools/packages/oapp-evm/contracts/oapp/OApp.sol\";\nimport { MessagingReceipt } from \"../../../../lib/devtools/packages/oapp-evm/contracts/oapp/OAppSender.sol\";\nimport { OAppOptionsType3 } from \"../../../../lib/devtools/packages/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol\";\nimport { OptionsBuilder } from \"../../../../lib/devtools/packages/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\nimport { IChainlinkVRFIntegratorV2_5 } from \"../../../interfaces/external/chainlink/IChainlinkVRFIntegratorV2_5.sol\";\nimport { IRandomWordsCallbackV2_5 } from \"../../../interfaces/external/chainlink/IRandomWordsCallbackV2_5.sol\";\nimport { SetConfigParam } from \"../../../../lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/IMessageLibManager.sol\";\n\n/**\n * @title ChainlinkVRFIntegratorV2_5\n * @notice Resides on a source chain (e.g., Sonic). Called by a provider to get random words from a peer on a destination chain (e.g., Arbitrum).\n */\ncontract ChainlinkVRFIntegratorV2_5 is OApp, OAppOptionsType3, IChainlinkVRFIntegratorV2_5 {\n    using OptionsBuilder for bytes;\n    \n    // Constants\n    uint32 constant ARBITRUM_EID = 30110;\n    \n    // State variables\n    uint64 public requestCounter;\n    uint32 public defaultGasLimit = 700000;\n    \n    // Request tracking\n    struct RequestStatus {\n        bool fulfilled;\n        bool exists;\n        address provider;\n        uint256 randomWord;\n        uint256 timestamp;\n        bool isContract; // Track if provider is a contract\n    }\n    mapping(uint64 => RequestStatus) public s_requests;\n    // AUDIT FIX: Removed redundant randomWordsProviders mapping\n\n    // Events are inherited from IChainlinkVRFIntegratorV2_5 interface\n\n    // Configuration\n    uint256 public requestTimeout = 300; // 5 minutes timeout\n\n    constructor(address _endpoint, address _initialOwner) \n        OApp(_endpoint, address(this)) \n        Ownable(_initialOwner) \n    {\n        // No-op constructor\n    }\n\n    /**\n     * @dev Receives random words responses from Arbitrum\n     * @dev Updated to handle the correct payload format: (sequence, randomWord)\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32,\n        bytes calldata _payload,\n        address,\n        bytes calldata\n    ) internal override {\n        require(peers[_origin.srcEid] == _origin.sender, \"Unauthorized\");\n        require(_payload.length == 40, \"Invalid payload size\"); // AUDIT FIX: uint64(8) + uint256(32) = 40 bytes\n\n        (uint64 sequence, uint256 randomWord) = abi.decode(_payload, (uint64, uint256));\n        \n        RequestStatus storage request = s_requests[sequence];\n        require(request.exists, \"Request not found\");\n        require(!request.fulfilled, \"Request already fulfilled\");\n        require(block.timestamp <= request.timestamp + requestTimeout, \"Request expired\");\n        \n        address provider = request.provider;\n        require(provider != address(0), \"Provider not found\");\n        \n        // Mark as fulfilled\n        request.fulfilled = true;\n        request.randomWord = randomWord;\n        \n        // AUDIT FIX: Removed redundant randomWordsProviders mapping cleanup\n\n        // Create randomWords array for callback/event\n        uint256[] memory randomWords = new uint256[](1);\n        randomWords[0] = randomWord;\n        \n        // Always emit the RandomWordsReceived event first\n        emit RandomWordsReceived(randomWords, sequence, provider);\n        \n        // Only attempt callback if provider is a contract\n        if (request.isContract) {\n            try IRandomWordsCallbackV2_5(provider).receiveRandomWords(randomWords, sequence) {\n                emit CallbackSucceeded(sequence, provider);\n            } catch Error(string memory reason) {\n                emit CallbackFailed(sequence, provider, reason);\n            } catch (bytes memory /*lowLevelData*/) {\n                emit CallbackFailed(sequence, provider, \"Low-level callback failure\");\n            }\n        }\n        // For EOA (wallet) requests, the RandomWordsReceived event is sufficient\n        // Users can query s_requests[sequence].randomWord to get their value\n    }\n\n    /**\n     * @notice Manual retry for stuck LayerZero messages\n     * @dev In LayerZero V2, retry is handled by the executor infrastructure\n     *      This function is for administrative purposes and monitoring\n     * @param requestId The request ID that may need attention\n     */\n    function checkRequestStatus(uint64 requestId) external view returns (\n        bool fulfilled,\n        bool exists,\n        address provider,\n        uint256 randomWord,\n        uint256 timestamp,\n        bool expired\n    ) {\n        RequestStatus memory request = s_requests[requestId];\n        return (\n            request.fulfilled,\n            request.exists,\n            request.provider,\n            request.randomWord,\n            request.timestamp,\n            block.timestamp > request.timestamp + requestTimeout\n        );\n    }\n\n    /**\n     * @notice Get the random word for a fulfilled request\n     * @param requestId The request ID to query\n     * @return randomWord The random word (0 if not fulfilled)\n     * @return fulfilled Whether the request has been fulfilled\n     */\n    function getRandomWord(uint64 requestId) external view returns (uint256 randomWord, bool fulfilled) {\n        RequestStatus memory request = s_requests[requestId];\n        return (request.randomWord, request.fulfilled);\n    }\n\n    /**\n     * @dev Main function to request random words from a peer VRF Consumer.\n     * @param _dstEid The destination endpoint ID (e.g., for Arbitrum).\n     * @param _options LayerZero options for the cross-chain message.\n     */\n    function requestRandomWords(uint32 _dstEid, bytes calldata _options) external payable returns (MessagingReceipt memory receipt, uint64 requestId) {\n        bytes32 peer = peers[_dstEid];\n        require(peer != bytes32(0), \"Peer not set\");\n        \n        requestCounter++;\n        requestId = requestCounter;\n        \n        // Check if caller is a contract\n        bool isContract = msg.sender.code.length > 0;\n        \n        // Store request info\n        s_requests[requestId] = RequestStatus({\n            fulfilled: false,\n            exists: true,\n            provider: msg.sender,\n            randomWord: 0,\n            timestamp: block.timestamp,\n            isContract: isContract\n        });\n\n        bytes memory payload = abi.encode(requestId);\n\n        receipt = _lzSend(\n            _dstEid,\n            payload,\n            _options,\n            MessagingFee({nativeFee: msg.value, lzTokenFee: 0}),\n            payable(msg.sender)\n        );\n\n        emit RandomWordsRequested(requestId, msg.sender, _dstEid);\n        emit MessageSent(requestId, _dstEid, payload);\n    }\n\n    /**\n     * @dev Convenience function to request random words with a default gas limit.\n     * @param _dstEid The destination endpoint ID (e.g., for Arbitrum).\n     */\n    function requestRandomWordsSimple(uint32 _dstEid) external payable returns (MessagingReceipt memory receipt, uint64 requestId) {\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(defaultGasLimit, 0);\n        return this.requestRandomWords{value: msg.value}(_dstEid, options);\n    }\n    \n    /**\n     * @dev Quote the fee for a random words request.\n     * @param _dstEid The destination endpoint ID.\n     * @param _options LayerZero options for the cross-chain message.\n     */\n    function quote(uint32 _dstEid, bytes calldata _options) public view returns (MessagingFee memory fee) {\n        bytes memory payload = abi.encode(uint64(requestCounter + 1));\n        fee = _quote(_dstEid, payload, _options, false);\n    }\n\n    /**\n     * @dev Allows the owner to set the default gas limit for simple requests.\n     * @param _newGasLimit The new default gas limit.\n     */\n    function setDefaultGasLimit(uint32 _newGasLimit) external onlyOwner {\n        uint32 oldLimit = defaultGasLimit;\n        defaultGasLimit = _newGasLimit;\n        emit GasLimitUpdated(oldLimit, _newGasLimit); // AUDIT FIX: Emit event\n    }\n\n    /**\n     * @dev Authorize/deauthorize callers (owner only)\n     * @param caller The address to authorize/deauthorize\n     * @param authorized Whether to authorize or deauthorize\n     */\n    function setAuthorizedCaller(address caller, bool authorized) external onlyOwner {\n        // For now, this is a placeholder function for interface compatibility\n        // The current implementation allows all callers\n        // This can be enhanced with actual authorization logic if needed\n    }\n\n    /**\n     * @dev Allows the owner to set the request timeout duration.\n     * @param _newTimeout The new timeout in seconds.\n     */\n    function setRequestTimeout(uint256 _newTimeout) external onlyOwner {\n        uint256 oldTimeout = requestTimeout;\n        requestTimeout = _newTimeout;\n        emit RequestTimeoutUpdated(oldTimeout, _newTimeout); // AUDIT FIX: Emit event\n    }\n\n    /**\n     * @dev Set peer for a specific endpoint ID (owner only)\n     * @param _eid The endpoint ID to set the peer for\n     * @param _peer The peer address (as bytes32)\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public override onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @dev Set LayerZero configuration (called by LayerZero tooling)\n     * @param _lib The message library address\n     * @param _params Array of configuration parameters\n     */\n    function setConfig(address _lib, SetConfigParam[] calldata _params) external onlyOwner {\n        // Delegate to the LayerZero endpoint\n        endpoint.setConfig(address(this), _lib, _params);\n    }\n\n    /**\n     * @dev Get LayerZero configuration\n     * @param _lib The message library address\n     * @param _eid The endpoint ID\n     * @param _configType The configuration type\n     * @return config The configuration bytes\n     */\n    function getConfig(address _lib, uint32 _eid, uint32 _configType) external view returns (bytes memory config) {\n        return endpoint.getConfig(address(this), _lib, _eid, _configType);\n    }\n\n    /**\n     * @dev Clean up expired requests (anyone can call)\n     * @param requestIds Array of request IDs to clean up (max 50 per transaction)\n     */\n    function cleanupExpiredRequests(uint64[] calldata requestIds) external {\n        require(requestIds.length <= 50, \"Too many requests to cleanup\"); // AUDIT FIX: Prevent DoS\n        \n        for (uint256 i = 0; i < requestIds.length; i++) {\n            uint64 requestId = requestIds[i];\n            RequestStatus storage request = s_requests[requestId];\n            \n            if (request.exists && !request.fulfilled && \n                block.timestamp > request.timestamp + requestTimeout) {\n                \n                address provider = request.provider;\n                \n                // Mark as expired and clean up\n                delete s_requests[requestId];\n                // AUDIT FIX: Removed redundant randomWordsProviders mapping cleanup\n                \n                emit RequestExpired(requestId, provider);\n            }\n        }\n    }\n\n    /// @dev Register my contract on Sonic FeeM\n    function registerMe() external {\n        (bool _success,) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n            abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n        );\n        require(_success, \"FeeM registration failed\");\n    }\n\n    /**\n     * @dev Emergency withdraw (owner only)\n     */\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No balance to withdraw\");\n        \n        // AUDIT FIX: Use call instead of transfer for better compatibility\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    /**\n     * @dev Fund contract with ETH for LayerZero operations\n     * @notice Anyone can fund the contract to ensure smooth VRF operations\n     */\n    function fundContract() external payable {\n        require(msg.value > 0, \"Must send ETH to fund contract\");\n        emit ContractFunded(msg.sender, msg.value, address(this).balance);\n    }\n\n    /**\n     * @dev Get current contract balance and status\n     * @return balance Current ETH balance\n     * @return canOperate Whether contract has sufficient funds for operations\n     */\n    function getContractStatus() external view returns (uint256 balance, bool canOperate) {\n        balance = address(this).balance;\n        canOperate = balance > 0; // Simple check - any balance allows operation\n        return (balance, canOperate);\n    }\n\n    /**\n     * @dev Receive ETH\n     */\n    receive() external payable {}\n} "
    },
    "contracts/core/external/chainlink/OmniDragonVRFConsumerV2_5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n/**\n * @title OmniDragonVRFConsumerV2_5\n * @dev Multi-chain VRF Consumer that accepts requests from multiple chains\n *      (Sonic, Avalanche, etc.) and sends randomness back to the originating chain.\n *      This acts as a centralized VRF hub on Arbitrum using Chainlink VRF 2.5.\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { OApp, MessagingFee, Origin } from \"lib/devtools/packages/oapp-evm/contracts/oapp/OApp.sol\";\nimport { MessagingReceipt } from \"lib/devtools/packages/oapp-evm/contracts/oapp/OAppSender.sol\";\nimport { OAppOptionsType3 } from \"lib/devtools/packages/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol\";\nimport { OptionsBuilder } from \"lib/devtools/packages/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\nimport { IVRFCoordinatorV2Plus } from \"lib/chainlink-brownie-contracts/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol\";\nimport { VRFV2PlusClient } from \"lib/chainlink-brownie-contracts/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol\";\n\ncontract OmniDragonVRFConsumerV2_5 is OApp, OAppOptionsType3 {\n    using OptionsBuilder for bytes;\n\n    IVRFCoordinatorV2Plus public immutable vrfCoordinator;\n    uint32 public constant ETHEREUM_EID = 30101;\n    uint32 public constant BSC_EID = 30102;\n    uint32 public constant AVALANCHE_EID = 30106;\n    uint32 public constant POLYGON_EID = 30109;\n    uint32 public constant OPTIMISM_EID = 30111;\n    uint32 public constant BASE_EID = 30184;\n    uint32 public constant SONIC_EID = 30332;\n    \n    mapping(uint32 => bool) public supportedChains;\n    mapping(uint32 => uint32) public chainGasLimits;\n    \n    uint32[] public registeredChainEids;\n    mapping(uint32 => string) public chainNames;\n    \n    uint256 public subscriptionId;\n    bytes32 public keyHash;\n    uint32 public callbackGasLimit = 2500000;\n    uint16 public requestConfirmations = 3;\n    uint32 public numWords = 1;\n    \n    bool public nativePayment = false;\n\n    struct VRFRequest {\n        uint64 sequence;\n        uint32 sourceChainEid;\n        bytes32 sourcePeer;\n        uint256 randomWord;\n        bool fulfilled;\n        bool responseSent;\n        uint256 timestamp;\n    }\n\n    mapping(uint256 => VRFRequest) public vrfRequests;\n    mapping(uint64 => uint256) public sequenceToRequestId;\n    \n    mapping(uint64 => bool) public pendingResponses;\n    \n    /**\n     * @dev Minimum ETH balance threshold for monitoring purposes only.\n     */\n    uint256 public minimumBalance = 0.005 ether;\n    uint32 public defaultGasLimit = 2500000;\n\n    event RandomWordsRequested(\n        uint256 indexed requestId,\n        uint32 indexed srcEid,\n        bytes32 indexed requester,\n        uint64 sequence,\n        uint256 timestamp\n    );\n    event VRFRequestSent(uint256 indexed originalRequestId, uint256 indexed vrfRequestId, uint32 sourceChain);\n    event RandomnessFulfilled(uint256 indexed requestId, uint256[] randomWords, uint32 targetChain);\n    event ResponseSentToChain(uint64 indexed sequence, uint256 randomWord, uint32 targetChain, uint256 fee);\n    event ResponsePending(uint64 indexed sequence, uint256 indexed requestId, uint32 targetChain, string reason);\n    event VRFConfigUpdated(uint256 subscriptionId, bytes32 keyHash, uint32 callbackGasLimit, uint16 requestConfirmations);\n    event MinimumBalanceUpdated(uint256 oldBalance, uint256 newBalance);\n    event ChainSupportUpdated(uint32 chainEid, bool supported, uint32 gasLimit);\n    event ContractFunded(address indexed funder, uint256 amount, uint256 newBalance);\n\n    constructor(\n        address _endpoint,\n        address _owner,\n        address _vrfCoordinator,\n        uint256 _subscriptionId,\n        bytes32 _keyHash\n    ) OApp(_endpoint, _owner) Ownable(_owner) {\n        vrfCoordinator = IVRFCoordinatorV2Plus(_vrfCoordinator);\n        subscriptionId = _subscriptionId;\n        keyHash = _keyHash;\n        \n        _setSupportedChain(SONIC_EID, true, 2500000);\n        _setSupportedChain(AVALANCHE_EID, true, 2500000);\n        _setSupportedChain(BASE_EID, true, 2500000);\n        _setSupportedChain(ETHEREUM_EID, true, 2500000);\n    }\n\n    /**\n     * @notice LayerZero V2 receive function - accepts VRF requests from multiple chains\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32,\n        bytes calldata _message,\n        address,\n        bytes calldata\n    ) internal override {\n        require(supportedChains[_origin.srcEid], \"Chain not supported\");\n        \n        require(peers[_origin.srcEid] == _origin.sender, \"Invalid source peer\");\n        \n        uint64 sequence = abi.decode(_message, (uint64));\n        \n        require(sequenceToRequestId[sequence] == 0, \"Duplicate sequence\");\n\n        bytes memory extraArgs = VRFV2PlusClient._argsToBytes(\n            VRFV2PlusClient.ExtraArgsV1({nativePayment: nativePayment})\n        );\n        \n        uint256 requestId = vrfCoordinator.requestRandomWords(\n            VRFV2PlusClient.RandomWordsRequest({\n                keyHash: keyHash,\n                subId: subscriptionId,\n                requestConfirmations: requestConfirmations,\n                callbackGasLimit: callbackGasLimit,\n                numWords: numWords,\n                extraArgs: extraArgs\n            })\n        );\n        \n        vrfRequests[requestId] = VRFRequest({\n            sequence: sequence,\n            sourceChainEid: _origin.srcEid,\n            sourcePeer: _origin.sender,\n            randomWord: 0,\n            fulfilled: false,\n            responseSent: false,\n            timestamp: block.timestamp\n        });\n        \n        sequenceToRequestId[sequence] = requestId;\n\n        emit VRFRequestSent(sequence, requestId, _origin.srcEid);\n        emit RandomWordsRequested(requestId, _origin.srcEid, _origin.sender, sequence, block.timestamp);\n    }\n\n    /**\n     * @notice Callback function used by VRF Coordinator\n     * @dev This function is called by the VRF Coordinator when randomness is ready\n     * @param requestId The request ID\n     * @param randomWords Array of random words\n     */\n    function rawFulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) external {\n        require(msg.sender == address(vrfCoordinator), \"Only VRF Coordinator can fulfill\");\n\n        VRFRequest storage request = vrfRequests[requestId];\n        require(request.sequence != 0, \"Invalid request ID\");\n        require(!request.fulfilled, \"Already fulfilled\");\n\n        request.fulfilled = true;\n        request.randomWord = randomWords[0];\n\n        uint32 targetGasLimit = chainGasLimits[request.sourceChainEid];\n        if (targetGasLimit == 0) {\n            targetGasLimit = defaultGasLimit;\n        }\n\n        bytes memory payload = abi.encode(request.sequence, request.randomWord);\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(targetGasLimit, 0);\n        MessagingFee memory fee = _quote(request.sourceChainEid, payload, options, false);\n\n        if (address(this).balance < fee.nativeFee) {\n            pendingResponses[request.sequence] = true;\n            emit ResponsePending(request.sequence, requestId, request.sourceChainEid, \"Insufficient balance for LayerZero fees\");\n            return;\n        }\n\n        _sendResponseToChain(request, fee);\n\n        emit RandomnessFulfilled(requestId, randomWords, request.sourceChainEid);\n    }\n\n    /**\n     * @dev Set peer for a specific endpoint ID (owner only)\n     * @param _eid The endpoint ID to set the peer for\n     * @param _peer The peer address (as bytes32)\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public override onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Add or remove support for a chain\n     * @param chainEid The LayerZero endpoint ID of the chain\n     * @param supported Whether the chain should be supported\n     * @param gasLimit Gas limit for responses to this chain\n     */\n    function setSupportedChain(uint32 chainEid, bool supported, uint32 gasLimit) external onlyOwner {\n        _setSupportedChain(chainEid, supported, gasLimit);\n    }\n\n    /**\n     * @notice Add a new chain with name (for better UX)\n     * @param chainEid The LayerZero endpoint ID of the chain\n     * @param chainName Human-readable name for the chain\n     * @param gasLimit Gas limit for responses to this chain\n     */\n    function addNewChain(uint32 chainEid, string calldata chainName, uint32 gasLimit) external onlyOwner {\n        require(!supportedChains[chainEid], \"Chain already supported\");\n        require(bytes(chainName).length > 0, \"Chain name required\");\n        \n        bool found = false;\n        for (uint i = 0; i < registeredChainEids.length; i++) {\n            if (registeredChainEids[i] == chainEid) {\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found) {\n            registeredChainEids.push(chainEid);\n        }\n        \n        chainNames[chainEid] = chainName;\n        _setSupportedChain(chainEid, true, gasLimit);\n    }\n\n    /**\n     * @notice Internal function to set chain support\n     */\n    function _setSupportedChain(uint32 chainEid, bool supported, uint32 gasLimit) internal {\n        supportedChains[chainEid] = supported;\n        if (supported) {\n            require(gasLimit >= 100000 && gasLimit <= 10000000, \"Invalid gas limit\");\n            chainGasLimits[chainEid] = gasLimit;\n        } else {\n            chainGasLimits[chainEid] = 0;\n        }\n        emit ChainSupportUpdated(chainEid, supported, gasLimit);\n    }\n\n    /**\n     * @notice Get supported chains info (EXPANDABLE VERSION)\n     */\n    function getSupportedChains() external view returns (\n        uint32[] memory eids,\n        bool[] memory supported,\n        uint32[] memory gasLimits\n    ) {\n        uint32[] memory baseChains = new uint32[](8);\n        baseChains[0] = SONIC_EID;\n        baseChains[1] = AVALANCHE_EID;\n        baseChains[2] = BASE_EID;\n        baseChains[3] = ETHEREUM_EID;\n        baseChains[4] = POLYGON_EID;\n        baseChains[5] = BSC_EID;\n        baseChains[6] = OPTIMISM_EID;\n        \n        uint256 totalChains = baseChains.length + registeredChainEids.length;\n        eids = new uint32[](totalChains);\n        supported = new bool[](totalChains);\n        gasLimits = new uint32[](totalChains);\n        \n        for (uint i = 0; i < baseChains.length; i++) {\n            eids[i] = baseChains[i];\n            supported[i] = supportedChains[baseChains[i]];\n            gasLimits[i] = chainGasLimits[baseChains[i]];\n        }\n        \n        for (uint i = 0; i < registeredChainEids.length; i++) {\n            uint256 index = baseChains.length + i;\n            eids[index] = registeredChainEids[i];\n            supported[index] = supportedChains[registeredChainEids[i]];\n            gasLimits[index] = chainGasLimits[registeredChainEids[i]];\n        }\n    }\n\n    /**\n     * @notice Get all registered chains with names\n     */\n    function getAllChainsWithNames() external view returns (\n        uint32[] memory eids,\n        string[] memory names,\n        bool[] memory supported,\n        uint32[] memory gasLimits\n    ) {\n        uint32[] memory baseChains = new uint32[](8);\n        baseChains[0] = SONIC_EID;\n        baseChains[1] = AVALANCHE_EID;\n        baseChains[2] = BASE_EID;\n        baseChains[3] = ETHEREUM_EID;\n        baseChains[4] = POLYGON_EID;\n        baseChains[5] = BSC_EID;\n        baseChains[6] = OPTIMISM_EID;\n\n        \n        string[] memory baseNames = new string[](8);\n        baseNames[0] = \"Sonic\";\n        baseNames[1] = \"Avalanche\";\n        baseNames[2] = \"Base\";\n        baseNames[3] = \"Ethereum\";\n        baseNames[4] = \"Polygon\";\n        baseNames[5] = \"BSC\";\n        baseNames[6] = \"Optimism\";\n\n        \n        uint256 totalChains = baseChains.length + registeredChainEids.length;\n        eids = new uint32[](totalChains);\n        names = new string[](totalChains);\n        supported = new bool[](totalChains);\n        gasLimits = new uint32[](totalChains);\n        \n        for (uint i = 0; i < baseChains.length; i++) {\n            eids[i] = baseChains[i];\n            names[i] = baseNames[i];\n            supported[i] = supportedChains[baseChains[i]];\n            gasLimits[i] = chainGasLimits[baseChains[i]];\n        }\n        \n        for (uint i = 0; i < registeredChainEids.length; i++) {\n            uint256 index = baseChains.length + i;\n            eids[index] = registeredChainEids[i];\n            names[index] = chainNames[registeredChainEids[i]];\n            supported[index] = supportedChains[registeredChainEids[i]];\n            gasLimits[index] = chainGasLimits[registeredChainEids[i]];\n        }\n    }\n\n    /**\n     * @notice Manual retry for pending responses\n     * @dev Call this after funding the contract to retry failed responses.\n     * @param sequence The sequence number to retry\n     */\n    function retryPendingResponse(uint64 sequence) external payable {\n        require(pendingResponses[sequence], \"No pending response for this sequence\");\n        \n        uint256 requestId = sequenceToRequestId[sequence];\n        require(requestId != 0, \"Invalid sequence\");\n        \n        VRFRequest storage request = vrfRequests[requestId];\n        require(request.fulfilled, \"VRF not fulfilled yet\");\n        require(!request.responseSent, \"Response already sent\");\n        \n        uint32 targetGasLimit = chainGasLimits[request.sourceChainEid];\n        if (targetGasLimit == 0) {\n            targetGasLimit = defaultGasLimit;\n        }\n        \n        bytes memory payload = abi.encode(request.sequence, request.randomWord);\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(targetGasLimit, 0);\n        MessagingFee memory fee = _quote(request.sourceChainEid, payload, options, false);\n        \n        require(address(this).balance >= fee.nativeFee, \"Insufficient contract balance for LayerZero fee\");\n        \n        delete pendingResponses[sequence];\n\n        _sendResponseToChain(request, fee);\n    }\n\n    /**\n     * @notice Quote LayerZero fee for sending response to any supported chain\n     * @param targetChainEid The chain to send the response to\n     */\n    function quoteSendToChain(uint32 targetChainEid) external view returns (MessagingFee memory fee) {\n        require(supportedChains[targetChainEid], \"Chain not supported\");\n        \n        uint32 targetGasLimit = chainGasLimits[targetChainEid];\n        if (targetGasLimit == 0) {\n            targetGasLimit = defaultGasLimit;\n        }\n        \n        bytes memory payload = abi.encode(uint64(1), uint256(12345));\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(targetGasLimit, 0);\n        return _quote(targetChainEid, payload, options, false);\n    }\n\n    /**\n     * @dev Internal function to send the VRF response back to the originating chain.\n     * @param _request The VRF request struct containing all necessary data.\n     * @param _fee The pre-calculated LayerZero messaging fee.\n     */\n    function _sendResponseToChain(VRFRequest storage _request, MessagingFee memory _fee) internal {\n        uint32 targetGasLimit = chainGasLimits[_request.sourceChainEid];\n        if (targetGasLimit == 0) {\n            targetGasLimit = defaultGasLimit;\n        }\n        \n        bytes memory payload = abi.encode(_request.sequence, _request.randomWord);\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(targetGasLimit, 0);\n\n        _request.responseSent = true;\n\n        _lzSend(\n            _request.sourceChainEid,  // ðŸ†• Send back to the originating chain\n            payload,\n            options,\n            _fee,\n            payable(owner()) // Refund any excess gas to the owner\n        );\n        \n        emit ResponseSentToChain(_request.sequence, _request.randomWord, _request.sourceChainEid, _fee.nativeFee);\n    }\n\n    /**\n     * @dev Set VRF 2.5 configuration (owner only)\n     */\n    function setVRFConfig(\n        uint256 _subscriptionId,\n        bytes32 _keyHash,\n        uint32 _callbackGasLimit,\n        uint16 _requestConfirmations,\n        bool _nativePayment\n    ) external onlyOwner {\n        require(_subscriptionId > 0, \"Invalid subscription ID\");\n        require(_keyHash != bytes32(0), \"Invalid key hash\");\n        require(_callbackGasLimit >= 40000 && _callbackGasLimit <= 2500000, \"Invalid callback gas limit\");\n        require(_requestConfirmations >= 3 && _requestConfirmations <= 200, \"Invalid request confirmations\");\n        \n        subscriptionId = _subscriptionId;\n        keyHash = _keyHash;\n        callbackGasLimit = _callbackGasLimit;\n        requestConfirmations = _requestConfirmations;\n        nativePayment = _nativePayment;\n        \n        emit VRFConfigUpdated(_subscriptionId, _keyHash, _callbackGasLimit, _requestConfirmations);\n    }\n\n    /**\n     * @dev Set minimum balance for responses (owner only)\n     */\n    function setMinimumBalance(uint256 _minimumBalance) external onlyOwner {\n        require(_minimumBalance <= 1 ether, \"Minimum balance too high\");\n        \n        uint256 oldBalance = minimumBalance;\n        minimumBalance = _minimumBalance;\n        emit MinimumBalanceUpdated(oldBalance, _minimumBalance);\n    }\n\n    /**\n     * @dev Set default gas limit (owner only)\n     */\n    function setDefaultGasLimit(uint32 _gasLimit) external onlyOwner {\n        require(_gasLimit >= 100000 && _gasLimit <= 10000000, \"Invalid gas limit\");\n        defaultGasLimit = _gasLimit;\n    }\n\n    /**\n     * @dev Fund contract with ETH for LayerZero fees\n     */\n    function fundContract() external payable {\n        require(msg.value > 0, \"Must send ETH to fund contract\");\n        emit ContractFunded(msg.sender, msg.value, address(this).balance);\n    }\n\n    /**\n     * @dev Override _payNative to handle payments from contract balance when msg.value is 0\n     * This is necessary for VRF callbacks where msg.value is 0 but the contract has ETH balance\n     */\n    function _payNative(uint256 _nativeFee) internal override returns (uint256 nativeFee) {\n        // If msg.value is 0 (e.g., from VRF callback), use contract balance\n        if (msg.value == 0) {\n            require(address(this).balance >= _nativeFee, \"Insufficient contract balance for LayerZero fee\");\n            return _nativeFee;\n        }\n        \n        // Otherwise, use the standard payment method\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Get request details by sequence\n     */\n    function getRequestBySequence(uint64 sequence) external view returns (\n        uint256 requestId,\n        bool exists,\n        bool fulfilled,\n        bool responseSent,\n        uint256 randomWord,\n        uint32 sourceChainEid,\n        uint256 timestamp\n    ) {\n        requestId = sequenceToRequestId[sequence];\n        if (requestId == 0) {\n            return (0, false, false, false, 0, 0, 0);\n        }\n        \n        VRFRequest storage request = vrfRequests[requestId];\n        return (\n            requestId,\n            true,\n            request.fulfilled,\n            request.responseSent,\n            request.randomWord,\n            request.sourceChainEid,  // ðŸ†• Include source chain info\n            request.timestamp\n        );\n    }\n\n    /**\n     * @dev Get request details by VRF request ID\n     */\n    function getRequestById(uint256 requestId) external view returns (\n        uint64 sequence,\n        bool exists,\n        bool fulfilled,\n        bool responseSent,\n        uint256 randomWord,\n        uint32 sourceChainEid,\n        uint256 timestamp\n    ) {\n        VRFRequest storage request = vrfRequests[requestId];\n        if (request.sequence == 0) {\n            return (0, false, false, false, 0, 0, 0);\n        }\n        \n        return (\n            request.sequence,\n            true,\n            request.fulfilled,\n            request.responseSent,\n            request.randomWord,\n            request.sourceChainEid,  // ðŸ†• Include source chain info\n            request.timestamp\n        );\n    }\n\n    /**\n     * @dev Check contract status\n     */\n    function getContractStatus() external view returns (\n        uint256 balance,\n        uint256 minBalance,\n        bool canSendResponses,\n        uint32 gasLimit,\n        uint256 supportedChainsCount\n    ) {\n        balance = address(this).balance;\n        minBalance = minimumBalance;\n        canSendResponses = balance >= minBalance;\n        gasLimit = defaultGasLimit;\n        \n        uint256 count = 0;\n        if (supportedChains[SONIC_EID]) count++;\n        if (supportedChains[AVALANCHE_EID]) count++;\n        if (supportedChains[BASE_EID]) count++;\n        if (supportedChains[ETHEREUM_EID]) count++;\n        supportedChainsCount = count;\n        \n        return (balance, minBalance, canSendResponses, gasLimit, supportedChainsCount);\n    }\n\n    /**\n     * @dev Withdraw ETH (owner only)\n     */\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No balance to withdraw\");\n        \n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    /**\n     * @dev Receive ETH for LayerZero fees\n     */\n    receive() external payable {}\n}\n\n"
    },
    "contracts/core/factory/CREATE2FactoryWithOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\n\n/**\n * @title CREATE2FactoryWithOwnership\n * @notice CREATE2 factory that automatically transfers ownership of deployed contracts\n * @dev Includes deployment tracking and salt management\n */\ncontract CREATE2FactoryWithOwnership is Ownable {\n    // Events\n    event ContractDeployed(\n        address indexed deployer,\n        address indexed deployed,\n        bytes32 indexed salt,\n        string contractType\n    );\n    \n    // Tracking\n    mapping(address => address[]) public deploymentsByDeployer;\n    mapping(address => bool) public isDeployedContract;\n    mapping(bytes32 => address) public deploymentBySalt;\n    mapping(address => string) public contractTypes;\n    \n    // Salt counter for automatic salt generation\n    uint256 private saltCounter;\n    \n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Deploy a contract using CREATE2 with automatic ownership transfer\n     * @param bytecode The bytecode of the contract to deploy\n     * @param salt The salt for deterministic deployment\n     * @param contractType A string identifier for the contract type\n     * @return deployed The address of the deployed contract\n     */\n    function deploy(\n        bytes memory bytecode,\n        bytes32 salt,\n        string memory contractType\n    ) public returns (address deployed) {\n        // Check if already deployed with this salt\n        require(deploymentBySalt[salt] == address(0), \"Salt already used\");\n        \n        // Deploy using CREATE2\n        assembly {\n            deployed := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n            if iszero(extcodesize(deployed)) {\n                revert(0, 0)\n            }\n        }\n        \n        // Try to transfer ownership to the deployer\n        (bool success,) = deployed.call(\n            abi.encodeWithSignature(\"transferOwnership(address)\", msg.sender)\n        );\n        \n        // If ownership transfer fails, try to set admin\n        if (!success) {\n            (success,) = deployed.call(\n                abi.encodeWithSignature(\"setAdmin(address)\", msg.sender)\n            );\n        }\n        \n        // Track deployment\n        deploymentsByDeployer[msg.sender].push(deployed);\n        isDeployedContract[deployed] = true;\n        deploymentBySalt[salt] = deployed;\n        contractTypes[deployed] = contractType;\n        \n        emit ContractDeployed(msg.sender, deployed, salt, contractType);\n    }\n    \n    /**\n     * @notice Deploy with auto-generated salt\n     * @param bytecode The bytecode of the contract to deploy\n     * @param contractType A string identifier for the contract type\n     * @return deployed The address of the deployed contract\n     */\n    function deployWithAutoSalt(\n        bytes memory bytecode,\n        string memory contractType\n    ) public returns (address deployed) {\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, saltCounter++));\n        return deploy(bytecode, salt, contractType);\n    }\n    \n    /**\n     * @notice Compute the deployment address for given bytecode and salt\n     * @param salt The salt for deterministic deployment\n     * @param bytecodeHash The keccak256 hash of the bytecode\n     * @return The computed address\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash\n    ) public view returns (address) {\n        return address(uint160(uint256(keccak256(abi.encodePacked(\n            bytes1(0xff),\n            address(this),\n            salt,\n            bytecodeHash\n        )))));\n    }\n    \n    /**\n     * @notice Get all deployments by a specific deployer\n     * @param deployer The address of the deployer\n     * @return An array of deployed contract addresses\n     */\n    function getDeployments(address deployer) public view returns (address[] memory) {\n        return deploymentsByDeployer[deployer];\n    }\n    \n    /**\n     * @notice Batch deploy multiple contracts\n     * @param bytecodes Array of bytecodes to deploy\n     * @param salts Array of salts for each deployment\n     * @param types Array of contract type identifiers\n     * @return deployed Array of deployed contract addresses\n     */\n    function batchDeploy(\n        bytes[] memory bytecodes,\n        bytes32[] memory salts,\n        string[] memory types\n    ) public returns (address[] memory deployed) {\n        require(\n            bytecodes.length == salts.length && salts.length == types.length,\n            \"Array length mismatch\"\n        );\n        \n        deployed = new address[](bytecodes.length);\n        for (uint256 i = 0; i < bytecodes.length; i++) {\n            deployed[i] = deploy(bytecodes[i], salts[i], types[i]);\n        }\n    }\n    \n    /**\n     * @notice Emergency function to transfer ownership of a deployed contract\n     * @dev Only callable by factory owner\n     * @param deployed The deployed contract address\n     * @param newOwner The new owner address\n     */\n    function emergencyTransferOwnership(\n        address deployed,\n        address newOwner\n    ) public onlyOwner {\n        require(isDeployedContract[deployed], \"Not a deployed contract\");\n        \n        (bool success,) = deployed.call(\n            abi.encodeWithSignature(\"transferOwnership(address)\", newOwner)\n        );\n        require(success, \"Ownership transfer failed\");\n    }\n} "
    },
    "contracts/core/factory/OmniDragonDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"./CREATE2FactoryWithOwnership.sol\";\n\n/**\n * @title OmniDragonDeployer\n * @dev Specialized deployer for OmniDragon ecosystem contracts\n * Ensures deterministic addresses across all chains for OmniDragon* contracts\n * \n * Nomenclature System:\n * - OmniDragon* = Universal contracts (same address all chains)\n * - Dragon* = Chain-specific contracts (different per chain)\n * \n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract OmniDragonDeployer is Ownable {\n    \n    // CREATE2 Factory\n    CREATE2FactoryWithOwnership public immutable factory;\n    \n    // Contract version for salt generation\n    string public constant VERSION = \"v1.0.0\";\n    \n    // Base salt for OmniDragon universal contracts\n    bytes32 public constant OMNIDRAGON_BASE_SALT = keccak256(\"OMNIDRAGON_ECOSYSTEM_2024\");\n    \n    // Deployment tracking\n    mapping(string => address) public deployedContracts; // contractName => address\n    mapping(string => bool) public isUniversalContract; // contractName => isUniversal\n    mapping(address => string) public contractNames; // address => contractName\n    \n    // Universal contract types (same address across all chains)\n    string[] public universalContractTypes = [\n        \"OmniDragonToken\",\n        \"OmniDragonLotteryManager\", \n        \"OmniDragonVRFConsumer\",\n        \"OmniDragonMarketOracle\",\n        \"OmniDragonRandomnessProvider\"\n    ];\n    \n    // Chain-specific contract types (different address per chain)\n    string[] public chainSpecificContractTypes = [\n        \"DragonRevenueDistributor\",\n        \"DragonFeeManager\",\n        \"DragonJackpotVault\",\n        \"DragonMarketOracle\",\n        \"DragonJackpotDistributor\"\n    ];\n    \n    // Events\n    event UniversalContractDeployed(\n        string indexed contractName,\n        address indexed contractAddress,\n        bytes32 salt,\n        uint256 chainId\n    );\n    \n    event ChainSpecificContractDeployed(\n        string indexed contractName,\n        address indexed contractAddress,\n        bytes32 salt,\n        uint256 chainId\n    );\n    \n    event ContractTypeRegistered(string contractName, bool isUniversal);\n    \n    constructor(address _factory) Ownable(msg.sender) {\n        require(_factory != address(0), \"Factory cannot be zero address\");\n        factory = CREATE2FactoryWithOwnership(_factory);\n        \n        // Register universal contract types\n        for (uint i = 0; i < universalContractTypes.length; i++) {\n            isUniversalContract[universalContractTypes[i]] = true;\n            emit ContractTypeRegistered(universalContractTypes[i], true);\n        }\n        \n        // Register chain-specific contract types\n        for (uint i = 0; i < chainSpecificContractTypes.length; i++) {\n            isUniversalContract[chainSpecificContractTypes[i]] = false;\n            emit ContractTypeRegistered(chainSpecificContractTypes[i], false);\n        }\n    }\n    \n    /**\n     * @dev Generate deterministic salt for universal contracts\n     * @param contractName Name of the contract (e.g., \"OmniDragonToken\")\n     * @return Deterministic salt that will be the same across all chains\n     */\n    function generateUniversalSalt(string memory contractName) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            OMNIDRAGON_BASE_SALT,\n            contractName,\n            VERSION\n        ));\n    }\n    \n    /**\n     * @dev Generate chain-specific salt for Dragon* contracts\n     * @param contractName Name of the contract (e.g., \"DragonFeeManager\")\n     * @return Chain-specific salt that will be different per chain\n     */\n    function generateChainSpecificSalt(string memory contractName) public view returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            OMNIDRAGON_BASE_SALT,\n            contractName,\n            VERSION,\n            block.chainid, // Makes it chain-specific\n            block.timestamp / 86400 // Daily rotation for additional uniqueness\n        ));\n    }\n    \n    /**\n     * @dev Deploy a universal OmniDragon contract (same address across chains)\n     * @param contractName Name of the contract\n     * @param bytecode Contract bytecode\n     * @return deployed Address of the deployed contract\n     */\n    function deployUniversalContract(\n        string memory contractName,\n        bytes memory bytecode\n    ) public onlyOwner returns (address deployed) {\n        require(isUniversalContract[contractName], \"Not a universal contract type\");\n        require(deployedContracts[contractName] == address(0), \"Contract already deployed\");\n        \n        bytes32 salt = generateUniversalSalt(contractName);\n        deployed = factory.deploy(bytecode, salt, contractName);\n        \n        // Track deployment\n        deployedContracts[contractName] = deployed;\n        contractNames[deployed] = contractName;\n        \n        emit UniversalContractDeployed(contractName, deployed, salt, block.chainid);\n    }\n    \n    /**\n     * @dev Deploy a chain-specific Dragon contract\n     * @param contractName Name of the contract\n     * @param bytecode Contract bytecode\n     * @return deployed Address of the deployed contract\n     */\n    function deployChainSpecificContract(\n        string memory contractName,\n        bytes memory bytecode\n    ) public onlyOwner returns (address deployed) {\n        require(!isUniversalContract[contractName], \"Use deployUniversalContract for universal types\");\n        require(deployedContracts[contractName] == address(0), \"Contract already deployed\");\n        \n        bytes32 salt = generateChainSpecificSalt(contractName);\n        deployed = factory.deploy(bytecode, salt, contractName);\n        \n        // Track deployment\n        deployedContracts[contractName] = deployed;\n        contractNames[deployed] = contractName;\n        \n        emit ChainSpecificContractDeployed(contractName, deployed, salt, block.chainid);\n    }\n    \n    /**\n     * @dev Predict the address of a universal contract across all chains\n     * @param contractName Name of the contract\n     * @param bytecodeHash Keccak256 hash of the contract bytecode\n     * @return predicted The predicted address (same across all chains)\n     */\n    function predictUniversalAddress(\n        string memory contractName,\n        bytes32 bytecodeHash\n    ) public view returns (address predicted) {\n        require(isUniversalContract[contractName], \"Not a universal contract type\");\n        \n        bytes32 salt = generateUniversalSalt(contractName);\n        return factory.computeAddress(salt, bytecodeHash);\n    }\n    \n    /**\n     * @dev Predict the address of a chain-specific contract\n     * @param contractName Name of the contract\n     * @param bytecodeHash Keccak256 hash of the contract bytecode\n     * @return predicted The predicted address (chain-specific)\n     */\n    function predictChainSpecificAddress(\n        string memory contractName,\n        bytes32 bytecodeHash\n    ) public view returns (address predicted) {\n        require(!isUniversalContract[contractName], \"Use predictUniversalAddress for universal types\");\n        \n        bytes32 salt = generateChainSpecificSalt(contractName);\n        return factory.computeAddress(salt, bytecodeHash);\n    }\n    \n    /**\n     * @dev Batch deploy multiple contracts\n     * @param _contractNames Array of contract names\n     * @param bytecodes Array of contract bytecodes\n     * @return deployed Array of deployed addresses\n     */\n    function batchDeploy(\n        string[] memory _contractNames,\n        bytes[] memory bytecodes\n    ) public onlyOwner returns (address[] memory deployed) {\n        require(_contractNames.length == bytecodes.length, \"Array length mismatch\");\n        \n        deployed = new address[](_contractNames.length);\n        \n        for (uint i = 0; i < _contractNames.length; i++) {\n            if (isUniversalContract[_contractNames[i]]) {\n                deployed[i] = deployUniversalContract(_contractNames[i], bytecodes[i]);\n            } else {\n                deployed[i] = deployChainSpecificContract(_contractNames[i], bytecodes[i]);\n            }\n        }\n    }\n    \n    /**\n     * @dev Register a new contract type\n     * @param contractName Name of the contract\n     * @param universal Whether it's a universal contract\n     */\n    function registerContractType(\n        string memory contractName,\n        bool universal\n    ) public onlyOwner {\n        isUniversalContract[contractName] = universal;\n        \n        if (universal) {\n            universalContractTypes.push(contractName);\n        } else {\n            chainSpecificContractTypes.push(contractName);\n        }\n        \n        emit ContractTypeRegistered(contractName, universal);\n    }\n    \n    /**\n     * @dev Get deployment info for a contract\n     * @param contractName Name of the contract\n     * @return deployed Address of the deployed contract\n     * @return universal Whether it's a universal contract\n     * @return salt The salt used for deployment\n     */\n    function getDeploymentInfo(string memory contractName) \n        public \n        view \n        returns (\n            address deployed,\n            bool universal,\n            bytes32 salt\n        ) \n    {\n        deployed = deployedContracts[contractName];\n        universal = isUniversalContract[contractName];\n        \n        if (universal) {\n            salt = generateUniversalSalt(contractName);\n        } else {\n            salt = generateChainSpecificSalt(contractName);\n        }\n    }\n    \n    /**\n     * @dev Get all universal contract types\n     */\n    function getUniversalContractTypes() public view returns (string[] memory) {\n        return universalContractTypes;\n    }\n    \n    /**\n     * @dev Get all chain-specific contract types\n     */\n    function getChainSpecificContractTypes() public view returns (string[] memory) {\n        return chainSpecificContractTypes;\n    }\n    \n    /**\n     * @dev Get contract name by address\n     * @param contractAddress Address of the contract\n     * @return Contract name\n     */\n    function getContractName(address contractAddress) public view returns (string memory) {\n        return contractNames[contractAddress];\n    }\n    \n    /**\n     * @dev Check if a contract is deployed\n     * @param contractName Name of the contract\n     * @return Whether the contract is deployed\n     */\n    function isDeployed(string memory contractName) public view returns (bool) {\n        return deployedContracts[contractName] != address(0);\n    }\n    \n    /**\n     * @dev Get the current chain ID\n     * @return Current chain ID\n     */\n    function getChainId() public view returns (uint256) {\n        return block.chainid;\n    }\n} "
    },
    "contracts/core/factory/OmniDragonTokenDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title OmniDragonTokenDeployer\n * @dev Specialized deployer for omniDRAGON tokens with proper ownership handling\n * \n * This contract solves the CREATE2 ownership problem by:\n * 1. Deploying the token via CREATE2\n * 2. Immediately transferring ownership to the specified address\n * 3. Supporting universal (same address) and chain-specific deployments\n */\ncontract OmniDragonTokenDeployer is Ownable, ReentrancyGuard {\n    \n    // ======== EVENTS ========\n    event TokenDeployed(\n        address indexed token,\n        address indexed owner,\n        bytes32 indexed salt,\n        string deploymentType\n    );\n    \n    event OwnershipTransferred(\n        address indexed token,\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    \n    // ======== ERRORS ========\n    error DeploymentFailed();\n    error OwnershipTransferFailed();\n    error ZeroAddress();\n    error InvalidBytecode();\n    \n    // ======== STRUCTS ========\n    struct DeploymentResult {\n        address deployedAddress;\n        bytes32 salt;\n        bool ownershipTransferred;\n    }\n    \n    // ======== STORAGE ========\n    mapping(bytes32 => address) public deployedTokens;\n    mapping(address => bool) public isDeployedByUs;\n    \n    uint256 public deploymentCount;\n    \n    // ======== CONSTRUCTOR ========\n    constructor() Ownable(msg.sender) {\n        // Contract is ready for deployment operations\n    }\n    \n    // ======== CORE DEPLOYMENT FUNCTIONS ========\n    \n    /**\n     * @dev Deploy omniDRAGON token with immediate ownership transfer\n     * @param bytecode The compiled bytecode of the omniDRAGON contract\n     * @param newOwner The address that should own the deployed token\n     * @param salt Custom salt for CREATE2 (use 0x0 for auto-generated)\n     * @return result Deployment result with address and ownership status\n     */\n    function deployWithOwnership(\n        bytes memory bytecode,\n        address newOwner,\n        bytes32 salt\n    ) external nonReentrant returns (DeploymentResult memory result) {\n        if (newOwner == address(0)) revert ZeroAddress();\n        if (bytecode.length == 0) revert InvalidBytecode();\n        \n        // Generate salt if not provided\n        if (salt == bytes32(0)) {\n            salt = generateSalt(newOwner, block.timestamp);\n        }\n        \n        // Deploy via CREATE2\n        address deployedToken = _deployCreate2(bytecode, salt);\n        if (deployedToken == address(0)) revert DeploymentFailed();\n        \n        // Record deployment\n        deployedTokens[salt] = deployedToken;\n        isDeployedByUs[deployedToken] = true;\n        deploymentCount++;\n        \n        // Transfer ownership\n        bool ownershipTransferred = _transferOwnership(deployedToken, newOwner);\n        \n        result = DeploymentResult({\n            deployedAddress: deployedToken,\n            salt: salt,\n            ownershipTransferred: ownershipTransferred\n        });\n        \n        emit TokenDeployed(deployedToken, newOwner, salt, \"WithOwnership\");\n        \n        return result;\n    }\n    \n    /**\n     * @dev Deploy universal omniDRAGON (same address on all chains)\n     * @param bytecode The compiled bytecode of the omniDRAGON contract\n     * @param newOwner The address that should own the deployed token\n     * @return result Deployment result with address and ownership status\n     */\n    function deployUniversal(\n        bytes memory bytecode,\n        address newOwner\n    ) external nonReentrant returns (DeploymentResult memory result) {\n        if (newOwner == address(0)) revert ZeroAddress();\n        if (bytecode.length == 0) revert InvalidBytecode();\n        \n        // Generate universal salt (same on all chains)\n        bytes32 universalSalt = generateUniversalSalt(\"omniDRAGON\", \"v1.0.0\");\n        \n        // Check if already deployed\n        if (deployedTokens[universalSalt] != address(0)) {\n            // Return existing deployment info\n            address existingToken = deployedTokens[universalSalt];\n            return DeploymentResult({\n                deployedAddress: existingToken,\n                salt: universalSalt,\n                ownershipTransferred: true // Assume already handled\n            });\n        }\n        \n        // Deploy via CREATE2\n        address deployedToken = _deployCreate2(bytecode, universalSalt);\n        if (deployedToken == address(0)) revert DeploymentFailed();\n        \n        // Record deployment\n        deployedTokens[universalSalt] = deployedToken;\n        isDeployedByUs[deployedToken] = true;\n        deploymentCount++;\n        \n        // Transfer ownership\n        bool ownershipTransferred = _transferOwnership(deployedToken, newOwner);\n        \n        result = DeploymentResult({\n            deployedAddress: deployedToken,\n            salt: universalSalt,\n            ownershipTransferred: ownershipTransferred\n        });\n        \n        emit TokenDeployed(deployedToken, newOwner, universalSalt, \"Universal\");\n        \n        return result;\n    }\n    \n    /**\n     * @dev Deploy chain-specific omniDRAGON (different address per chain)\n     * @param bytecode The compiled bytecode of the omniDRAGON contract\n     * @param newOwner The address that should own the deployed token\n     * @return result Deployment result with address and ownership status\n     */\n    function deployChainSpecific(\n        bytes memory bytecode,\n        address newOwner\n    ) external nonReentrant returns (DeploymentResult memory result) {\n        if (newOwner == address(0)) revert ZeroAddress();\n        if (bytecode.length == 0) revert InvalidBytecode();\n        \n        // Generate chain-specific salt\n        bytes32 chainSalt = generateChainSpecificSalt(\"omniDRAGON\", \"v1.0.0\", block.chainid);\n        \n        // Check if already deployed\n        if (deployedTokens[chainSalt] != address(0)) {\n            // Return existing deployment info\n            address existingToken = deployedTokens[chainSalt];\n            return DeploymentResult({\n                deployedAddress: existingToken,\n                salt: chainSalt,\n                ownershipTransferred: true // Assume already handled\n            });\n        }\n        \n        // Deploy via CREATE2\n        address deployedToken = _deployCreate2(bytecode, chainSalt);\n        if (deployedToken == address(0)) revert DeploymentFailed();\n        \n        // Record deployment\n        deployedTokens[chainSalt] = deployedToken;\n        isDeployedByUs[deployedToken] = true;\n        deploymentCount++;\n        \n        // Transfer ownership\n        bool ownershipTransferred = _transferOwnership(deployedToken, newOwner);\n        \n        result = DeploymentResult({\n            deployedAddress: deployedToken,\n            salt: chainSalt,\n            ownershipTransferred: ownershipTransferred\n        });\n        \n        emit TokenDeployed(deployedToken, newOwner, chainSalt, \"ChainSpecific\");\n        \n        return result;\n    }\n    \n    // ======== INTERNAL FUNCTIONS ========\n    \n    /**\n     * @dev Deploy contract using CREATE2\n     * @param bytecode Contract bytecode\n     * @param salt Salt for CREATE2\n     * @return deployed Address of deployed contract\n     */\n    function _deployCreate2(bytes memory bytecode, bytes32 salt) internal returns (address deployed) {\n        assembly {\n            deployed := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n    }\n    \n    /**\n     * @dev Transfer ownership of deployed token\n     * @param token Address of the deployed token\n     * @param newOwner New owner address\n     * @return success Whether ownership transfer succeeded\n     */\n    function _transferOwnership(address token, address newOwner) internal returns (bool success) {\n        try this.externalOwnershipTransfer(token, newOwner) {\n            emit OwnershipTransferred(token, address(this), newOwner);\n            return true;\n        } catch {\n            // Ownership transfer failed, but deployment succeeded\n            return false;\n        }\n    }\n    \n    /**\n     * @dev External function to handle ownership transfer (for try/catch)\n     * @param token Address of the token\n     * @param newOwner New owner address\n     */\n    function externalOwnershipTransfer(address token, address newOwner) external {\n        require(msg.sender == address(this), \"Only self\");\n        \n        // Call transferOwnership on the deployed token\n        (bool success, ) = token.call(\n            abi.encodeWithSignature(\"transferOwnership(address)\", newOwner)\n        );\n        \n        if (!success) revert OwnershipTransferFailed();\n    }\n    \n    // ======== SALT GENERATION ========\n    \n    /**\n     * @dev Generate universal salt (same on all chains)\n     * @param contractName Name of the contract\n     * @param version Version string\n     * @return salt Universal salt\n     */\n    function generateUniversalSalt(\n        string memory contractName,\n        string memory version\n    ) public pure returns (bytes32 salt) {\n        return keccak256(abi.encodePacked(\"UNIVERSAL\", contractName, version));\n    }\n    \n    /**\n     * @dev Generate chain-specific salt\n     * @param contractName Name of the contract\n     * @param version Version string\n     * @param chainId Chain ID\n     * @return salt Chain-specific salt\n     */\n    function generateChainSpecificSalt(\n        string memory contractName,\n        string memory version,\n        uint256 chainId\n    ) public pure returns (bytes32 salt) {\n        return keccak256(abi.encodePacked(\"CHAIN\", contractName, version, chainId));\n    }\n    \n    /**\n     * @dev Generate custom salt with timestamp\n     * @param owner Owner address\n     * @param timestamp Timestamp\n     * @return salt Custom salt\n     */\n    function generateSalt(address owner, uint256 timestamp) public pure returns (bytes32 salt) {\n        return keccak256(abi.encodePacked(\"CUSTOM\", owner, timestamp));\n    }\n    \n    // ======== PREDICTION FUNCTIONS ========\n    \n    /**\n     * @dev Predict deployment address\n     * @param bytecode Contract bytecode\n     * @param salt Salt for CREATE2\n     * @return predicted Predicted deployment address\n     */\n    function predictAddress(\n        bytes memory bytecode,\n        bytes32 salt\n    ) external view returns (address predicted) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(bytecode)\n            )\n        );\n        \n        return address(uint160(uint256(hash)));\n    }\n    \n    /**\n     * @dev Predict universal deployment address\n     * @param bytecode Contract bytecode\n     * @return predicted Predicted address\n     * @return salt Universal salt used\n     */\n    function predictUniversalAddress(\n        bytes memory bytecode\n    ) external view returns (address predicted, bytes32 salt) {\n        salt = generateUniversalSalt(\"omniDRAGON\", \"v1.0.0\");\n        predicted = this.predictAddress(bytecode, salt);\n    }\n    \n    /**\n     * @dev Predict chain-specific deployment address\n     * @param bytecode Contract bytecode\n     * @return predicted Predicted address\n     * @return salt Chain-specific salt used\n     */\n    function predictChainSpecificAddress(\n        bytes memory bytecode\n    ) external view returns (address predicted, bytes32 salt) {\n        salt = generateChainSpecificSalt(\"omniDRAGON\", \"v1.0.0\", block.chainid);\n        predicted = this.predictAddress(bytecode, salt);\n    }\n    \n    // ======== VIEW FUNCTIONS ========\n    \n    /**\n     * @dev Check if token was deployed by this contract\n     * @param token Token address\n     * @return deployed Whether token was deployed by us\n     */\n    function isTokenDeployedByUs(address token) external view returns (bool deployed) {\n        return isDeployedByUs[token];\n    }\n    \n    /**\n     * @dev Get deployment info by salt\n     * @param salt Deployment salt\n     * @return tokenAddress Address of deployed token\n     */\n    function getDeploymentBySalt(bytes32 salt) external view returns (address tokenAddress) {\n        return deployedTokens[salt];\n    }\n    \n    // ======== EMERGENCY FUNCTIONS ========\n    \n    /**\n     * @dev Emergency function to transfer ownership of a token we deployed\n     * @param token Token address\n     * @param newOwner New owner address\n     */\n    function emergencyTransferOwnership(\n        address token,\n        address newOwner\n    ) external onlyOwner {\n        if (!isDeployedByUs[token]) revert(\"Not deployed by us\");\n        if (newOwner == address(0)) revert ZeroAddress();\n        \n        bool success = _transferOwnership(token, newOwner);\n        if (!success) revert OwnershipTransferFailed();\n    }\n    \n    /**\n     * @dev Emergency pause function\n     */\n    function pause() external onlyOwner {\n        // Could implement pausable functionality if needed\n    }\n    \n    // ======== RECEIVE FUNCTION ========\n    receive() external payable {\n        // Allow receiving ETH for gas fees\n    }\n} "
    },
    "contracts/core/governance/fees/DragonFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { Pausable } from \"lib/openzeppelin-contracts/contracts/utils/Pausable.sol\";\nimport { DragonMath } from \"../../../libraries/math/DragonMath.sol\";\n\n// External Interfaces\nimport { IUniswapV2Router02 } from \"../../../interfaces/external/uniswap/v2/IUniswapV2Router02.sol\";\n\n/**\n * @title DragonFeeManager\n * @dev Lightweight fee manager that uses DragonMath for calculations\n *\n * Replaces the heavy DragonAdaptiveFeeManager by separating concerns:\n * - This contract: State management and admin functions\n * - DragonMath library: Pure mathematical calculations\n *\n * Fee structure:\n * - Burn Fee: Fixed at 0.69% (69 basis points) - non-configurable\n * - Jackpot Fee: Configurable, defaults to 6.9% (690 basis points)\n * - LP Fee: Automatically calculated as (totalFee - jackpotFee - burnFee)\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract DragonFeeManager is Ownable {\n    // Custom Errors\n    error TotalFeeTooLow();\n    error FeesExceedTotal();\n    error FeeTooHigh();\n    error IntervalMustBeGreaterThanZero();\n    error AlreadyInitialized();\n\n    // Initialization flag\n    bool public initialized;\n\n    // Fee configuration\n    uint256 public totalFee;            // Total fee percentage (scaled by 1e4, e.g. 1000 = 10%)\n    uint256 public burnFee;             // Burn fee percentage (always BASE_BURN_BPS = 69)\n\n    // Current fee allocation (cached from last calculation)\n    uint256 public jackpotFee;          // Current jackpot fee (scaled by 1e4)\n    uint256 public liquidityFee;        // Current LP fee (calculated as: totalFee - jackpotFee - burnFee)\n\n    // Market state tracking\n    uint256 public jackpotSize;         // Current jackpot size\n    uint256 public cumulativeVolume;    // Cumulative trading volume\n    uint256 public dailyVolume;         // Approximate daily volume\n    uint256 public lastVolumeReset;     // Timestamp of last volume reset\n    uint256 public volumeUpdateInterval; // Interval between volume resets (seconds)\n\n    // Update control\n    uint256 public feeUpdateInterval;   // Minimum time between fee updates (seconds)\n    uint256 public lastFeeUpdate;       // Timestamp of last fee update\n    bool public adaptiveFeesEnabled;    // Whether adaptive fees are enabled\n\n    // Events\n    event FeeUpdated(uint256 jackpotFee, uint256 liquidityFee, uint256 burnFee, uint256 totalFee);\n    event JackpotSizeUpdated(uint256 newSize);\n    event VolumeUpdated(uint256 newVolume);\n    event AdaptiveFeesToggled(bool enabled);\n    event Initialized(uint256 totalFee, uint256 jackpotFee);\n\n    /**\n     * @dev Constructor\n     * @param _totalFee Initial total fee (scaled by 1e4, e.g. 1000 = 10%)\n     * @param _initialJackpotFee Initial jackpot fee (scaled by 1e4)\n     */\n    constructor(\n        uint256 _totalFee,\n        uint256 _initialJackpotFee\n    ) Ownable(msg.sender) {\n        if (_totalFee <= DragonMath.BASE_BURN_BPS) revert TotalFeeTooLow();\n        if (_initialJackpotFee + DragonMath.BASE_BURN_BPS > _totalFee) revert FeesExceedTotal();\n\n        // Initialize fee structure with fixed burn fee\n        totalFee = _totalFee;\n        burnFee = DragonMath.BASE_BURN_BPS; // Always 69 (0.69%)\n        jackpotFee = _initialJackpotFee;\n        liquidityFee = _totalFee - _initialJackpotFee - DragonMath.BASE_BURN_BPS;\n\n        // Initialize volume tracking\n        lastVolumeReset = block.timestamp;\n        volumeUpdateInterval = 1 days;\n        feeUpdateInterval = 1 days;\n\n        // Enable adaptive fees by default\n        adaptiveFeesEnabled = true;\n\n        // Mark as initialized if constructor is called with non-placeholder values\n        initialized = !(_totalFee == 1000 && _initialJackpotFee == 690);\n\n        // Register for Sonic FeeM automatically\n    }\n\n    /**\n     * @dev Initialize the contract after deployment with placeholder values\n     * @param _totalFee Initial total fee (scaled by 1e4, e.g. 1000 = 10%)\n     * @param _initialJackpotFee Initial jackpot fee (scaled by 1e4)\n     */\n    function initialize(\n        uint256 _totalFee,\n        uint256 _initialJackpotFee\n    ) external onlyOwner {\n        if (initialized) revert AlreadyInitialized();\n\n        if (_totalFee <= DragonMath.BASE_BURN_BPS) revert TotalFeeTooLow();\n        if (_initialJackpotFee + DragonMath.BASE_BURN_BPS > _totalFee) revert FeesExceedTotal();\n\n        // Set fee structure with fixed burn fee\n        totalFee = _totalFee;\n        burnFee = DragonMath.BASE_BURN_BPS; // Always 69 (0.69%)\n        jackpotFee = _initialJackpotFee;\n        liquidityFee = _totalFee - _initialJackpotFee - DragonMath.BASE_BURN_BPS;\n\n        // Initialize volume tracking\n        lastVolumeReset = block.timestamp;\n        volumeUpdateInterval = 1 days;\n        feeUpdateInterval = 1 days;\n\n        // Enable adaptive fees by default\n        adaptiveFeesEnabled = true;\n\n        // Mark as initialized\n        initialized = true;\n\n        emit Initialized(_totalFee, _initialJackpotFee);\n    }\n\n    /**\n     * @notice Update jackpot size (called when jackpot changes)\n     * @param _newJackpotSize Current jackpot size\n     */\n    function updateJackpotSize(uint256 _newJackpotSize) external onlyOwner {\n        jackpotSize = _newJackpotSize;\n        emit JackpotSizeUpdated(_newJackpotSize);\n\n        // Consider updating fees if conditions are met\n        _maybeUpdateFees();\n    }\n\n    /**\n     * @notice Add transaction volume\n     * @param _volumeAmount Amount to add to volume tracking\n     */\n    function addVolume(uint256 _volumeAmount) external onlyOwner {\n        // Add to cumulative volume\n        cumulativeVolume += _volumeAmount;\n\n        // Add to daily volume approximation\n        dailyVolume += _volumeAmount;\n\n        // Check if it's time to reset the daily volume counter\n        if (block.timestamp >= lastVolumeReset + volumeUpdateInterval) {\n            // Update the daily volume metric\n            lastVolumeReset = block.timestamp;\n            emit VolumeUpdated(dailyVolume);\n\n            // Reset daily volume counter\n            dailyVolume = 0;\n\n            // Consider updating fees if conditions are met\n            _maybeUpdateFees();\n        }\n    }\n\n    /**\n     * @notice Force an update of fee allocation\n     */\n    function updateFees() external onlyOwner {\n        _updateFees();\n    }\n\n    /**\n     * @notice Get current fee percentages\n     * @return _jackpotFee Current jackpot fee\n     * @return _liquidityFee Current liquidity provider fee\n     * @return _burnFee Current burn fee\n     * @return _totalFee Total fee\n     */\n    function getFees() external view returns (\n        uint256 _jackpotFee,\n        uint256 _liquidityFee,\n        uint256 _burnFee,\n        uint256 _totalFee\n    ) {\n        return (jackpotFee, liquidityFee, burnFee, totalFee);\n    }\n\n    /**\n     * @notice Calculate the optimal fee allocation based on current conditions\n     * @param _jackpotSize Current jackpot size\n     * @param _dailyVolume Approximate daily volume\n     * @return _jackpotFee Calculated jackpot fee percentage (scaled by 1e4)\n     * @return _liquidityFee Calculated liquidity fee percentage (scaled by 1e4)\n     */\n    function calculateAdaptiveFees(\n        uint256 _jackpotSize,\n        uint256 _dailyVolume\n    ) public view returns (\n        uint256 _jackpotFee,\n        uint256 _liquidityFee\n    ) {\n        // If adaptive fees are disabled, return current fees\n        if (!adaptiveFeesEnabled) {\n            return (jackpotFee, liquidityFee);\n        }\n\n        // Use DragonMath library for calculations\n        DragonMath.FeeAllocation memory allocation = DragonMath.calculateAdaptiveFees(\n            _jackpotSize,\n            _dailyVolume,\n            totalFee\n        );\n\n        return (allocation.jackpotFeeBps, allocation.lpFeeBps);\n    }\n\n    /**\n     * @notice Update fees if conditions are met\n     */\n    function _maybeUpdateFees() internal {\n        // Check if enough time has passed since last update\n        if (block.timestamp >= lastFeeUpdate + feeUpdateInterval) {\n            _updateFees();\n        }\n    }\n\n    /**\n     * @notice Update fee allocation based on current conditions\n     */\n    function _updateFees() internal {\n        // Skip if adaptive fees are disabled\n        if (!adaptiveFeesEnabled) return;\n\n        // Calculate new fees using DragonMath\n        (uint256 newJackpotFee, uint256 newLiquidityFee) = calculateAdaptiveFees(\n            jackpotSize,\n            dailyVolume\n        );\n\n        // Update fees\n        jackpotFee = newJackpotFee;\n        liquidityFee = newLiquidityFee;\n        lastFeeUpdate = block.timestamp;\n\n        emit FeeUpdated(jackpotFee, liquidityFee, burnFee, totalFee);\n    }\n\n    /***************************************************************************\n     *                              ADMIN FUNCTIONS                            *\n     ***************************************************************************/\n\n    /**\n     * @notice Update total fee\n     * @param _totalFee New total fee (scaled by 1e4)\n     */\n    function updateTotalFee(uint256 _totalFee) external onlyOwner {\n        if (_totalFee < DragonMath.BASE_BURN_BPS) revert TotalFeeTooLow();\n        if (_totalFee > 2000) revert FeeTooHigh();\n\n        totalFee = _totalFee;\n\n        // Recalculate other fees\n        _updateFees();\n    }\n\n    /**\n     * @notice Set fee update interval\n     * @param _intervalSeconds New interval in seconds\n     */\n    function setFeeUpdateInterval(uint256 _intervalSeconds) external onlyOwner {\n        if (_intervalSeconds == 0) revert IntervalMustBeGreaterThanZero();\n        feeUpdateInterval = _intervalSeconds;\n    }\n\n    /**\n     * @notice Set volume update interval\n     * @param _intervalSeconds New interval in seconds\n     */\n    function setVolumeUpdateInterval(uint256 _intervalSeconds) external onlyOwner {\n        if (_intervalSeconds == 0) revert IntervalMustBeGreaterThanZero();\n        volumeUpdateInterval = _intervalSeconds;\n    }\n\n    /**\n     * @notice Toggle adaptive fees\n     * @param _enabled Whether to enable adaptive fees\n     */\n    function setAdaptiveFeesEnabled(bool _enabled) external onlyOwner {\n        adaptiveFeesEnabled = _enabled;\n        emit AdaptiveFeesToggled(_enabled);\n    }\n\n    /**\n     * @notice Check if this contract is registered for Sonic FeeM\n     * @return isRegistered Whether the contract is registered for fee monetization\n     */\n    function checkFeeMStatus() external view returns (bool isRegistered) {\n    }\n}\n"
    },
    "contracts/core/governance/partners/DragonPartnerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"../../../libraries/security/ReentrancyGuard.sol\";\nimport {IDragonPartnerFactory} from \"../../../interfaces/governance/partners/IDragonPartnerFactory.sol\";\nimport {DragonPartnerPool} from \"./DragonPartnerPool.sol\";\nimport \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../../../interfaces/governance/partners/IDragonPartnerRegistry.sol\";\n\n/**\n * @title DragonPartnerFactory\n * @dev Factory contract for creating and managing Dragon partner pools\n *\n * Enables ecosystem partnerships through dedicated liquidity pools and fee sharing\n * Streamlines partner onboarding and pool creation for the OmniDragon ecosystem\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract DragonPartnerFactory is Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // State variables\n    address public immutable partnerRegistry;\n    address public veDRAGONBoostManager;\n    address public treasury;\n    address public jackpot;\n    address public defaultStakingToken;\n\n    // Pool tracking\n    mapping(uint256 => address) public partnerPools;\n    EnumerableSet.AddressSet private poolSet;\n\n    // Configuration\n    uint256 public defaultFeePercentage = 500; // 5% default fee\n    bool public onlyOwnerCanCreate = true; // Only owner can create pools initially\n\n    // Events\n    event PartnerPoolCreated(uint256 indexed partnerId, address indexed partnerAddress, address poolAddress, address stakingToken);\n    event PartnerPoolInitialized(address indexed poolAddress, address stakingToken);\n    event ConfigurationUpdated(string parameter, uint256 value);\n    event AddressUpdated(string parameter, address value);\n    event PermissionUpdated(string permission, bool value);\n\n    /**\n     * @dev Constructor\n     * @param _partnerRegistry Partner registry address\n     * @param _veDRAGONBoostManager veDRAGON boost manager address\n     * @param _treasury Treasury address\n     * @param _jackpot Jackpot address\n     * @param _defaultStakingToken Default staking token address\n     */\n    constructor(\n        address _partnerRegistry,\n        address _veDRAGONBoostManager,\n        address _treasury,\n        address _jackpot,\n        address _defaultStakingToken\n    ) Ownable(msg.sender) {\n        require(_partnerRegistry != address(0), \"Zero address: partnerRegistry\");\n        require(_veDRAGONBoostManager != address(0), \"Zero address: veDRAGONBoostManager\");\n        require(_treasury != address(0), \"Zero address: treasury\");\n        require(_jackpot != address(0), \"Zero address: jackpot\");\n        require(_defaultStakingToken != address(0), \"Zero address: token\");\n\n        partnerRegistry = _partnerRegistry;\n        veDRAGONBoostManager = _veDRAGONBoostManager;\n        treasury = _treasury;\n        jackpot = _jackpot;\n        defaultStakingToken = _defaultStakingToken;\n\n        // Register for Sonic FeeM automatically\n    }\n\n    /**\n     * @dev Modifier for authorized creators\n     */\n    modifier canCreate() {\n        if (onlyOwnerCanCreate) {\n            require(msg.sender == owner(), \"Not authorized\");\n        }\n        _;\n    }\n\n    /**\n     * @dev Create a new partner pool\n     * @param _partnerId ID of the partner\n     * @param _stakingToken Token to use for staking (optional, defaults to defaultStakingToken)\n     * @return poolAddress Address of the new partner pool\n     */\n    function createPartnerPool(\n        uint256 _partnerId,\n        address _stakingToken\n    ) external returns (address poolAddress) {\n        // Check if partner exists and is active\n        address partnerAddress = IDragonPartnerRegistry(partnerRegistry).partnerList(_partnerId);\n        require(partnerAddress != address(0), \"Partner does not exist\");\n\n        bool isActive = IDragonPartnerRegistry(partnerRegistry).isPartnerActive(partnerAddress);\n        require(isActive, \"Partner not active\");\n\n        // Use default values if not specified\n        uint256 feePercentage = defaultFeePercentage;\n        require(feePercentage <= 5000, \"Fee too high\");\n\n        address stakingToken = _stakingToken != address(0) ? _stakingToken : defaultStakingToken;\n\n        // Deploy new pool\n        DragonPartnerPool pool = new DragonPartnerPool(\n            partnerAddress,\n            veDRAGONBoostManager,\n            treasury,\n            jackpot,\n            feePercentage\n        );\n\n        // Store pool address\n        poolAddress = address(pool);\n        partnerPools[_partnerId] = poolAddress;\n        poolSet.add(poolAddress);\n\n        // Initialize pool\n        pool.initialize(partnerRegistry, stakingToken);\n        pool.transferOwnership(owner());\n\n        emit PartnerPoolCreated(_partnerId, partnerAddress, poolAddress, stakingToken);\n\n        return poolAddress;\n    }\n\n    /**\n     * @dev Get the pool address for a partner\n     * @param _partnerId Partner ID\n     * @return Pool address\n     */\n    function getPartnerPool(uint256 _partnerId) external view returns (address) {\n        return partnerPools[_partnerId];\n    }\n\n    /**\n     * @dev Get total number of pools\n     * @return Number of pools\n     */\n    function getPoolCount() external view returns (uint256) {\n        return poolSet.length();\n    }\n\n    /**\n     * @dev Get pool at index\n     * @param _index Index in the pool array\n     * @return Pool address\n     */\n    function getPoolAt(uint256 _index) external view returns (address) {\n        require(_index < poolSet.length(), \"Index out of bounds\");\n        return poolSet.at(_index);\n    }\n\n    /**\n     * @dev Set default fee percentage\n     * @param _feePercentage New default fee percentage\n     */\n    function setDefaultFeePercentage(uint256 _feePercentage) external onlyOwner {\n        require(_feePercentage <= 5000, \"Fee too high\");\n        defaultFeePercentage = _feePercentage;\n        emit ConfigurationUpdated(\"defaultFeePercentage\", _feePercentage);\n    }\n\n    /**\n     * @dev Set the veDRAGON boost manager address\n     * @param _veDRAGONBoostManager New veDRAGON boost manager address\n     */\n    function setVeDRAGONBoostManager(address _veDRAGONBoostManager) external onlyOwner {\n        require(_veDRAGONBoostManager != address(0), \"Zero address\");\n        veDRAGONBoostManager = _veDRAGONBoostManager;\n        emit AddressUpdated(\"veDRAGONBoostManager\", _veDRAGONBoostManager);\n    }\n\n    /**\n     * @dev Set treasury address\n     * @param _treasury New treasury address\n     */\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0), \"Zero address\");\n        treasury = _treasury;\n        emit AddressUpdated(\"treasury\", _treasury);\n    }\n\n    /**\n     * @dev Set jackpot address\n     * @param _jackpot New jackpot address\n     */\n    function setJackpot(address _jackpot) external onlyOwner {\n        require(_jackpot != address(0), \"Zero address\");\n        jackpot = _jackpot;\n        emit AddressUpdated(\"jackpot\", _jackpot);\n    }\n\n    /**\n     * @dev Set default staking token\n     * @param _defaultStakingToken New default staking token\n     */\n    function setDefaultStakingToken(address _defaultStakingToken) external onlyOwner {\n        require(_defaultStakingToken != address(0), \"Zero address\");\n        defaultStakingToken = _defaultStakingToken;\n        emit AddressUpdated(\"defaultStakingToken\", _defaultStakingToken);\n    }\n\n    /**\n     * @dev Set permission for who can create pools\n     * @param _onlyOwner Whether only owner can create pools\n     */\n    function setOnlyOwnerCanCreate(bool _onlyOwner) external onlyOwner {\n        onlyOwnerCanCreate = _onlyOwner;\n        emit PermissionUpdated(\"onlyOwnerCanCreate\", _onlyOwner);\n    }\n\n    /**\n     * @notice Check if this contract is registered for Sonic FeeM\n     * @return isRegistered Whether the contract is registered for fee monetization\n     */\n    function checkFeeMStatus() external view returns (bool isRegistered) {\n    }\n}"
    },
    "contracts/core/governance/partners/DragonPartnerFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\n *   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•\n *   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\n *   â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â•â•â–ˆâ–ˆâ•‘\n *   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\n *   â•šâ•â•     â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•\n *              COLLABORATION AND INTEGRATION SYSTEM\n *\n * Governance: DragonPartnerFeeDistributor\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonic_reddragon_bot\n */\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\";\nimport { IveDRAGONBoostManager } from \"../../../interfaces/governance/partners/IveDRAGONBoostManager.sol\";\nimport { IDragonPartnerRegistry } from \"../../../interfaces/governance/partners/IDragonPartnerRegistry.sol\";\n\n/**\n * @title DragonPartnerFeeDistributor\n * @dev Distributes fees to users who voted for a specific partner gauge\n */\ncontract DragonPartnerFeeDistributor is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // State variables\n    address public veDRAGONBoostManager;\n    address public partnerRegistry;\n    address public treasury;\n\n    // Fee configuration\n    uint256 public protocolFeePercentage = 1000; // 10% goes to protocol treasury\n    uint256 public constant FEE_PRECISION = 10000;\n\n    // Period and reward tracking\n    struct RewardPeriod {\n        uint256 startTime;\n        uint256 endTime;\n        bool feesClaimed;\n        mapping(address => uint256) tokenTotalAmount; // token => amount\n        mapping(address => bool) tokensRegistered; // token => registered\n        address[] rewardTokens;\n    }\n\n    // Partner fee tracking\n    struct PartnerFees {\n        mapping(address => uint256) tokenAmounts; // token => amount\n        mapping(address => mapping(address => uint256)) userClaimed; // user => token => claimed amount\n        mapping(address => bool) isRewardToken; // token => is registered\n        address[] rewardTokens;\n    }\n\n    // User vote tracking\n    mapping(uint256 => mapping(uint256 => mapping(address => uint256))) public userVotes; // period => partnerId => user => votes\n    mapping(uint256 => mapping(uint256 => uint256)) public partnerTotalVotes; // period => partnerId => total votes\n    mapping(uint256 => mapping(address => uint256)) public periodUserTotalVotes; // period => user => total votes across all partners\n\n    // Reward period tracking\n    mapping(uint256 => RewardPeriod) internal rewardPeriods; // period => RewardPeriod\n    mapping(uint256 => mapping(uint256 => PartnerFees)) internal partnerFees; // period => partnerId => PartnerFees\n\n    // Active periods\n    uint256 public currentPeriod;\n    uint256 public periodDuration = 7 days;\n\n    // Events\n    event RewardTokenRegistered(uint256 indexed period, address indexed token);\n    event FeeDeposited(uint256 indexed period, uint256 indexed partnerId, address indexed token, uint256 amount);\n    event FeesClaimed(uint256 indexed period, uint256 indexed partnerId, address indexed user, address token, uint256 amount);\n    event VotesRecorded(uint256 indexed period, uint256 indexed partnerId, address indexed user, uint256 votes);\n    event PeriodRolled(uint256 indexed newPeriod, uint256 startTime, uint256 endTime);\n    event ProtocolFeeUpdated(uint256 oldFee, uint256 newFee);\n\n    /**\n     * @dev Constructor\n     * @param _veDRAGONBoostManager Address of veDRAGON boost manager\n     * @param _partnerRegistry Address of partner registry\n     * @param _treasury Address of treasury\n     */\n    constructor(address _veDRAGONBoostManager, address _partnerRegistry, address _treasury) Ownable(msg.sender) {\n        require(_veDRAGONBoostManager != address(0), \"Zero address: veDRAGONBoostManager\");\n        require(_partnerRegistry != address(0), \"Zero address: partner registry\");\n        require(_treasury != address(0), \"Zero address: treasury\");\n\n        veDRAGONBoostManager = _veDRAGONBoostManager;\n        partnerRegistry = _partnerRegistry;\n        treasury = _treasury;\n\n        // Initialize first period\n        currentPeriod = 1;\n        rewardPeriods[currentPeriod].startTime = block.timestamp;\n        rewardPeriods[currentPeriod].endTime = block.timestamp + periodDuration;\n\n        // Register for Sonic FeeM automatically\n    }\n\n    /**\n     * @dev Roll to next period if current period has ended\n     */\n    function checkAndRollPeriod() public {\n        if (block.timestamp >= rewardPeriods[currentPeriod].endTime) {\n            _rollPeriod();\n        }\n    }\n\n    /**\n     * @dev Roll to next period\n     */\n    function _rollPeriod() internal {\n        uint256 newPeriod = currentPeriod + 1;\n        uint256 startTime = rewardPeriods[currentPeriod].endTime;\n        uint256 endTime = startTime + periodDuration;\n\n        rewardPeriods[newPeriod].startTime = startTime;\n        rewardPeriods[newPeriod].endTime = endTime;\n\n        currentPeriod = newPeriod;\n\n        emit PeriodRolled(newPeriod, startTime, endTime);\n    }\n\n    /**\n     * @dev Record a vote for a partner - can only be called by veDRAGONBoostManager\n     * @param voter Address of the voter\n     * @param partnerId ID of the partner\n     * @param votes Number of votes\n     */\n    function recordVote(address voter, uint256 partnerId, uint256 votes) external {\n        require(msg.sender == veDRAGONBoostManager, \"Only veDRAGONBoostManager can record votes\");\n        require(voter != address(0), \"Zero address: voter\");\n        require(partnerId > 0, \"Invalid partner ID\");\n        require(votes > 0, \"Votes must be positive\");\n\n        // Ensure we're in the current period\n        checkAndRollPeriod();\n\n        // Record votes\n        userVotes[currentPeriod][partnerId][voter] = votes;\n        partnerTotalVotes[currentPeriod][partnerId] += votes;\n        periodUserTotalVotes[currentPeriod][voter] += votes;\n\n        emit VotesRecorded(currentPeriod, partnerId, voter, votes);\n    }\n\n    /**\n     * @dev Deposit fees for a partner to be distributed to voters\n     * @param _partnerId Partner ID\n     * @param _token Token address\n     * @param _amount Amount to deposit\n     */\n    function depositFees(uint256 _partnerId, address _token, uint256 _amount) external nonReentrant {\n        require(_token != address(0), \"Zero address: token\");\n        require(_amount > 0, \"Amount must be positive\");\n\n        // Verify partner exists\n        address partnerAddress = IDragonPartnerRegistry(partnerRegistry).partnerList(_partnerId);\n        require(partnerAddress != address(0), \"Partner does not exist\");\n\n        // Check if partner is active\n        bool isActive = IDragonPartnerRegistry(partnerRegistry).isPartnerActive(partnerAddress);\n        require(isActive, \"Partner not active\");\n\n        // Roll period if needed\n        checkAndRollPeriod();\n\n        // Register token if needed\n        if (!rewardPeriods[currentPeriod].tokensRegistered[_token]) {\n            rewardPeriods[currentPeriod].tokensRegistered[_token] = true;\n            rewardPeriods[currentPeriod].rewardTokens.push(_token);\n            emit RewardTokenRegistered(currentPeriod, _token);\n        }\n\n        // Register token for partner if needed\n        if (!partnerFees[currentPeriod][_partnerId].isRewardToken[_token]) {\n            partnerFees[currentPeriod][_partnerId].isRewardToken[_token] = true;\n            partnerFees[currentPeriod][_partnerId].rewardTokens.push(_token);\n        }\n\n        // Transfer tokens from sender\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Calculate protocol fee\n        uint256 protocolFee = (_amount * protocolFeePercentage) / FEE_PRECISION;\n        uint256 partnerAmount = _amount - protocolFee;\n\n        // Update total amounts\n        rewardPeriods[currentPeriod].tokenTotalAmount[_token] += _amount;\n        partnerFees[currentPeriod][_partnerId].tokenAmounts[_token] += partnerAmount;\n\n        // Transfer protocol fee to treasury\n        if (protocolFee > 0) {\n            IERC20(_token).safeTransfer(treasury, protocolFee);\n        }\n\n        emit FeeDeposited(currentPeriod, _partnerId, _token, _amount);\n    }\n\n    /**\n     * @dev Get user's claimable amount for a specific period, partner, and token\n     * @param _period Period number\n     * @param _partnerId Partner ID\n     * @param _user User address\n     * @param _token Token address\n     * @return Claimable amount\n     */\n    function getUserClaimable(\n        uint256 _period,\n        uint256 _partnerId,\n        address _user,\n        address _token\n    ) public view returns (uint256) {\n        // Check if period exists and has ended\n        if (_period >= currentPeriod ||\n            rewardPeriods[_period].startTime == 0 ||\n            block.timestamp < rewardPeriods[_period].endTime) {\n            return 0;\n        }\n\n        // Check if user voted for this partner\n        uint256 userVoteAmount = userVotes[_period][_partnerId][_user];\n        if (userVoteAmount == 0) {\n            return 0;\n        }\n\n        // Get partner total votes\n        uint256 totalVotes = partnerTotalVotes[_period][_partnerId];\n        if (totalVotes == 0) {\n            return 0;\n        }\n\n        // Calculate user's share of partner fees\n        uint256 partnerTokenAmount = partnerFees[_period][_partnerId].tokenAmounts[_token];\n        uint256 userShare = (partnerTokenAmount * userVoteAmount) / totalVotes;\n\n        // Subtract already claimed amount\n        uint256 alreadyClaimed = partnerFees[_period][_partnerId].userClaimed[_user][_token];\n\n        // Return claimable amount\n        return userShare > alreadyClaimed ? userShare - alreadyClaimed : 0;\n    }\n\n    /**\n     * @dev Claim fees for a specific period, partner, and token\n     * @param _period Period number\n     * @param _partnerId Partner ID\n     * @param _token Token address\n     */\n    function claimFees(uint256 _period, uint256 _partnerId, address _token) external nonReentrant {\n        require(_period < currentPeriod, \"Period not ended\");\n        require(rewardPeriods[_period].startTime > 0, \"Period does not exist\");\n        require(block.timestamp >= rewardPeriods[_period].endTime, \"Period not ended\");\n\n        uint256 claimableAmount = getUserClaimable(_period, _partnerId, msg.sender, _token);\n        require(claimableAmount > 0, \"Nothing to claim\");\n\n        // Update claimed amount\n        partnerFees[_period][_partnerId].userClaimed[msg.sender][_token] += claimableAmount;\n\n        // Transfer tokens to user\n        IERC20(_token).safeTransfer(msg.sender, claimableAmount);\n\n        emit FeesClaimed(_period, _partnerId, msg.sender, _token, claimableAmount);\n    }\n\n    /**\n     * @dev Claim fees for a specific period and multiple partners and tokens\n     * @param _period Period number\n     * @param _partnerIds Array of partner IDs\n     * @param _tokens Array of tokens\n     */\n    function claimMultiple(\n        uint256 _period,\n        uint256[] calldata _partnerIds,\n        address[] calldata _tokens\n    ) external nonReentrant {\n        require(_period < currentPeriod, \"Period not ended\");\n        require(rewardPeriods[_period].startTime > 0, \"Period does not exist\");\n        require(block.timestamp >= rewardPeriods[_period].endTime, \"Period not ended\");\n\n        for (uint256 i = 0; i < _partnerIds.length; i++) {\n            uint256 partnerId = _partnerIds[i];\n\n            for (uint256 j = 0; j < _tokens.length; j++) {\n                address token = _tokens[j];\n\n                uint256 claimableAmount = getUserClaimable(_period, partnerId, msg.sender, token);\n                if (claimableAmount > 0) {\n                    // Update claimed amount\n                    partnerFees[_period][partnerId].userClaimed[msg.sender][token] += claimableAmount;\n\n                    // Transfer tokens to user\n                    IERC20(token).safeTransfer(msg.sender, claimableAmount);\n\n                    emit FeesClaimed(_period, partnerId, msg.sender, token, claimableAmount);\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Get reward tokens for a period\n     * @param _period Period number\n     * @return Array of reward tokens\n     */\n    function getPeriodRewardTokens(uint256 _period) external view returns (address[] memory) {\n        return rewardPeriods[_period].rewardTokens;\n    }\n\n    /**\n     * @dev Get reward tokens for a partner in a period\n     * @param _period Period number\n     * @param _partnerId Partner ID\n     * @return Array of reward tokens\n     */\n    function getPartnerRewardTokens(uint256 _period, uint256 _partnerId) external view returns (address[] memory) {\n        return partnerFees[_period][_partnerId].rewardTokens;\n    }\n\n    /**\n     * @dev Get period information\n     * @param _period Period number\n     * @return startTime Start timestamp\n     * @return endTime End timestamp\n     * @return active Whether period is active\n     */\n    function getPeriodInfo(uint256 _period) external view returns (uint256 startTime, uint256 endTime, bool active) {\n        startTime = rewardPeriods[_period].startTime;\n        endTime = rewardPeriods[_period].endTime;\n        active = _period == currentPeriod && block.timestamp < endTime;\n        return (startTime, endTime, active);\n    }\n\n    /**\n     * @dev Set protocol fee percentage\n     * @param _feePercentage New fee percentage\n     */\n    function setProtocolFee(uint256 _feePercentage) external onlyOwner {\n        require(_feePercentage <= 3000, \"Fee too high\"); // Max 30%\n\n        uint256 oldFee = protocolFeePercentage;\n        protocolFeePercentage = _feePercentage;\n\n        emit ProtocolFeeUpdated(oldFee, _feePercentage);\n    }\n\n    /**\n     * @dev Set period duration\n     * @param _duration New duration in seconds\n     */\n    function setPeriodDuration(uint256 _duration) external onlyOwner {\n        require(_duration >= 1 days && _duration <= 30 days, \"Invalid duration\");\n        periodDuration = _duration;\n    }\n\n    /**\n     * @dev Set veDRAGONBoostManager address\n     * @param _veDRAGONBoostManager New veDRAGON boost manager address\n     */\n    function setVeDRAGONBoostManager(address _veDRAGONBoostManager) external onlyOwner {\n        require(_veDRAGONBoostManager != address(0), \"Zero address\");\n        veDRAGONBoostManager = _veDRAGONBoostManager;\n    }\n\n    /**\n     * @dev Update treasury address\n     * @param _treasury New treasury address\n     */\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0), \"Zero address\");\n        treasury = _treasury;\n    }\n\n    /**\n     * @dev Emergency withdraw tokens that are stuck (can only be used for non-reward tokens)\n     * @param _token Token address\n     * @param _amount Amount to withdraw\n     * @param _to Recipient address\n     */\n    function emergencyWithdraw(address _token, uint256 _amount, address _to) external onlyOwner {\n        require(_to != address(0), \"Zero address\");\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @dev Get partner details for a specific partner\n     * @param _partnerId Partner ID\n     * @return partnerAddress Partner address\n     * @return name Partner name\n     * @return feeShare Partner fee share\n     * @return probabilityBoost Partner probability boost\n     * @return isActive Whether partner is active\n     */\n    function getPartnerDetails(uint256 _partnerId) external view returns (\n        address partnerAddress,\n        string memory name,\n        uint256 feeShare,\n        uint256 probabilityBoost,\n        bool isActive\n    ) {\n        partnerAddress = IDragonPartnerRegistry(partnerRegistry).partnerList(_partnerId);\n        require(partnerAddress != address(0), \"Partner does not exist\");\n\n        (name, feeShare, probabilityBoost, isActive) = IDragonPartnerRegistry(partnerRegistry).getPartnerDetails(partnerAddress);\n\n        return (partnerAddress, name, feeShare, probabilityBoost, isActive);\n    }\n\n    /**\n     * @dev Get partner fee share\n     * @param _partnerId Partner ID\n     * @return Fee share in basis points\n     */\n    function getPartnerFeeShare(uint256 _partnerId) public view returns (uint256) {\n        address partnerAddress = IDragonPartnerRegistry(partnerRegistry).partnerList(_partnerId);\n        require(partnerAddress != address(0), \"Partner does not exist\");\n\n        (,uint256 feeShare,,) = IDragonPartnerRegistry(partnerRegistry).getPartnerDetails(partnerAddress);\n\n        return feeShare;\n    }\n\n    /**\n     * @notice Check if this contract is registered for Sonic FeeM\n     * @return isRegistered Whether the contract is registered for fee monetization\n     */\n    function checkFeeMStatus() external view returns (bool isRegistered) {\n    }\n}"
    },
    "contracts/core/governance/partners/DragonPartnerPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\n *   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•\n *   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\n *   â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â•â•â–ˆâ–ˆâ•‘\n *   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\n *   â•šâ•â•     â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•\n *              COLLABORATION AND INTEGRATION SYSTEM\n *\n * Governance: DragonPartnerPool\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonic_reddragon_bot\n */\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from 'lib/openzeppelin-contracts/contracts/access/Ownable.sol';\nimport { IERC20 } from 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from 'lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { ReentrancyGuard } from 'lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol';\nimport { Pausable } from 'lib/openzeppelin-contracts/contracts/utils/Pausable.sol';\nimport { IDragonPartnerRegistry } from '../../../interfaces/governance/partners/IDragonPartnerRegistry.sol';\nimport { IveDRAGONBoostManager } from '../../../interfaces/governance/partners/IveDRAGONBoostManager.sol';\nimport { IJackpot } from '../../../interfaces/external/IJackpot.sol';\n\n/**\n * @title DragonPartnerPool\n * @dev Pool contract for partners receiving votes and distributing rewards\n */\ncontract DragonPartnerPool is Ownable, ReentrancyGuard, Pausable {\n  using SafeERC20 for IERC20;\n\n  // State variables\n  address public partnerAddress;\n  address public veDRAGONBoostManager;\n  address public jackpot;\n  address public treasury;\n  address public partnerRegistry;\n\n  // Pool configuration\n  uint256 public feePercentage; // In basis points (e.g., 500 = 5%)\n  uint256 public partnerId;\n  bool public initialized;\n\n  // Boost tracking\n  uint256 public lastProbabilityBoost;\n  uint256 public lastBoostUpdate;\n  uint256 public boostUpdateInterval;\n\n  // Reward tracking\n  mapping(address => uint256) public totalRewards;\n  mapping(address => uint256) public distributedRewards;\n  uint256 public lastDistribution;\n\n  // Staking tracking\n  IERC20 public stakingToken;\n  uint256 public totalStaked;\n  mapping(address => uint256) public userStakes;\n  mapping(address => uint256) public userRewardDebt;\n  uint256 public accRewardPerShare; // 1e12 precision\n\n  // Constants\n  uint256 private constant REWARD_PRECISION = 1e12;\n  uint256 private constant PROBABILITY_PRECISION = 10000;\n\n  // Events\n  event Initialized(address indexed partnerAddress, uint256 indexed partnerId);\n  event Staked(address indexed user, uint256 amount);\n  event Unstaked(address indexed user, uint256 amount);\n  event RewardsHarvested(address indexed user, address indexed token, uint256 amount);\n  event RewardsAdded(address indexed token, uint256 amount);\n  event RewardsDistributed(address indexed token, uint256 totalAmount, uint256 feeAmount, uint256 partnerAmount);\n  event ProbabilityBoostUpdated(uint256 oldBoost, uint256 newBoost);\n  event JackpotEntered(address indexed user, uint256 baseAmount, uint256 boostedAmount);\n\n  /**\n   * @dev Constructor\n   * @param _partnerAddress Address of the partner\n   * @param _veDRAGONBoostManager Address of veDRAGON boost manager contract\n   * @param _treasury Address of treasury\n   * @param _jackpot Address of jackpot contract\n   * @param _feePercentage Fee percentage in basis points\n   */\n  constructor(\n    address _partnerAddress,\n    address _veDRAGONBoostManager,\n    address _treasury,\n    address _jackpot,\n    uint256 _feePercentage\n  ) Ownable(msg.sender) {\n    require(_partnerAddress != address(0), 'Zero address: partner');\n    require(_veDRAGONBoostManager != address(0), 'Zero address: veDRAGONBoostManager');\n    require(_treasury != address(0), 'Zero address: treasury');\n    require(_jackpot != address(0), 'Zero address: jackpot');\n    require(_feePercentage <= 5000, 'Fee too high');\n\n    partnerAddress = _partnerAddress;\n    veDRAGONBoostManager = _veDRAGONBoostManager;\n    treasury = _treasury;\n    jackpot = _jackpot;\n    feePercentage = _feePercentage;\n    boostUpdateInterval = 1 days;\n    lastDistribution = block.timestamp;\n    lastBoostUpdate = block.timestamp;\n\n    // Register for Sonic FeeM automatically\n  }\n\n  /**\n   * @dev Initialize the pool with partner registry and staking token\n   * @param _partnerRegistry Partner registry address\n   * @param _stakingToken Token used for staking\n   */\n  function initialize(address _partnerRegistry, address _stakingToken) external onlyOwner {\n    require(!initialized, 'Already initialized');\n    require(_partnerRegistry != address(0), 'Zero address: registry');\n    require(_stakingToken != address(0), 'Zero address: token');\n\n    partnerRegistry = _partnerRegistry;\n    stakingToken = IERC20(_stakingToken);\n\n    // First store the partner ID (we'll verify it's registered in the next step)\n    // Partners are registered by index in the array\n    for (uint256 i = 0; i < IDragonPartnerRegistry(_partnerRegistry).getPartnerCount(); i++) {\n      if (IDragonPartnerRegistry(_partnerRegistry).partnerList(i) == partnerAddress) {\n        partnerId = i;\n        break;\n      }\n    }\n\n    // Verify the partner is registered\n    bool isActive = IDragonPartnerRegistry(_partnerRegistry).isPartnerActive(partnerAddress);\n    require(isActive, 'Partner not active');\n\n    initialized = true;\n\n    emit Initialized(partnerAddress, partnerId);\n  }\n\n  /**\n   * @dev Modifier to check if contract is initialized\n   */\n  modifier whenInitialized() {\n    require(initialized, 'Not initialized');\n    _;\n  }\n\n  /**\n   * @dev Update probability boost from veDRAGON voting\n   */\n  function updateProbabilityBoost() external whenInitialized {\n    require(block.timestamp >= lastBoostUpdate + boostUpdateInterval, 'Too soon to update');\n\n    uint256 oldBoost = lastProbabilityBoost;\n    uint256 newBoost = IveDRAGONBoostManager(veDRAGONBoostManager).getPartnerProbabilityBoost(partnerId);\n\n    lastProbabilityBoost = newBoost;\n    lastBoostUpdate = block.timestamp;\n\n    emit ProbabilityBoostUpdated(oldBoost, newBoost);\n  }\n\n  /**\n   * @dev Stake tokens into the pool\n   * @param _amount Amount to stake\n   */\n  function stake(uint256 _amount) external nonReentrant whenNotPaused whenInitialized {\n    require(_amount > 0, 'Zero amount');\n\n    // Harvest pending rewards first\n    _harvestRewards(msg.sender);\n\n    // Transfer tokens\n    stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n    // Update state\n    userStakes[msg.sender] += _amount;\n    totalStaked += _amount;\n\n    // Update reward debt\n    userRewardDebt[msg.sender] = (userStakes[msg.sender] * accRewardPerShare) / REWARD_PRECISION;\n\n    emit Staked(msg.sender, _amount);\n  }\n\n  /**\n   * @dev Unstake tokens from the pool\n   * @param _amount Amount to unstake\n   */\n  function unstake(uint256 _amount) external nonReentrant whenInitialized {\n    require(_amount > 0, 'Zero amount');\n    require(userStakes[msg.sender] >= _amount, 'Insufficient stake');\n\n    // Harvest pending rewards first\n    _harvestRewards(msg.sender);\n\n    // Update state\n    userStakes[msg.sender] -= _amount;\n    totalStaked -= _amount;\n\n    // Update reward debt\n    userRewardDebt[msg.sender] = (userStakes[msg.sender] * accRewardPerShare) / REWARD_PRECISION;\n\n    // Transfer tokens back to user\n    stakingToken.safeTransfer(msg.sender, _amount);\n\n    emit Unstaked(msg.sender, _amount);\n  }\n\n  /**\n   * @dev Harvest pending rewards\n   */\n  function harvestRewards() external nonReentrant whenInitialized {\n    _harvestRewards(msg.sender);\n  }\n\n  /**\n   * @dev Enter jackpot with boost\n   * @param _amount Amount of tokens to enter with\n   */\n  function enterJackpot(uint256 _amount) external nonReentrant whenNotPaused whenInitialized {\n    require(_amount > 0, 'Zero amount');\n\n    // Use a common wrapped native token (e.g., WETH)\n    // Normally we would get this from jackpot, but the interface doesn't expose it\n    address wrappedNativeToken = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH address\n\n    // Transfer tokens from user\n    IERC20(wrappedNativeToken).safeTransferFrom(msg.sender, address(this), _amount);\n\n    // Approve jackpot to use tokens  \n    IERC20(wrappedNativeToken).safeIncreaseAllowance(veDRAGONBoostManager, _amount);\n\n    // Enter jackpot with boosted amount using veDRAGON boost\n    uint256 finalBoostedAmount = IveDRAGONBoostManager(veDRAGONBoostManager).enterJackpotWithBoost(msg.sender, _amount);\n\n    emit JackpotEntered(msg.sender, _amount, finalBoostedAmount);\n  }\n\n  /**\n   * @dev Add rewards to the pool\n   * @param _token Token to add as reward\n   * @param _amount Amount to add\n   */\n  function addRewards(address _token, uint256 _amount) external nonReentrant whenInitialized {\n    require(_token != address(0), 'Zero address');\n    require(_amount > 0, 'Zero amount');\n\n    // Transfer tokens\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n    // Update state\n    totalRewards[_token] += _amount;\n\n    emit RewardsAdded(_token, _amount);\n  }\n\n  /**\n   * @dev Distribute rewards to stakers\n   * @param _token Token to distribute\n   */\n  function distributeRewards(address _token) external nonReentrant whenInitialized {\n    require(_token != address(0), 'Zero address');\n    require(totalStaked > 0, 'No stakers');\n\n    uint256 balance = IERC20(_token).balanceOf(address(this));\n    uint256 stakingBalance = totalStaked;\n\n    // Calculate amount to distribute (non-staked tokens)\n    uint256 distributableAmount = balance - stakingBalance;\n    require(distributableAmount > 0, 'No rewards to distribute');\n\n    // Calculate fee for treasury\n    uint256 feeAmount = (distributableAmount * feePercentage) / 10000;\n\n    // Calculate partner amount with boost\n    uint256 basePartnerAmount = distributableAmount - feeAmount;\n    uint256 boostMultiplier = PROBABILITY_PRECISION + lastProbabilityBoost;\n    uint256 boostedPartnerAmount = (basePartnerAmount * boostMultiplier) / PROBABILITY_PRECISION;\n\n    // Calculate amount to distribute to stakers (original amount - fees - partner share)\n    uint256 stakerAmount = distributableAmount - feeAmount - boostedPartnerAmount;\n\n    // Distribute fees\n    if (feeAmount > 0) {\n      IERC20(_token).safeTransfer(treasury, feeAmount);\n    }\n\n    // Distribute to partner\n    if (boostedPartnerAmount > 0) {\n      IERC20(_token).safeTransfer(partnerAddress, boostedPartnerAmount);\n    }\n\n    // Update staker rewards\n    if (stakerAmount > 0 && totalStaked > 0) {\n      accRewardPerShare += (stakerAmount * REWARD_PRECISION) / totalStaked;\n    }\n\n    // Update state\n    distributedRewards[_token] += distributableAmount;\n    lastDistribution = block.timestamp;\n\n    emit RewardsDistributed(_token, distributableAmount, feeAmount, boostedPartnerAmount);\n  }\n\n  /**\n   * @dev Internal function to harvest rewards\n   * @param _user User address\n   */\n  function _harvestRewards(address _user) internal {\n    uint256 userStake = userStakes[_user];\n    if (userStake == 0) {\n      return;\n    }\n\n    uint256 pending = (userStake * accRewardPerShare) / REWARD_PRECISION - userRewardDebt[_user];\n    if (pending > 0) {\n      // Determine the reward token - in this case, it's the staking token itself\n      address rewardToken = address(stakingToken);\n\n      // Update reward debt\n      userRewardDebt[_user] = (userStake * accRewardPerShare) / REWARD_PRECISION;\n\n      // Transfer rewards\n      stakingToken.safeTransfer(_user, pending);\n\n      emit RewardsHarvested(_user, rewardToken, pending);\n    }\n  }\n\n  /**\n   * @dev Get pending rewards for a user\n   * @param _user User address\n   * @return Amount of pending rewards\n   */\n  function pendingRewards(address _user) external view returns (uint256) {\n    if (userStakes[_user] == 0) {\n      return 0;\n    }\n\n    uint256 _accRewardPerShare = accRewardPerShare;\n\n    return (userStakes[_user] * _accRewardPerShare) / REWARD_PRECISION - userRewardDebt[_user];\n  }\n\n  /**\n   * @dev Set fee percentage\n   * @param _feePercentage New fee percentage\n   */\n  function setFeePercentage(uint256 _feePercentage) external onlyOwner {\n    require(_feePercentage <= 5000, 'Fee too high');\n    feePercentage = _feePercentage;\n  }\n\n  /**\n   * @dev Set boost update interval\n   * @param _interval New interval in seconds\n   */\n  function setBoostUpdateInterval(uint256 _interval) external onlyOwner {\n    require(_interval >= 1 hours, 'Interval too short');\n    boostUpdateInterval = _interval;\n  }\n\n  /**\n   * @dev Pause the contract\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @dev Unpause the contract\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @dev Emergency withdraw tokens\n   * @param _token Token to withdraw\n   * @param _to Recipient address\n   */\n  function emergencyWithdraw(address _token, address _to) external onlyOwner {\n    require(_to != address(0), 'Zero address');\n\n    uint256 balance = IERC20(_token).balanceOf(address(this));\n    if (balance > 0) {\n      IERC20(_token).safeTransfer(_to, balance);\n    }\n  }\n\n  /**\n   * @notice Check if this contract is registered for Sonic FeeM\n   * @return isRegistered Whether the contract is registered for fee monetization\n   */\n  function checkFeeMStatus() external view returns (bool isRegistered) {\n  }\n}"
    },
    "contracts/core/governance/partners/DragonPartnerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\n *   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•\n *   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\n *   â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â•â•â–ˆâ–ˆâ•‘\n *   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\n *   â•šâ•â•     â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•\n *              COLLABORATION AND INTEGRATION SYSTEM\n *\n * Partner Integration Contracts\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonic_reddragon_bot\n */\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from 'lib/openzeppelin-contracts/contracts/access/Ownable.sol';\nimport { IDragonPartnerRegistry } from '../../../interfaces/governance/partners/IDragonPartnerRegistry.sol';\n\n/**\n * @title DragonPartnerRegistry\n * @dev Registry for managing partners in the Dragon ecosystem\n */\ncontract DragonPartnerRegistry is Ownable, IDragonPartnerRegistry {\n  // Custom errors\n  error BoostTooHigh(uint256 provided, uint256 maximum);\n  error ZeroAddress();\n  error FeeShareTooHigh(uint256 provided, uint256 maximum);\n  error PartnerAlreadyExists(address partner);\n  error PartnerDoesNotExist(address partner);\n  error PartnerNotActive(address partner);\n  error PartnerAlreadyActive(address partner);\n  error FeeMRegistrationFailed();\n  error IndexOutOfBounds(uint256 index, uint256 length);\n  error RegistrationFailed();\n\n  // Partner extended internal struct (not exposed in interface)\n  struct PartnerExtended {\n    address addr; // Partner address\n    string name; // Partner name\n    uint256 feeShare; // Fee share in basis points\n    uint256 probabilityBoost; // Probability boost in basis points\n    bool active; // Partner active status\n  }\n\n  // Partners storage\n  address[] private _partnerList;\n  mapping(address => PartnerExtended) private _partners;\n  mapping(address => bool) public override isPartnerActive;\n\n  // Authorized distributors\n  mapping(address => bool) private _authorizedDistributors;\n\n  // Default probability boost\n  uint256 private _defaultProbabilityBoost = 100; // 1% by default\n\n  // Events\n  event PartnerAdded(address indexed partner, string name);\n  event PartnerActivated(address indexed partner);\n  event PartnerDeactivated(address indexed partner);\n  event PartnerRemoved(address indexed partner);\n  event DistributorAuthorized(address indexed distributor);\n  event DistributorUnauthorized(address indexed distributor);\n  event DefaultProbabilityBoostUpdated(uint256 newBoost);\n\n  constructor() Ownable(msg.sender) {\n    // Register for Sonic FeeM automatically\n  }\n\n  /**\n   * @dev Add a new partner\n   * @param partnerAddress Partner address\n   * @param name Partner name\n   * @param feeShare Fee share in basis points\n   * @param probabilityBoost Probability boost in basis points\n   */\n  function addPartner(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare,\n    uint256 probabilityBoost\n  ) external override onlyOwner {\n    if (partnerAddress == address(0)) revert ZeroAddress();\n    if (_partners[partnerAddress].addr != address(0)) revert PartnerAlreadyExists(partnerAddress);\n    if (feeShare > 5000) revert FeeShareTooHigh(feeShare, 5000); // Max 50%\n    if (probabilityBoost > 1000) revert BoostTooHigh(probabilityBoost, 1000); // Max 10%\n\n    // Create partner\n    _partners[partnerAddress] = PartnerExtended({\n      addr: partnerAddress,\n      name: name,\n      feeShare: feeShare,\n      probabilityBoost: probabilityBoost,\n      active: true\n    });\n\n    // Add to list\n    _partnerList.push(partnerAddress);\n\n    // Set active\n    isPartnerActive[partnerAddress] = true;\n\n    // Emit event\n    emit PartnerAdded(partnerAddress, name);\n    emit PartnerActivated(partnerAddress);\n  }\n\n  /**\n   * @dev Add a new partner with default probability boost\n   * @param partnerAddress Partner address\n   * @param name Partner name\n   * @param feeShare Fee share in basis points\n   */\n  function addPartnerWithDefaultBoost(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare\n  ) external override onlyOwner {\n    this.addPartner(partnerAddress, name, feeShare, _defaultProbabilityBoost);\n  }\n\n  /**\n   * @dev Update an existing partner\n   * @param partnerAddress Partner address\n   * @param name New name\n   * @param feeShare New fee share\n   * @param probabilityBoost New probability boost\n   */\n  function updatePartner(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare,\n    uint256 probabilityBoost\n  ) external override onlyOwner {\n    if (_partners[partnerAddress].addr == address(0)) revert PartnerDoesNotExist(partnerAddress);\n    if (feeShare > 5000) revert FeeShareTooHigh(feeShare, 5000); // Max 50%\n    if (probabilityBoost > 1000) revert BoostTooHigh(probabilityBoost, 1000); // Max 10%\n\n    // Update partner\n    _partners[partnerAddress].name = name;\n    _partners[partnerAddress].feeShare = feeShare;\n    _partners[partnerAddress].probabilityBoost = probabilityBoost;\n  }\n\n  /**\n   * @dev Update an existing partner with default probability boost\n   * @param partnerAddress Partner address\n   * @param name New name\n   * @param feeShare New fee share\n   */\n  function updatePartnerWithDefaultBoost(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare\n  ) external override onlyOwner {\n    this.updatePartner(partnerAddress, name, feeShare, _defaultProbabilityBoost);\n  }\n\n  /**\n   * @dev Activate a partner\n   * @param partnerAddress Partner address\n   */\n  function activatePartner(address partnerAddress) external onlyOwner {\n    if (_partners[partnerAddress].addr == address(0)) revert PartnerDoesNotExist(partnerAddress);\n    if (isPartnerActive[partnerAddress]) revert PartnerAlreadyActive(partnerAddress);\n\n    // Set active\n    _partners[partnerAddress].active = true;\n    isPartnerActive[partnerAddress] = true;\n\n    // Emit event\n    emit PartnerActivated(partnerAddress);\n  }\n\n  /**\n   * @dev Deactivate a partner\n   * @param partnerAddress Partner address\n   */\n  function deactivatePartner(address partnerAddress) external override onlyOwner {\n    if (_partners[partnerAddress].addr == address(0)) revert PartnerDoesNotExist(partnerAddress);\n    if (!isPartnerActive[partnerAddress]) revert PartnerNotActive(partnerAddress);\n\n    // Set inactive\n    _partners[partnerAddress].active = false;\n    isPartnerActive[partnerAddress] = false;\n\n    // Emit event\n    emit PartnerDeactivated(partnerAddress);\n  }\n\n  /**\n   * @dev Set distributor authorization\n   * @param distributor Distributor address\n   * @param authorized Authorization status\n   */\n  function setDistributorAuthorization(address distributor, bool authorized) external override onlyOwner {\n    if (distributor == address(0)) revert ZeroAddress();\n\n    _authorizedDistributors[distributor] = authorized;\n\n    if (authorized) {\n      emit DistributorAuthorized(distributor);\n    } else {\n      emit DistributorUnauthorized(distributor);\n    }\n  }\n\n  /**\n   * @dev Set default probability boost\n   * @param boost Default probability boost\n   */\n  function setDefaultProbabilityBoost(uint256 boost) external override onlyOwner {\n    if (boost > 1000) revert BoostTooHigh(boost, 1000); // Max 10%\n\n    _defaultProbabilityBoost = boost;\n    emit DefaultProbabilityBoostUpdated(boost);\n  }\n\n  /**\n   * @dev Get partner at index - implements IDragonPartnerRegistry\n   * @param index Index\n   * @return Partner address\n   */\n  function partnerList(uint256 index) external view override returns (address) {\n    if (index >= _partnerList.length) revert IndexOutOfBounds(index, _partnerList.length);\n    return _partnerList[index];\n  }\n\n  /**\n   * @dev Get partner count - implements IDragonPartnerRegistry\n   * @return Partner count\n   */\n  function getPartnerCount() external view override returns (uint256) {\n    return _partnerList.length;\n  }\n\n  /**\n   * @dev Get partner details - implements IDragonPartnerRegistry\n   * @param partnerAddress Partner address\n   * @return name Partner name\n   * @return feeShare Fee share in basis points\n   * @return probabilityBoost Probability boost in basis points\n   * @return isActive Partner active status\n   */\n  function getPartnerDetails(\n    address partnerAddress\n  ) external view override returns (string memory name, uint256 feeShare, uint256 probabilityBoost, bool isActive) {\n    if (_partners[partnerAddress].addr == address(0)) revert PartnerDoesNotExist(partnerAddress);\n\n    PartnerExtended memory partner = _partners[partnerAddress];\n    return (partner.name, partner.feeShare, partner.probabilityBoost, partner.active);\n  }\n\n  /**\n   * @dev Get partner data - implements IDragonPartnerRegistry\n   */\n  function partners(\n    address partnerAddress\n  ) external view override returns (string memory name, uint256 feeShare, uint256 probabilityBoost, bool isActive) {\n    PartnerExtended memory partner = _partners[partnerAddress];\n    return (partner.name, partner.feeShare, partner.probabilityBoost, partner.active);\n  }\n\n  /**\n   * @dev Check if distributor is authorized\n   */\n  function authorizedDistributors(address distributor) external view override returns (bool) {\n    return _authorizedDistributors[distributor];\n  }\n\n  /**\n   * @dev Check if distributor is authorized\n   */\n  function isDistributorAuthorized(address distributor) external view override returns (bool) {\n    return _authorizedDistributors[distributor];\n  }\n\n  /**\n   * @dev Get default probability boost\n   */\n  function defaultProbabilityBoost() external view override returns (uint256) {\n    return _defaultProbabilityBoost;\n  }\n\n  /**\n   * @dev Check if partner is whitelisted (alias for isPartnerActive)\n   * @param partner Partner address\n   * @return Whether partner is whitelisted\n   */\n  function isWhitelistedPartner(address partner) external view override returns (bool) {\n    return isPartnerActive[partner];\n  }\n\n  /**\n   * @dev Get partner boost (returns probability boost)\n   * @param partner Partner address\n   * @return Probability boost in basis points\n   */\n  function getPartnerBoost(address partner) external view override returns (uint256) {\n    if (_partners[partner].addr == address(0)) revert PartnerDoesNotExist(partner);\n    return _partners[partner].probabilityBoost;\n  }\n\n  /**\n   * @dev Register a partner (alias for addPartner with default fee share)\n   * @param partner Partner address\n   * @param boost Probability boost in basis points\n   */\n  function registerPartner(address partner, uint256 boost) external override onlyOwner {\n    this.addPartner(partner, 'Partner', 0, boost); // 0 fee share by default\n  }\n\n  /**\n   * @dev Remove a partner from the registry\n   * @param partner Partner address\n   */\n  function removePartner(address partner) external override onlyOwner {\n    if (_partners[partner].addr == address(0)) revert PartnerDoesNotExist(partner);\n\n    // Find and remove from list\n    for (uint256 i = 0; i < _partnerList.length; i++) {\n      if (_partnerList[i] == partner) {\n        _partnerList[i] = _partnerList[_partnerList.length - 1];\n        _partnerList.pop();\n        break;\n      }\n    }\n\n    // Delete partner data\n    delete _partners[partner];\n    delete isPartnerActive[partner];\n\n    emit PartnerRemoved(partner);\n  }\n\n  /**\n   * @notice Check if this contract is registered for Sonic FeeM\n   * @return isRegistered Whether the contract is registered for fee monetization\n   */\n  function checkFeeMStatus() external view returns (bool isRegistered) {\n  }\n}"
    },
    "contracts/core/governance/voting/veDRAGONBoostManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Ownable } from 'lib/openzeppelin-contracts/contracts/access/Ownable.sol';\nimport { ReentrancyGuard } from 'lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol';\nimport { IveDRAGON } from '../../../interfaces/tokens/IveDRAGON.sol';\nimport { IJackpot } from '../../../interfaces/shared/IJackpot.sol';\nimport { IveDRAGONBoostManager } from '../../../interfaces/governance/partners/IveDRAGONBoostManager.sol';\nimport { IDragonPartnerRegistry } from '../../../interfaces/governance/partners/IDragonPartnerRegistry.sol';\nimport { DragonDateTimeLib } from '../../../libraries/core/DragonDateTimeLib.sol';\nimport { veDRAGONMath } from '../../../libraries/math/veDRAGONMath.sol';\n\n/**\n * @title veDRAGONBoostManager\n * @dev Unified contract for veDRAGON boost and voting functionality for partner systems\n *\n * Combines boost calculation for jackpot entries and partner pool voting mechanisms\n * Provides voting power-based probability boosts and democratic partner selection\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\nabstract contract veDRAGONBoostManager is Ownable, ReentrancyGuard, IveDRAGONBoostManager {\n  // === Custom Errors ===\n  error ZeroAddress();\n  error ZeroAmount();\n  error BaseBoostMustBePositive();\n  error MaxBoostMustBeGreaterThanBase();\n  error UnauthorizedCaller();\n  error PartnerDoesNotExist();\n  error PartnerNotActive();\n  error InsufficientVotingPower();\n  error NoVotesForOldPartner();\n  error TooSoonToRecalculate();\n  error PeriodTooShort();\n  error FeeMRegistrationFailed();\n  error InvalidMultiplier();\n\n  // Core contract references\n  IveDRAGON public immutable veDRAGON;\n  IJackpot public jackpot;\n  IDragonPartnerRegistry public partnerRegistry;\n\n  // ===== BOOST PARAMETERS =====\n  /// @dev Precision for boost calculations (10000 = 100%)\n  uint256 public constant BOOST_PRECISION = 10000;\n\n  /// @dev Base boost value (10000 = 100%)\n  uint256 public baseBoost = 10000;\n\n  /// @dev Maximum boost value (25000 = 250%)\n  uint256 public maxBoost = 25000;\n\n  // Optional parameters for refined boost calculation (packed into single storage slot)\n  uint64 public minLockDuration = 7 days; // Minimum lock duration for boost\n  uint64 public maxLockDuration = 4 * 365 days; // Maximum lock duration (4 years)\n\n  // ===== VOTING PARAMETERS =====\n  /// @dev Voting period length in seconds\n  uint64 public votingPeriodLength = 7 days;\n\n  /// @dev Current voting period\n  uint64 private _currentPeriod;\n\n  /// @dev Maximum total probability boost (6.9% expressed in basis points)\n  uint256 public constant MAX_TOTAL_BOOST = 690;\n\n  /// @dev Minimum voting power to participate\n  uint256 public minVotingPower = 0.1 ether; // 0.1 veDRAGON\n\n  // Track votes for each partner in each period\n  // period => partnerId => votes\n  mapping(uint256 => mapping(uint256 => uint256)) public partnerVotes;\n\n  // Track total votes in each period\n  // period => totalVotes\n  mapping(uint256 => uint256) public periodTotalVotes;\n\n  // Track if a user has voted in current period\n  // period => user => hasVoted\n  mapping(uint256 => mapping(address => bool)) public hasVoted;\n\n  // Track votes by user\n  // period => user => partnerId => votes\n  mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public userVotes;\n\n  // Track allocated probability boost\n  // partnerId => probabilityBoost (in basis points)\n  mapping(uint256 => uint256) public partnerProbabilityBoost;\n\n  // Last calculation timestamp\n  uint64 public lastCalculation;\n\n  // Flash loan protection\n  mapping(address => uint256) public lastBalanceUpdateBlock;\n  uint256 public constant MIN_HOLDING_BLOCKS = 10; // ~2 minutes on most chains\n\n  // Timelock for critical parameters\n  bool public boostTimelockInitialized;\n  uint256 public constant BOOST_TIMELOCK_DELAY = 24 hours; // 24 hour delay for boost changes\n\n  struct BoostTimelockProposal {\n    uint256 newBaseBoost;\n    uint256 newMaxBoost;\n    uint256 executeTime;\n    bool executed;\n    bool exists;\n  }\n\n  mapping(bytes32 => BoostTimelockProposal) public boostTimelockProposals;\n  bool public boostParametersSetOnce;\n\n  // ===== EVENTS =====\n  // Boost Events (BoostCalculated is inherited from interface)\n  event BoostParametersUpdated(uint256 baseBoost, uint256 maxBoost);\n  event JackpotAddressUpdated(address indexed newJackpot);\n  event JackpotEntryWithBoost(address indexed user, uint256 amount, uint256 boostedAmount);\n\n  // Voting Events\n  event VoteCast(address indexed user, uint256 indexed partnerId, uint256 votes, uint256 period);\n  event VoteChanged(\n    address indexed user,\n    uint256 indexed oldPartnerId,\n    uint256 indexed newPartnerId,\n    uint256 votes,\n    uint256 period\n  );\n  event VoteRemoved(address indexed user, uint256 indexed partnerId, uint256 votes, uint256 period);\n  event PartnersBoostCalculated(uint256 period, uint256 totalVotes);\n  event PartnerBoostUpdated(uint256 indexed partnerId, uint256 probabilityBoost);\n  event VotingPeriodChanged(uint256 newPeriodLength);\n  event MinVotingPowerChanged(uint256 newMinVotingPower);\n  event PartnerRegistryUpdated(address indexed newRegistry);\n\n  event BoostProposalCreated(\n    bytes32 indexed proposalId,\n    uint256 newBaseBoost,\n    uint256 newMaxBoost,\n    uint256 executeTime\n  );\n  event BoostProposalExecuted(bytes32 indexed proposalId);\n  event BoostTimelockInitialized();\n\n  /**\n   * @dev Constructor\n   * @param _veDRAGON Address of the veDRAGON token\n   * @param _jackpot Address of the jackpot contract\n   * @param _partnerRegistry Address of the partner registry\n   */\n  constructor(address _veDRAGON, address _jackpot, address _partnerRegistry) {\n    if (_veDRAGON == address(0)) revert ZeroAddress();\n    if (_jackpot == address(0)) revert ZeroAddress();\n    if (_partnerRegistry == address(0)) revert ZeroAddress();\n\n    veDRAGON = IveDRAGON(_veDRAGON);\n    jackpot = IJackpot(_jackpot);\n    partnerRegistry = IDragonPartnerRegistry(_partnerRegistry);\n\n    // Initialize period and calculation timestamp\n    _currentPeriod = uint64(block.timestamp / votingPeriodLength);\n    lastCalculation = uint64(block.timestamp);\n\n    // Register for Sonic FeeM automatically\n  }\n\n  /**\n   * @dev Get the current voting period\n   * @return Current period ID\n   */\n  function currentPeriod() external view returns (uint256) {\n    return _currentPeriod;\n  }\n\n  // ============================================================\n  // ==================== BOOST FUNCTIONS =======================\n  // ============================================================\n\n  /**\n   * @dev Calculate boost multiplier based on user's veDRAGON balance with cubic root normalization\n   * @param _user Address of the user\n   * @return boostMultiplier Boost multiplier in BOOST_PRECISION (10000 = 100%)\n   */\n  function calculateBoost(address _user) public view returns (uint256 boostMultiplier) {\n    // Use secure calculation with flash loan protection\n    return calculateBoostWithProtection(_user);\n  }\n\n  /**\n   * @dev Calculate boost with flash loan protection\n   */\n  function calculateBoostWithProtection(address _user) public view returns (uint256 boostMultiplier) {\n    // Check if user has held tokens for minimum duration\n    if (block.number < lastBalanceUpdateBlock[_user] + MIN_HOLDING_BLOCKS) {\n      return baseBoost; // Only base boost for recent holders\n    }\n\n    // Get user's time-weighted veDRAGON voting power\n    uint256 userVeDRAGONBalance = veDRAGON.getVotingPower(_user);\n    uint256 totalVeDRAGONSupply = veDRAGON.getTotalVotingPower();\n\n    // Use the veDRAGONMath library for boost calculation\n    uint256 standardBoost = veDRAGONMath.calculateNormalizedBoostMultiplier(\n      userVeDRAGONBalance,\n      totalVeDRAGONSupply,\n      maxBoost\n    );\n\n    // Check if today is a special event day for additional boost\n    (bool isSpecialEvent, uint256 eventMultiplier) = DragonDateTimeLib.checkForSpecialEvent(block.timestamp);\n\n    if (isSpecialEvent) {\n      return (standardBoost * eventMultiplier) / 10000;\n    }\n\n    return standardBoost;\n  }\n\n  /**\n   * @dev Calculate boost and emit event (non-view version)\n   * @param _user Address of the user\n   * @return boostMultiplier Boost multiplier\n   */\n  function getBoostWithEvent(address _user) public override returns (uint256 boostMultiplier) {\n    boostMultiplier = calculateBoost(_user);\n    emit BoostCalculated(_user, boostMultiplier);\n    return boostMultiplier;\n  }\n\n  /**\n   * @dev Enter jackpot with a boosted amount based on veDRAGON holdings\n   * @param _user Address of the user entering the jackpot\n   * @param _amount Base amount for jackpot entry\n   * @return boostedAmount The amount after applying the boost\n   */\n  function enterJackpotWithBoost(address _user, uint256 _amount) external override returns (uint256 boostedAmount) {\n    // Only authorized integrators can call this function\n    if (msg.sender != owner() && msg.sender != address(jackpot)) revert UnauthorizedCaller();\n\n    // Calculate boost\n    uint256 boostMultiplier = calculateBoost(_user);\n\n    // Apply boost to amount\n    boostedAmount = (_amount * boostMultiplier) / BOOST_PRECISION;\n\n    // Enter jackpot with boosted amount\n    jackpot.enterJackpotWithWrappedNativeToken(_user, boostedAmount);\n\n    // Emit events\n    emit BoostCalculated(_user, boostMultiplier);\n    emit JackpotEntryWithBoost(_user, _amount, boostedAmount);\n\n    return boostedAmount;\n  }\n\n  /**\n   * @dev Update boost parameters (with timelock protection after first use)\n   * @param _baseBoost New base boost (10000 = 100%)\n   * @param _maxBoost New max boost (25000 = 250%)\n   */\n  function setBoostParameters(uint256 _baseBoost, uint256 _maxBoost) external onlyOwner {\n    if (_baseBoost == 0) revert BaseBoostMustBePositive();\n    if (_maxBoost <= _baseBoost) revert MaxBoostMustBeGreaterThanBase();\n\n    // First time can be set immediately\n    if (!boostParametersSetOnce) {\n      boostParametersSetOnce = true;\n      boostTimelockInitialized = true;\n\n      baseBoost = _baseBoost;\n      maxBoost = _maxBoost;\n\n      emit BoostParametersUpdated(_baseBoost, _maxBoost);\n      emit BoostTimelockInitialized();\n      return;\n    }\n\n    // Subsequent changes require timelock\n    revert('Use proposeBoostParameterChange');\n  }\n\n  /**\n   * @dev Propose boost parameter changes (required after first use)\n   */\n  function proposeBoostParameterChange(\n    uint256 _baseBoost,\n    uint256 _maxBoost\n  ) external onlyOwner returns (bytes32 proposalId) {\n    require(boostTimelockInitialized, 'Timelock not initialized');\n    if (_baseBoost == 0) revert BaseBoostMustBePositive();\n    if (_maxBoost <= _baseBoost) revert MaxBoostMustBeGreaterThanBase();\n\n    proposalId = keccak256(abi.encode(_baseBoost, _maxBoost, block.timestamp));\n    require(!boostTimelockProposals[proposalId].exists, 'Proposal already exists');\n\n    uint256 executeTime = block.timestamp + BOOST_TIMELOCK_DELAY;\n\n    boostTimelockProposals[proposalId] = BoostTimelockProposal({\n      newBaseBoost: _baseBoost,\n      newMaxBoost: _maxBoost,\n      executeTime: executeTime,\n      executed: false,\n      exists: true\n    });\n\n    emit BoostProposalCreated(proposalId, _baseBoost, _maxBoost, executeTime);\n    return proposalId;\n  }\n\n  /**\n   * @dev Execute boost parameter change after timelock\n   */\n  function executeBoostParameterChange(bytes32 proposalId) external onlyOwner {\n    BoostTimelockProposal storage proposal = boostTimelockProposals[proposalId];\n    require(proposal.exists, 'Proposal does not exist');\n    require(!proposal.executed, 'Proposal already executed');\n    require(block.timestamp >= proposal.executeTime, 'Timelock not expired');\n\n    proposal.executed = true;\n\n    baseBoost = proposal.newBaseBoost;\n    maxBoost = proposal.newMaxBoost;\n\n    emit BoostParametersUpdated(proposal.newBaseBoost, proposal.newMaxBoost);\n    emit BoostProposalExecuted(proposalId);\n  }\n\n  /**\n   * @dev Update jackpot address\n   * @param _jackpot New jackpot address\n   */\n  function setJackpot(address _jackpot) external onlyOwner {\n    if (_jackpot == address(0)) revert ZeroAddress();\n    jackpot = IJackpot(_jackpot);\n    emit JackpotAddressUpdated(_jackpot);\n  }\n\n  // ============================================================\n  // =================== VOTING FUNCTIONS =======================\n  // ============================================================\n\n  /**\n   * @dev Vote for a partner to receive probability boost\n   * @param _partnerId ID of the partner to vote for\n   * @param _weight Voting weight to allocate (not used, for interface compatibility)\n   */\n  function voteForPartner(uint256 _partnerId, uint256 _weight) external override {\n    // _weight parameter is not used in this implementation but is included for interface compatibility\n    _weight; // Silence unused variable warning\n\n    // Get partner address from ID\n    address partnerAddress = partnerRegistry.partnerList(_partnerId);\n\n    // Verify partner exists and is active\n    bool isActive = partnerRegistry.isPartnerActive(partnerAddress);\n    if (partnerAddress == address(0)) revert PartnerDoesNotExist();\n    if (!isActive) revert PartnerNotActive();\n\n    // Check if we need to move to a new period\n    updatePeriodIfNeeded();\n\n    // Get user's voting power\n    uint256 votingPower = veDRAGON.getVotingPower(msg.sender);\n    if (votingPower < minVotingPower) revert InsufficientVotingPower();\n\n    // If user has already voted in this period, remove their previous vote\n    if (hasVoted[_currentPeriod][msg.sender]) {\n      removeVote(msg.sender);\n    }\n\n    // Record the new vote\n    partnerVotes[_currentPeriod][_partnerId] += votingPower;\n    periodTotalVotes[_currentPeriod] += votingPower;\n    hasVoted[_currentPeriod][msg.sender] = true;\n    userVotes[_currentPeriod][msg.sender][_partnerId] = votingPower;\n\n    emit VoteCast(msg.sender, _partnerId, votingPower, _currentPeriod);\n  }\n\n  /**\n   * @dev Change vote from one partner to another\n   * @param _oldPartnerId Current partner ID the user is voting for\n   * @param _newPartnerId New partner ID to vote for\n   */\n  function changeVote(uint256 _oldPartnerId, uint256 _newPartnerId) external {\n    // Get partner address from ID\n    address newPartnerAddress = partnerRegistry.partnerList(_newPartnerId);\n\n    // Verify new partner exists and is active\n    bool isActive = partnerRegistry.isPartnerActive(newPartnerAddress);\n    if (newPartnerAddress == address(0)) revert PartnerDoesNotExist();\n    if (!isActive) revert PartnerNotActive();\n\n    // Check if we need to move to a new period\n    updatePeriodIfNeeded();\n\n    // Check if user has voted for the old partner\n    uint256 oldVotes = userVotes[_currentPeriod][msg.sender][_oldPartnerId];\n    if (oldVotes == 0) revert NoVotesForOldPartner();\n\n    // Remove old vote\n    partnerVotes[_currentPeriod][_oldPartnerId] -= oldVotes;\n    userVotes[_currentPeriod][msg.sender][_oldPartnerId] = 0;\n\n    // Add new vote\n    partnerVotes[_currentPeriod][_newPartnerId] += oldVotes;\n    userVotes[_currentPeriod][msg.sender][_newPartnerId] = oldVotes;\n\n    emit VoteChanged(msg.sender, _oldPartnerId, _newPartnerId, oldVotes, _currentPeriod);\n  }\n\n  /**\n   * @dev Remove a user's vote\n   * @param user Address of the user\n   */\n  function removeVote(address user) internal {\n    // Find all partners the user voted for\n    for (uint256 i = 0; i < partnerRegistry.getPartnerCount(); i++) {\n      uint256 userVoteAmount = userVotes[_currentPeriod][user][i];\n      if (userVoteAmount > 0) {\n        // Remove votes\n        partnerVotes[_currentPeriod][i] -= userVoteAmount;\n        periodTotalVotes[_currentPeriod] -= userVoteAmount;\n        userVotes[_currentPeriod][user][i] = 0;\n\n        emit VoteRemoved(user, i, userVoteAmount, _currentPeriod);\n      }\n    }\n\n    // Mark user as not having voted\n    hasVoted[_currentPeriod][user] = false;\n  }\n\n  /**\n   * @dev Calculate probability boosts based on votes\n   * Can be called by anyone, but has a time restriction\n   */\n  function calculatePartnersBoost() external {\n    // Check if 24 hours have passed since last calculation\n    if (block.timestamp < lastCalculation + 1 days) revert TooSoonToRecalculate();\n\n    // Update period if needed\n    updatePeriodIfNeeded();\n\n    // Get total votes in the current period\n    uint256 totalVotes = periodTotalVotes[_currentPeriod];\n\n    // If no votes, reset all boosts\n    if (totalVotes == 0) {\n      for (uint256 i = 0; i < partnerRegistry.getPartnerCount(); i++) {\n        if (partnerProbabilityBoost[i] > 0) {\n          partnerProbabilityBoost[i] = 0;\n          emit PartnerBoostUpdated(i, 0);\n        }\n      }\n    } else {\n      // Calculate boost for each partner\n      for (uint256 i = 0; i < partnerRegistry.getPartnerCount(); i++) {\n        uint256 votes = partnerVotes[_currentPeriod][i];\n\n        // Calculate partner's share of the boost\n        uint256 boost = (votes * MAX_TOTAL_BOOST) / totalVotes;\n\n        // Update partner's probability boost if changed\n        if (boost != partnerProbabilityBoost[i]) {\n          partnerProbabilityBoost[i] = boost;\n          emit PartnerBoostUpdated(i, boost);\n        }\n      }\n    }\n\n    // Update last calculation timestamp\n    lastCalculation = uint64(block.timestamp);\n\n    emit PartnersBoostCalculated(_currentPeriod, totalVotes);\n  }\n\n  /**\n   * @dev Get probability boost for a partner\n   * @param _partnerId ID of the partner\n   * @return Probability boost in basis points (e.g., 100 = 1%)\n   */\n  function getPartnerProbabilityBoost(uint256 _partnerId) external view override returns (uint256) {\n    return partnerProbabilityBoost[_partnerId];\n  }\n\n  /**\n   * @dev Get probability boost for a partner address\n   * @param _partner Address of the partner\n   * @return Probability boost in basis points (e.g., 100 = 1%)\n   */\n  function getPartnerProbabilityBoostByAddress(address _partner) external view returns (uint256) {\n    // Iterate through partner list to find matching address\n    for (uint256 i = 0; i < partnerRegistry.getPartnerCount(); i++) {\n      if (partnerRegistry.partnerList(i) == _partner) {\n        return partnerProbabilityBoost[i];\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * @dev Update current period if needed\n   */\n  function updatePeriodIfNeeded() internal {\n    uint64 calculatedPeriod = uint64(block.timestamp / votingPeriodLength);\n    if (calculatedPeriod > _currentPeriod) {\n      _currentPeriod = calculatedPeriod;\n    }\n  }\n\n  /**\n   * @dev Set minimum voting power required to participate\n   * @param _minVotingPower New minimum voting power\n   */\n  function setMinVotingPower(uint256 _minVotingPower) external onlyOwner {\n    minVotingPower = _minVotingPower;\n    emit MinVotingPowerChanged(_minVotingPower);\n  }\n\n  /**\n   * @dev Set voting period length\n   * @param _votingPeriodLength New voting period length in seconds\n   */\n  function setVotingPeriodLength(uint256 _votingPeriodLength) external onlyOwner {\n    if (_votingPeriodLength < 1 days) revert PeriodTooShort();\n    votingPeriodLength = uint64(_votingPeriodLength);\n    emit VotingPeriodChanged(_votingPeriodLength);\n  }\n\n  /**\n   * @dev Update partner registry address\n   * @param _partnerRegistry New partner registry address\n   */\n  function setPartnerRegistry(address _partnerRegistry) external onlyOwner {\n    if (_partnerRegistry == address(0)) revert ZeroAddress();\n    partnerRegistry = IDragonPartnerRegistry(_partnerRegistry);\n    emit PartnerRegistryUpdated(_partnerRegistry);\n  }\n\n  /**\n   * @dev Update balance tracking (should be called on veDRAGON transfers)\n   */\n  function updateBalanceTracking(address user) external {\n    require(msg.sender == address(veDRAGON), 'Only veDRAGON can update');\n    lastBalanceUpdateBlock[user] = block.number;\n  }\n\n  /**\n   * @dev Check if a special event is active\n   * @return Whether a special event is currently active\n   */\n  function isSpecialEventActive() external view returns (bool) {\n    (bool isActive, ) = DragonDateTimeLib.checkForSpecialEvent(block.timestamp);\n    return isActive;\n  }\n\n  /**\n   * @dev Get normalized boost multiplier for a user\n   * @param user User address\n   * @return Normalized boost multiplier\n   */\n  function getNormalizedBoostMultiplier(address user) external view returns (uint256) {\n    return calculateBoost(user);\n  }\n\n  /**\n   * @notice Check if this contract is registered for Sonic FeeM\n   * @return isRegistered Whether the contract is registered for fee monetization\n   */\n  function checkFeeMStatus() external view returns (bool isRegistered) {\n  }\n}"
    },
    "contracts/core/governance/voting/veDRAGONRevenueDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from 'lib/openzeppelin-contracts/contracts/access/Ownable.sol';\nimport { IERC20 } from 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from 'lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { ReentrancyGuard } from 'lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol';\nimport { IDragonRevenueDistributor } from '../../../interfaces/governance/fees/IDragonRevenueDistributor.sol';\nimport { IveDRAGON } from '../../../interfaces/tokens/IveDRAGON.sol';\n\n/**\n * @title veDRAGONRevenueDistributor\n * @dev Revenue distributor for veDRAGON holders based on their voting power\n * Implements epoch-based distribution system for fair fee sharing\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract veDRAGONRevenueDistributor is IDragonRevenueDistributor, Ownable, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // Custom errors\n  error ZeroAddress();\n  error InsufficientFees();\n  error NothingToClaim();\n  error InvalidEpoch();\n\n  // State variables\n  IveDRAGON public immutable veDRAGON;\n\n  // Epoch tracking\n  uint256 public currentEpoch;\n  uint256 public epochDuration = 7 days;\n  mapping(uint256 => uint256) public epochStartTime;\n  mapping(uint256 => uint256) public epochEndTime;\n\n  // Fee tracking per epoch and token\n  mapping(uint256 => mapping(address => uint256)) public epochFees; // epoch => token => amount\n  mapping(uint256 => uint256) public epochTotalSupply; // epoch => total veDRAGON supply snapshot\n\n  // User claim tracking\n  mapping(address => mapping(uint256 => mapping(address => bool))) public hasClaimed; // user => epoch => token => claimed\n  mapping(address => mapping(address => uint256)) public totalClaimed; // user => token => total claimed\n\n  // Partner fee tracking (for interface compliance)\n  mapping(uint256 => mapping(address => uint256)) public partnerFees; // partnerId => token => amount\n\n  // Wrapped native token address (WETH, WSONIC, etc.)\n  address public wrappedNativeToken;\n\n  // Events\n  event FeesReceived(uint256 indexed epoch, address indexed token, uint256 amount);\n  event FeesClaimed(address indexed user, uint256 indexed epoch, address indexed token, uint256 amount);\n  event WrappedTokenSet(address indexed oldToken, address indexed newToken);\n  event EpochRolled(uint256 indexed newEpoch, uint256 startTime, uint256 endTime);\n\n  constructor(address _veDRAGON) Ownable(msg.sender) {\n    if (_veDRAGON == address(0)) revert ZeroAddress();\n\n    veDRAGON = IveDRAGON(_veDRAGON);\n\n    // Initialize first epoch\n    currentEpoch = 1;\n    epochStartTime[1] = block.timestamp;\n    epochEndTime[1] = block.timestamp + epochDuration;\n\n    // Register for Sonic FeeM automatically\n  }\n\n  /**\n   * @dev Receive native token fees\n   */\n  receive() external payable {\n    if (msg.value > 0) {\n      rollEpoch(); // Ensure we're in the correct epoch\n      epochFees[currentEpoch][address(0)] += msg.value;\n      emit FeesReceived(currentEpoch, address(0), msg.value);\n    }\n  }\n\n  // ======== IDragonRevenueDistributor Interface Implementation ========\n\n  /**\n   * @dev Distribute general fees not associated with a specific partner\n   * @param token Token address (address(0) for native token)\n   * @param amount Amount of fees to distribute\n   */\n  function distributeGeneralFees(address token, uint256 amount) external override nonReentrant {\n    require(amount > 0, \"Amount must be positive\");\n    \n    rollEpoch(); // Ensure we're in the correct epoch\n    \n    if (token == address(0)) {\n      // Native token - should already be in contract via receive() or direct transfer\n      require(address(this).balance >= amount, \"Insufficient native balance\");\n    } else {\n      // ERC20 token - transfer from sender\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    }\n    \n    epochFees[currentEpoch][token] += amount;\n    emit FeesReceived(currentEpoch, token, amount);\n  }\n\n  /**\n   * @dev Deposit fees for a specific partner (tracked separately)\n   * @param partnerId ID of the partner\n   * @param token Token address (address(0) for native token)\n   * @param amount Amount of fees\n   */\n  function depositFees(uint256 partnerId, address token, uint256 amount) external payable override nonReentrant {\n    require(amount > 0, \"Amount must be positive\");\n    \n    if (token == address(0)) {\n      // Native token deposit\n      require(msg.value == amount, \"Incorrect native amount\");\n      partnerFees[partnerId][address(0)] += amount;\n    } else {\n      // ERC20 token deposit\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      partnerFees[partnerId][token] += amount;\n    }\n  }\n\n  /**\n   * @dev Claim rewards for a user (uses epoch-based system)\n   * @param user User address to claim for\n   */\n  function claimRewards(address user) external override nonReentrant {\n    require(user != address(0), \"Zero address: user\");\n    \n    // Auto-claim all available epochs for native token\n    uint256 totalClaimedAmount = 0;\n    \n    for (uint256 epoch = 1; epoch < currentEpoch; epoch++) {\n      if (epochEndTime[epoch] <= block.timestamp && !hasClaimed[user][epoch][address(0)]) {\n        uint256 claimable = getClaimable(user, epoch, address(0));\n        if (claimable > 0) {\n          hasClaimed[user][epoch][address(0)] = true;\n          totalClaimedAmount += claimable;\n        }\n      }\n    }\n    \n    require(totalClaimedAmount > 0, \"No rewards to claim\");\n    \n    // Transfer native token rewards\n    (bool success, ) = user.call{value: totalClaimedAmount}(\"\");\n    require(success, \"Reward transfer failed\");\n    \n    // Update total claimed tracking\n    totalClaimed[user][address(0)] += totalClaimedAmount;\n  }\n\n  /**\n   * @dev Get claimable rewards for a user (sum of all epochs)\n   * @param user User address\n   * @return Total claimable reward amount in native token\n   */\n  function getClaimableRewards(address user) external view override returns (uint256) {\n    uint256 totalClaimable = 0;\n    \n    for (uint256 epoch = 1; epoch < currentEpoch; epoch++) {\n      if (epochEndTime[epoch] <= block.timestamp) {\n        totalClaimable += getClaimable(user, epoch, address(0));\n      }\n    }\n    \n    return totalClaimable;\n  }\n\n  // ======== Existing Epoch-Based Distribution System ========\n\n  /**\n   * @dev Set the wrapped native token address\n   * @param _wrappedToken The new wrapped native token address\n   */\n  function setWrappedToken(address _wrappedToken) external onlyOwner {\n    require(_wrappedToken != address(0), 'Zero address');\n    address oldToken = wrappedNativeToken;\n    wrappedNativeToken = _wrappedToken;\n    emit WrappedTokenSet(oldToken, _wrappedToken);\n  }\n\n  /**\n   * @dev Roll to next epoch if current epoch has ended\n   */\n  function rollEpoch() public {\n    if (block.timestamp >= epochEndTime[currentEpoch]) {\n      // Snapshot total supply for the ending epoch\n      epochTotalSupply[currentEpoch] = veDRAGON.getTotalVotingPower();\n\n      // Start new epoch\n      currentEpoch++;\n      epochStartTime[currentEpoch] = epochEndTime[currentEpoch - 1];\n      epochEndTime[currentEpoch] = epochStartTime[currentEpoch] + epochDuration;\n\n      emit EpochRolled(currentEpoch, epochStartTime[currentEpoch], epochEndTime[currentEpoch]);\n    }\n  }\n\n  /**\n   * @dev Receive fees for distribution (legacy function)\n   * @param token Token address\n   * @param amount Amount of fees\n   */\n  function receiveFees(address token, uint256 amount) external {\n    rollEpoch(); // Ensure we're in the correct epoch\n\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    epochFees[currentEpoch][token] += amount;\n\n    emit FeesReceived(currentEpoch, token, amount);\n  }\n\n  /**\n   * @dev Calculate user's claimable amount for a specific epoch and token\n   * @param user User address\n   * @param epoch Epoch number\n   * @param token Token address\n   * @return Claimable amount\n   */\n  function getClaimable(address user, uint256 epoch, address token) public view returns (uint256) {\n    // Check if epoch is valid and ended\n    if (epoch >= currentEpoch || epochEndTime[epoch] > block.timestamp) {\n      return 0;\n    }\n\n    // Check if already claimed\n    if (hasClaimed[user][epoch][token]) {\n      return 0;\n    }\n\n    // Get user's voting power at epoch end\n    uint256 userVotingPower = veDRAGON.getVotingPowerAt(user, epochEndTime[epoch]);\n    if (userVotingPower == 0) {\n      return 0;\n    }\n\n    // Get total supply for the epoch\n    uint256 totalSupply = epochTotalSupply[epoch];\n    if (totalSupply == 0) {\n      return 0;\n    }\n\n    // Calculate user's share\n    uint256 epochTokenFees = epochFees[epoch][token];\n    return (epochTokenFees * userVotingPower) / totalSupply;\n  }\n\n  /**\n   * @dev Claim fees for a specific epoch and token\n   * @param epoch Epoch number\n   * @param token Token address\n   */\n  function claimFees(uint256 epoch, address token) external nonReentrant {\n    if (epoch >= currentEpoch) revert InvalidEpoch();\n    if (epochEndTime[epoch] > block.timestamp) revert InvalidEpoch();\n\n    uint256 claimable = getClaimable(msg.sender, epoch, token);\n    if (claimable == 0) revert NothingToClaim();\n\n    // Mark as claimed\n    hasClaimed[msg.sender][epoch][token] = true;\n    totalClaimed[msg.sender][token] += claimable;\n\n    // Transfer fees\n    if (token == address(0)) {\n      (bool success, ) = msg.sender.call{value: claimable}(\"\");\n      require(success, \"Native transfer failed\");\n    } else {\n      IERC20(token).safeTransfer(msg.sender, claimable);\n    }\n\n    emit FeesClaimed(msg.sender, epoch, token, claimable);\n  }\n\n  /**\n   * @dev Claim fees for multiple epochs and tokens\n   * @param epochs Array of epoch numbers\n   * @param tokens Array of token addresses\n   */\n  function claimMultiple(uint256[] calldata epochs, address[] calldata tokens) external nonReentrant {\n    for (uint256 i = 0; i < epochs.length; i++) {\n      uint256 epoch = epochs[i];\n\n      if (epoch >= currentEpoch || epochEndTime[epoch] > block.timestamp) {\n        continue; // Skip invalid epochs\n      }\n\n      for (uint256 j = 0; j < tokens.length; j++) {\n        address token = tokens[j];\n        uint256 claimable = getClaimable(msg.sender, epoch, token);\n\n        if (claimable > 0) {\n          // Mark as claimed\n          hasClaimed[msg.sender][epoch][token] = true;\n          totalClaimed[msg.sender][token] += claimable;\n\n          // Transfer fees\n          if (token == address(0)) {\n            (bool success, ) = msg.sender.call{value: claimable}(\"\");\n            require(success, \"Native transfer failed\");\n          } else {\n            IERC20(token).safeTransfer(msg.sender, claimable);\n          }\n\n          emit FeesClaimed(msg.sender, epoch, token, claimable);\n        }\n      }\n    }\n  }\n\n  // ======== View Functions ========\n\n  /**\n   * @dev Get collected fees for an epoch and token\n   * @param epoch Epoch number\n   * @param token Token address\n   * @return Amount of collected fees\n   */\n  function getEpochFees(uint256 epoch, address token) external view returns (uint256) {\n    return epochFees[epoch][token];\n  }\n\n  /**\n   * @dev Get total claimed fees for a user and token\n   * @param user User address\n   * @param token Token address\n   * @return Amount of total claimed fees\n   */\n  function getUserTotalClaimed(address user, address token) external view returns (uint256) {\n    return totalClaimed[user][token];\n  }\n\n  /**\n   * @dev Check if user has claimed for a specific epoch and token\n   * @param user User address\n   * @param epoch Epoch number\n   * @param token Token address\n   * @return True if claimed\n   */\n  function hasUserClaimed(address user, uint256 epoch, address token) external view returns (bool) {\n    return hasClaimed[user][epoch][token];\n  }\n\n  /**\n   * @dev Get partner fees for a specific partner and token\n   * @param partnerId Partner ID\n   * @param token Token address\n   * @return Fee amount\n   */\n  function getPartnerFees(uint256 partnerId, address token) external view returns (uint256) {\n    return partnerFees[partnerId][token];\n  }\n\n  // ======== Admin Functions ========\n\n  /**\n   * @dev Set epoch duration\n   * @param _duration New duration in seconds\n   */\n  function setEpochDuration(uint256 _duration) external onlyOwner {\n    require(_duration >= 1 days && _duration <= 30 days, 'Invalid duration');\n    epochDuration = _duration;\n  }\n\n  /**\n   * @notice Check if this contract is registered for Sonic FeeM\n   * @return isRegistered Whether the contract is registered for fee monetization\n   */\n  function checkFeeMStatus() external view returns (bool isRegistered) {\n  }\n}"
    },
    "contracts/core/governance/voting/VotingPowerCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Voting Power Calculation Library for veDRAGON\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonic_reddragon_bot\n */\n\npragma solidity ^0.8.19;\n\nimport {Math} from \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {veDRAGONMath} from \"contracts/libraries/math/veDRAGONMath.sol\";\n\n/**\n * @title VotingPowerCalculator\n * @dev Library for calculating voting power for veDRAGON tokens\n * Supports multiple calculation methods for flexibility\n */\nlibrary VotingPowerCalculator {\n    using Math for uint256;\n\n    // Constants\n    uint256 public constant PRECISION = 1e18;\n    uint256 public constant BPS_DENOMINATOR = 10000;\n    uint256 public constant SECONDS_PER_YEAR = 365 days;\n    uint256 public constant MAX_LOCK_TIME = 4 * SECONDS_PER_YEAR;\n\n    // Calculation methods for voting power\n    enum VotingPowerMethod {\n        LINEAR,        // Linear scaling with lock time\n        CUBIC_ROOT,    // Cubic root scaling (less steep power curve)\n        QUADRATIC,     // Quadratic scaling (steeper power curve)\n        TIME_WEIGHTED  // Time-weighted balance (veCRV style)\n    }\n\n    /**\n     * @dev Calculate voting power based on amount and lock time using the specified method\n     * @param amount Amount of veDRAGON tokens\n     * @param lockDuration Duration of lock in seconds\n     * @param method Calculation method to use\n     * @return votingPower The calculated voting power\n     */\n    function calculateVotingPower(\n        uint256 amount,\n        uint256 lockDuration,\n        VotingPowerMethod method\n    ) public pure returns (uint256 votingPower) {\n        if (amount == 0) return 0;\n\n        // Ensure lock duration is capped\n        lockDuration = Math.min(lockDuration, MAX_LOCK_TIME);\n\n        // Apply different calculation methods\n        if (method == VotingPowerMethod.LINEAR) {\n            return calculateLinearVotingPower(amount, lockDuration);\n        } else if (method == VotingPowerMethod.CUBIC_ROOT) {\n            return calculateCubicRootVotingPower(amount, lockDuration);\n        } else if (method == VotingPowerMethod.QUADRATIC) {\n            return calculateQuadraticVotingPower(amount, lockDuration);\n        } else if (method == VotingPowerMethod.TIME_WEIGHTED) {\n            return calculateTimeWeightedVotingPower(amount, lockDuration);\n        } else {\n            // Default to cubic root if invalid method\n            return calculateCubicRootVotingPower(amount, lockDuration);\n        }\n    }\n\n    /**\n     * @dev Calculate voting power using linear scaling with lock time\n     * @param amount Amount of veDRAGON tokens\n     * @param lockDuration Duration of lock in seconds\n     * @return votingPower The calculated voting power\n     */\n    function calculateLinearVotingPower(\n        uint256 amount,\n        uint256 lockDuration\n    ) public pure returns (uint256 votingPower) {\n        // Linear scaling: amount * (lockDuration / MAX_LOCK_TIME)\n        // With minimum multiplier of 1x\n        uint256 timeRatio = (lockDuration * PRECISION) / MAX_LOCK_TIME;\n        uint256 boost = BPS_DENOMINATOR + ((BPS_DENOMINATOR * timeRatio) / PRECISION);\n\n        return (amount * boost) / BPS_DENOMINATOR;\n    }\n\n    /**\n     * @dev Calculate voting power using cubic root scaling with lock time\n     * @param amount Amount of veDRAGON tokens\n     * @param lockDuration Duration of lock in seconds\n     * @return votingPower The calculated voting power\n     */\n    function calculateCubicRootVotingPower(\n        uint256 amount,\n        uint256 lockDuration\n    ) public pure returns (uint256 votingPower) {\n        // Calculate time ratio (0-1 scaled by PRECISION)\n        uint256 timeRatio = (lockDuration * PRECISION) / MAX_LOCK_TIME;\n\n        // Apply cube root scaling for non-linear boost\n        uint256 nonLinearBoost = veDRAGONMath.cubeRoot(timeRatio);\n\n        // Scale by max boost (2.5x) and apply to amount\n        uint256 boostMultiplier = (nonLinearBoost * 15000) / PRECISION;\n        uint256 effectiveBoost = BPS_DENOMINATOR + boostMultiplier;\n\n        // Calculate boosted amount\n        return (amount * effectiveBoost) / BPS_DENOMINATOR;\n    }\n\n    /**\n     * @dev Calculate voting power using quadratic scaling with lock time\n     * @param amount Amount of veDRAGON tokens\n     * @param lockDuration Duration of lock in seconds\n     * @return votingPower The calculated voting power\n     */\n    function calculateQuadraticVotingPower(\n        uint256 amount,\n        uint256 lockDuration\n    ) public pure returns (uint256 votingPower) {\n        // Calculate time ratio (0-1 scaled by PRECISION)\n        uint256 timeRatio = (lockDuration * PRECISION) / MAX_LOCK_TIME;\n\n        // Apply quadratic scaling (xÂ²) for steeper power curve\n        uint256 quadraticBoost = (timeRatio * timeRatio) / PRECISION;\n\n        // Scale by max boost (2.5x) and apply to amount\n        uint256 boostMultiplier = (quadraticBoost * 15000) / PRECISION;\n        uint256 effectiveBoost = BPS_DENOMINATOR + boostMultiplier;\n\n        // Calculate boosted amount\n        return (amount * effectiveBoost) / BPS_DENOMINATOR;\n    }\n\n    /**\n     * @dev Calculate voting power using time-weighted balance (veCRV style)\n     * @param amount Amount of veDRAGON tokens\n     * @param lockDuration Duration of lock in seconds\n     * @return votingPower The calculated voting power\n     */\n    function calculateTimeWeightedVotingPower(\n        uint256 amount,\n        uint256 lockDuration\n    ) public pure returns (uint256 votingPower) {\n        // Time-weighted voting power: amount * lockDuration / MAX_LOCK_TIME\n        return (amount * lockDuration) / MAX_LOCK_TIME;\n    }\n\n    /**\n     * @dev Calculate effective voting power at a specific timestamp\n     * @param amount Amount of veDRAGON tokens\n     * @param lockEndTime Timestamp when lock expires\n     * @param currentTime Current timestamp to calculate voting power at\n     * @param method Calculation method to use\n     * @return effectiveVotingPower The time-decayed voting power\n     */\n    function calculateEffectiveVotingPower(\n        uint256 amount,\n        uint256 lockEndTime,\n        uint256 currentTime,\n        VotingPowerMethod method\n    ) public pure returns (uint256 effectiveVotingPower) {\n        // If lock has expired, voting power is 0\n        if (currentTime >= lockEndTime) return 0;\n\n        // Calculate remaining lock duration\n        uint256 remainingLockTime = lockEndTime - currentTime;\n\n        // Calculate effective voting power using specified method\n        return calculateVotingPower(amount, remainingLockTime, method);\n    }\n\n    /**\n     * @dev Calculate weighted voting power for governance\n     * @param amount Amount of veDRAGON tokens\n     * @param lockEndTime Timestamp when lock expires\n     * @param currentTime Current timestamp\n     * @return weightedVotingPower The weighted voting power for governance\n     */\n    function calculateGovernanceVotingPower(\n        uint256 amount,\n        uint256 lockEndTime,\n        uint256 currentTime\n    ) public pure returns (uint256 weightedVotingPower) {\n        // For governance, we use time-weighted power with a minimum 0.1x multiplier\n        // If lock has expired, provide minimal voting rights (10% of tokens)\n        if (currentTime >= lockEndTime) {\n            return amount / 10;\n        }\n\n        // Calculate remaining lock duration\n        uint256 remainingLockTime = lockEndTime - currentTime;\n\n        // Use time-weighted method for governance\n        uint256 baseVotingPower = calculateTimeWeightedVotingPower(amount, remainingLockTime);\n\n        // Ensure minimum voting power is 10% of token amount\n        return Math.max(baseVotingPower, amount / 10);\n    }\n\n    /**\n     * @dev Calculate boost multiplier for rewards based on voting power\n     * @param votingPower User's voting power\n     * @param totalVotingPower Total voting power in the system\n     * @param userBalance User's token balance\n     * @param totalSupply Total token supply\n     * @return boostMultiplier The boost multiplier in basis points (10000 = 1.0x)\n     */\n    function calculateRewardBoostMultiplier(\n        uint256 votingPower,\n        uint256 totalVotingPower,\n        uint256 userBalance,\n        uint256 totalSupply\n    ) public pure returns (uint256 boostMultiplier) {\n        if (votingPower == 0 || totalVotingPower == 0) {\n            return BPS_DENOMINATOR; // Default 1.0x with no voting power\n        }\n\n        // Calculate vote share and token share\n        uint256 voteShare = (votingPower * PRECISION) / totalVotingPower;\n        uint256 tokenShare = (userBalance * PRECISION) / totalSupply;\n\n        // Calculate boost based on the ratio of vote share to token share\n        // A higher vote-to-token ratio gives more boost, capped at 2.5x\n        uint256 shareRatio = (voteShare * PRECISION) / tokenShare;\n\n        // Linear scaling from 1.0x to 2.5x based on share ratio\n        // Maximum boost at 4.0x ratio (4 times more voting weight than token weight)\n        uint256 maxBoostRatio = 4 * PRECISION;\n        uint256 maxBoostMultiplier = 25000; // 2.5x\n\n        if (shareRatio >= maxBoostRatio) {\n            return maxBoostMultiplier;\n        } else {\n            uint256 boostRange = maxBoostMultiplier - BPS_DENOMINATOR;\n            uint256 additionalBoost = (boostRange * shareRatio) / maxBoostRatio;\n            return BPS_DENOMINATOR + additionalBoost;\n        }\n    }\n}"
    },
    "contracts/core/lottery/OmniDragonLotteryManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\";\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { veDRAGONMath } from \"../../libraries/math/veDRAGONMath.sol\";\nimport { IChainlinkVRFIntegratorV2_5 } from \"../../interfaces/external/chainlink/IChainlinkVRFIntegratorV2_5.sol\";\nimport { MessagingReceipt } from \"../../../lib/devtools/packages/oapp-evm/contracts/oapp/OAppSender.sol\";\n\n// ============ INTERFACES ============\n\ninterface IRandomWordsCallbackV2_5 {\n    function receiveRandomWords(uint256[] memory randomWords, uint64 sequence) external;\n}\n\ninterface IDragonJackpotVault {\n    function getJackpotBalance() external view returns (uint256 balance);\n    function payJackpot(address winner, uint256 amount) external;\n    function getLastWinTime() external view returns (uint256 timestamp);\n    function setWrappedNativeToken(address _wrappedNativeToken) external;\n}\n\ninterface IDragonJackpotDistributor {\n    function addToJackpot(uint256 amount) external;\n    function distributeJackpot(address winner, uint256 amount) external;\n    function getCurrentJackpot() external view returns (uint256);\n}\n\ninterface IOmniDragonRandomnessProvider {\n    function requestRandomnessFromPool() external payable returns (uint256);\n    function drawUnpredictableFromPool(\n        address swapper,\n        address tokenA,\n        address tokenB,\n        uint256 amountIn,\n        uint256 amountOut\n    ) external returns (uint256 randomness);\n    function getRandomnessRequest(uint256 randomnessId) external view returns (\n        address requester,\n        uint64 timestamp,\n        bool fulfilled,\n        uint256 randomValue,\n        uint32 requestType\n    );\n    function authorizeConsumer(address consumer, bool authorized) external;\n}\n\n// ============ MAIN CONTRACT ============\n\ncontract OmniDragonLotteryManager is Ownable, ReentrancyGuard, IRandomWordsCallbackV2_5 {\n    using SafeERC20 for IERC20;\n\n    // ============ EVENTS ============\n    event LotteryConfigured(uint256 indexed lotteryId, uint256 entryFee, uint256 maxParticipants);\n    event LotteryEntered(uint256 indexed lotteryId, address indexed participant, uint256 entryFee);\n    event LotteryDrawn(uint256 indexed lotteryId, address indexed winner, uint256 prize);\n    event InstantLotteryProcessed(address indexed user, uint256 swapAmount, bool won, uint256 reward);\n    event RandomnessRequested(uint256 indexed lotteryId, uint256 requestId);\n    event RandomnessFulfilled(uint256 indexed requestId, uint256 randomness);\n\n    // ============ ENUMS ============\n    \n    enum RandomnessSource {\n        CHAINLINK_VRF,      // Primary: Chainlink VRF (most secure)\n        DRAND,              // Secondary: drand beacon (future implementation)\n        RANDOMNESS_PROVIDER // Fallback: OmniDragonRandomnessProvider (less secure)\n    }\n\n    // ============ STRUCTS ============\n    \n    struct LotteryConfig {\n        uint256 entryFee;\n        uint256 maxParticipants;\n        uint256 prizePool;\n        bool isActive;\n        address[] participants;\n        uint256 vrfRequestId;\n        bool isDrawn;\n        RandomnessSource randomnessSource; // Track which source was used\n        uint64 vrfSequence; // For Chainlink VRF tracking\n    }\n\n    struct InstantLotteryConfig {\n        uint256 baseWinProbability; // Base probability in basis points (1-10000)\n        uint256 minSwapAmount;      // Minimum swap amount to qualify\n        uint256 rewardPercentage;   // Percentage of swap amount as reward\n        bool isActive;\n    }\n\n    struct UserStats {\n        uint256 totalSwaps;\n        uint256 totalVolume;\n        uint256 totalWins;\n        uint256 totalRewards;\n        uint256 lastSwapTime;\n    }\n\n    // ============ STATE VARIABLES ============\n    \n    IChainlinkVRFIntegratorV2_5 public vrfIntegrator;\n    IOmniDragonRandomnessProvider public randomnessProvider;\n    IDragonJackpotVault public jackpotVault;\n    IDragonJackpotDistributor public jackpotDistributor;\n    \n    uint256 public nextLotteryId = 1;\n    uint256 public constant MIN_SWAP_INTERVAL = 1; // 1 second between swaps per user\n    uint256 public constant MAX_PARTICIPANTS_PER_LOTTERY = 1000; // DoS protection\n    \n    mapping(uint256 => LotteryConfig) public lotteries;\n    mapping(address => bool) public authorizedSwapContracts;\n    mapping(address => UserStats) public userStats;\n    mapping(uint256 => uint256) public vrfRequestToLottery; // VRF request ID to lottery ID\n    \n    InstantLotteryConfig public instantLotteryConfig;\n\n    // ============ CONSTRUCTOR ============\n    \n    constructor(\n        address _vrfIntegrator,\n        address _randomnessProvider,\n        address _jackpotVault,\n        address _jackpotDistributor\n    ) Ownable(msg.sender) {\n        vrfIntegrator = IChainlinkVRFIntegratorV2_5(_vrfIntegrator);\n        randomnessProvider = IOmniDragonRandomnessProvider(_randomnessProvider);\n        jackpotVault = IDragonJackpotVault(_jackpotVault);\n        jackpotDistributor = IDragonJackpotDistributor(_jackpotDistributor);\n        \n        // Set default instant lottery config\n        instantLotteryConfig = InstantLotteryConfig({\n            baseWinProbability: 100,  // 1% base win rate\n            minSwapAmount: 1e18,      // 1 token minimum\n            rewardPercentage: 500,    // 5% of swap amount\n            isActive: true\n        });\n        \n        // Register for Sonic FeeM automatically\n        // No-op - FeeM registration disabled\n    }\n\n    // ============ MODIFIERS ============\n    \n    modifier onlyAuthorizedSwapContract() {\n        require(authorizedSwapContracts[msg.sender], \"Not authorized swap contract\");\n        _;\n    }\n\n    modifier rateLimited(address user) {\n        require(\n            block.timestamp >= userStats[user].lastSwapTime + MIN_SWAP_INTERVAL,\n            \"Swap too frequent\"\n        );\n        userStats[user].lastSwapTime = block.timestamp;\n        _;\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n    \n    function setVRFIntegrator(address _vrfIntegrator) external onlyOwner {\n        vrfIntegrator = IChainlinkVRFIntegratorV2_5(_vrfIntegrator);\n        \n        // Auto-authorize this contract with the VRF integrator if possible\n        if (_vrfIntegrator != address(0)) {\n            try IChainlinkVRFIntegratorV2_5(_vrfIntegrator).setAuthorizedCaller(address(this), true) {\n                // Successfully authorized\n            } catch {\n                // Authorization failed - owner will need to authorize manually\n            }\n        }\n    }\n\n    function setRandomnessProvider(address _randomnessProvider) external onlyOwner {\n        randomnessProvider = IOmniDragonRandomnessProvider(_randomnessProvider);\n    }\n\n    function setJackpotVault(address _jackpotVault) external onlyOwner {\n        jackpotVault = IDragonJackpotVault(_jackpotVault);\n    }\n\n    function setJackpotDistributor(address _jackpotDistributor) external onlyOwner {\n        jackpotDistributor = IDragonJackpotDistributor(_jackpotDistributor);\n    }\n\n    function authorizeSwapContract(address swapContract, bool authorized) external onlyOwner {\n        authorizedSwapContracts[swapContract] = authorized;\n    }\n\n    function configureInstantLottery(\n        uint256 _baseWinProbability,\n        uint256 _minSwapAmount,\n        uint256 _rewardPercentage,\n        bool _isActive\n    ) external onlyOwner {\n        require(_baseWinProbability <= 10000, \"Invalid probability\");\n        require(_rewardPercentage <= 10000, \"Invalid reward percentage\");\n        \n        instantLotteryConfig = InstantLotteryConfig({\n            baseWinProbability: _baseWinProbability,\n            minSwapAmount: _minSwapAmount,\n            rewardPercentage: _rewardPercentage,\n            isActive: _isActive\n        });\n    }\n\n    function fundJackpot(uint256 /*amount*/) external payable onlyOwner {\n        // Fund the jackpot distributor\n        require(address(jackpotDistributor) != address(0), \"Distributor not set\");\n        \n        if (msg.value > 0) {\n            // Send native S to distributor (if it accepts ETH)\n            payable(address(jackpotDistributor)).transfer(msg.value);\n        }\n    }\n\n    /**\n     * @notice Fund jackpot with ERC20 tokens\n     * @param token The ERC20 token address\n     * @param amount The amount of tokens to fund\n     * @dev Caller must approve this contract first for the token amount\n     */\n    function fundJackpotERC20(address token, uint256 amount) external onlyOwner {\n        require(address(jackpotDistributor) != address(0), \"Distributor not set\");\n        require(token != address(0), \"Invalid token address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        \n        // Transfer tokens from caller to this contract\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // Approve and add to jackpot distributor\n        IERC20(token).forceApprove(address(jackpotDistributor), amount);\n        jackpotDistributor.addToJackpot(amount);\n    }\n\n    // ============ LOTTERY FUNCTIONS ============\n    \n    function createLottery(\n        uint256 entryFee,\n        uint256 maxParticipants\n    ) external onlyOwner returns (uint256 lotteryId) {\n        require(maxParticipants <= MAX_PARTICIPANTS_PER_LOTTERY, \"Exceeds max participants\");\n        \n        lotteryId = nextLotteryId++;\n        \n        lotteries[lotteryId] = LotteryConfig({\n            entryFee: entryFee,\n            maxParticipants: maxParticipants,\n            prizePool: 0,\n            isActive: true,\n            participants: new address[](0),\n            vrfRequestId: 0,\n            isDrawn: false,\n            randomnessSource: RandomnessSource.RANDOMNESS_PROVIDER,\n            vrfSequence: 0\n        });\n\n        emit LotteryConfigured(lotteryId, entryFee, maxParticipants);\n    }\n\n    function enterLottery(uint256 lotteryId) external payable nonReentrant {\n        LotteryConfig storage lottery = lotteries[lotteryId];\n        require(lottery.isActive, \"Lottery not active\");\n        require(!lottery.isDrawn, \"Lottery already drawn\");\n        require(lottery.participants.length < lottery.maxParticipants, \"Lottery full\");\n        require(lottery.maxParticipants <= MAX_PARTICIPANTS_PER_LOTTERY, \"Exceeds max participants\");\n        require(msg.value == lottery.entryFee, \"Incorrect entry fee\");\n\n        lottery.participants.push(msg.sender);\n        lottery.prizePool += msg.value;\n\n        emit LotteryEntered(lotteryId, msg.sender, msg.value);\n\n        // Auto-draw if lottery is full\n        if (lottery.participants.length == lottery.maxParticipants) {\n            _requestRandomnessForLottery(lotteryId);\n        }\n    }\n\n    function drawLottery(uint256 lotteryId) external onlyOwner {\n        LotteryConfig storage lottery = lotteries[lotteryId];\n        require(lottery.isActive, \"Lottery not active\");\n        require(!lottery.isDrawn, \"Lottery already drawn\");\n        require(lottery.participants.length > 0, \"No participants\");\n\n        _requestRandomnessForLottery(lotteryId);\n    }\n\n    function _requestRandomnessForLottery(uint256 lotteryId) internal {\n        LotteryConfig storage lottery = lotteries[lotteryId];\n        \n        // Try Chainlink VRF first (most secure)\n        if (address(vrfIntegrator) != address(0)) {\n            uint256 vrfFee = 0.25 ether; // Proven working fee amount\n            require(address(this).balance >= vrfFee, \"Insufficient balance for VRF fee\");\n            \n            try vrfIntegrator.requestRandomWordsSimple{value: vrfFee}(30110) returns (\n                MessagingReceipt memory, \n                uint64 requestId\n            ) {\n                lottery.vrfRequestId = requestId;\n                lottery.vrfSequence = requestId;\n                lottery.randomnessSource = RandomnessSource.CHAINLINK_VRF;\n                vrfRequestToLottery[requestId] = lotteryId;\n                \n                emit RandomnessRequested(lotteryId, requestId);\n                return;\n            } catch {\n                // VRF failed, fall back to randomness provider\n            }\n        }\n        \n        // Fallback to randomness provider\n        if (address(randomnessProvider) != address(0)) {\n            uint256 poolFee = 0.0001 ether; \n            require(address(this).balance >= poolFee, \"Insufficient balance for pool fee\");\n            \n            uint256 requestId = randomnessProvider.requestRandomnessFromPool{value: poolFee}();\n            lottery.vrfRequestId = requestId;\n            lottery.randomnessSource = RandomnessSource.RANDOMNESS_PROVIDER;\n            vrfRequestToLottery[requestId] = lotteryId;\n            \n            emit RandomnessRequested(lotteryId, requestId);\n        } else {\n            revert(\"No randomness source available\");\n        }\n    }\n\n    function fulfillLottery(uint256 lotteryId) external onlyOwner {\n        LotteryConfig storage lottery = lotteries[lotteryId];\n        require(lottery.vrfRequestId != 0, \"No randomness request for this lottery\");\n        require(!lottery.isDrawn, \"Lottery already drawn\");\n        \n        uint256 randomness;\n        bool fulfilled = false;\n        \n        // Check fulfillment based on randomness source\n        if (lottery.randomnessSource == RandomnessSource.CHAINLINK_VRF) {\n            // Check VRF integrator for fulfillment\n            if (address(vrfIntegrator) != address(0)) {\n                (uint256 randomWord, bool vrfFulfilled) = vrfIntegrator.getRandomWord(lottery.vrfSequence);\n                if (vrfFulfilled && randomWord != 0) {\n                    randomness = randomWord;\n                    fulfilled = true;\n                }\n            }\n        } else if (lottery.randomnessSource == RandomnessSource.RANDOMNESS_PROVIDER) {\n            // Check randomness provider for fulfillment\n            if (address(randomnessProvider) != address(0)) {\n                (,, bool providerFulfilled, uint256 randomValue,) = randomnessProvider.getRandomnessRequest(lottery.vrfRequestId);\n                if (providerFulfilled) {\n                    randomness = randomValue;\n                    fulfilled = true;\n                }\n            }\n        }\n        \n        require(fulfilled, \"Randomness request not fulfilled\");\n        require(randomness != 0, \"Invalid random value\");\n\n        uint256 winnerIndex = randomness % lottery.participants.length;\n        address winner = lottery.participants[winnerIndex];\n\n        lottery.isDrawn = true;\n        lottery.isActive = false;\n\n        // Transfer prize to winner\n        (bool success, ) = winner.call{value: lottery.prizePool}(\"\");\n        require(success, \"Prize transfer failed\");\n\n        emit LotteryDrawn(lotteryId, winner, lottery.prizePool);\n        emit RandomnessFulfilled(lottery.vrfRequestId, randomness);\n    }\n\n    // ============ INSTANT LOTTERY FUNCTIONS ============\n    \n    function processInstantLottery(\n        address user,\n        uint256 swapAmount\n    ) external onlyAuthorizedSwapContract rateLimited(user) nonReentrant {\n        require(instantLotteryConfig.isActive, \"Instant lottery not active\");\n        require(swapAmount >= instantLotteryConfig.minSwapAmount, \"Swap amount too small\");\n\n        // Update user stats\n        UserStats storage stats = userStats[user];\n        stats.totalSwaps++;\n        stats.totalVolume += swapAmount;\n\n        // Calculate swap amount-based probability using veDRAGONMath scaling\n        uint256 swapBasedProbability = _calculateSwapBasedProbability(swapAmount);\n        \n        // Add loyalty bonus\n        uint256 loyaltyBonus = _calculateLoyaltyBonus(user);\n        uint256 winProbability = swapBasedProbability + loyaltyBonus;\n        \n        // Cap at maximum probability (4% = 400 basis points)\n        if (winProbability > 400) winProbability = 400;\n\n        // Get secure randomness from provider for per-swap lottery\n        uint256 randomness = randomnessProvider.drawUnpredictableFromPool(\n            user,\n            address(0), // tokenA - could be passed from swap contract\n            address(0), // tokenB - could be passed from swap contract  \n            swapAmount,\n            swapAmount  // amountOut - could be passed from swap contract\n        );\n        bool won = (randomness % 10000) < winProbability;\n\n        uint256 reward = 0;\n        if (won) {\n            // Reward comes from accumulated jackpot, not percentage of swap\n            uint256 availableJackpot = jackpotDistributor.getCurrentJackpot();\n            if (availableJackpot > 0) {\n                // Get a percentage of current jackpot as reward\n                reward = (availableJackpot * instantLotteryConfig.rewardPercentage) / 10000;\n                \n                stats.totalWins++;\n                stats.totalRewards += reward;\n                \n                // Distribute reward via jackpot distributor\n                jackpotDistributor.distributeJackpot(user, reward);\n            } else {\n                won = false; // No jackpot available\n            }\n        }\n\n        emit InstantLotteryProcessed(user, swapAmount, won, reward);\n    }\n\n    /**\n     * @dev Calculate swap-based win probability using logarithmic scaling\n     * @param swapAmount The swap amount in token units (assumes 1:1 USD ratio)\n     * @return Probability in basis points (1 BP = 0.01%)\n     * \n     * LOGARITHMIC SCALING FORMULA:\n     * - $10 swap = 1 basis point (0.01% - rounded up from 0.004% for eligibility)\n     * - $100 swap = 4 basis points (0.04%)\n     * - $1,000 swap = 40 basis points (0.4%)  \n     * - $10,000 swap = 400 basis points (4%)\n     * \n     * Implementation uses piecewise linear interpolation to approximate log10 scaling.\n     * WARNING: Assumes swapAmount is in token units equivalent to USD value.\n     * Integer arithmetic may introduce small rounding errors near boundaries.\n     */\n    function _calculateSwapBasedProbability(uint256 swapAmount) internal pure returns (uint256) {\n        uint256 minAmount = 10 ether; // $10 equivalent in token units\n        uint256 maxAmount = 10000 ether; // $10,000 equivalent in token units\n        \n        if (swapAmount < minAmount) {\n            return 0; // Below minimum\n        } else if (swapAmount >= maxAmount) {\n            return 400; // 4% maximum\n        } else {\n            // Logarithmic scaling implementation\n            // Calculate log10(swapAmount / $10) and scale appropriately\n            \n            uint256 ratio = (swapAmount * 1000) / minAmount; // Multiply by 1000 for precision\n            uint256 logValue = 0;\n            \n            // Simple log10 approximation for the specific range we need\n            if (ratio >= 1000000) { // >= $10,000\n                logValue = 3000; // log10(1000) * 1000 = 3000\n            } else if (ratio >= 100000) { // >= $1,000  \n                logValue = 2000 + ((ratio - 100000) * 1000) / 900000; // Interpolate between 2.0 and 3.0\n            } else if (ratio >= 10000) { // >= $100\n                logValue = 1000 + ((ratio - 10000) * 1000) / 90000; // Interpolate between 1.0 and 2.0\n            } else { // >= $10\n                logValue = (ratio - 1000) * 1000 / 9000; // Interpolate between 0.0 and 1.0\n            }\n            \n            // Convert log value to basis points: 0.4 * 10^logValue\n            // Base is 0.4 basis points, multiply by 10^(logValue/1000)\n            uint256 probabilityBP;\n            if (logValue == 0) {\n                probabilityBP = 1; // Round 0.4 up to 1 for minimum eligibility\n            } else if (logValue <= 1000) { // 0-1x multiplier\n                probabilityBP = 1 + (logValue * 3) / 1000; // Scale from 1 to 4 basis points\n            } else if (logValue <= 2000) { // 1-2x multiplier  \n                probabilityBP = 4 + ((logValue - 1000) * 36) / 1000; // Scale from 4 to 40 basis points\n            } else { // 2-3x multiplier\n                probabilityBP = 40 + ((logValue - 2000) * 360) / 1000; // Scale from 40 to 400 basis points\n            }\n            \n            return probabilityBP;\n        }\n    }\n\n    function _calculateLoyaltyBonus(address user) internal view returns (uint256) {\n        UserStats memory stats = userStats[user];\n        \n        // Loyalty bonus: 1 basis point per 10 swaps (max 50 basis points)\n        uint256 swapBonus = (stats.totalSwaps / 10) * 1;\n        if (swapBonus > 50) swapBonus = 50;\n        \n        // Volume bonus: 1 basis point per 100 tokens volume (max 30 basis points)\n        uint256 volumeBonus = (stats.totalVolume / (100 * 1e18)) * 1;\n        if (volumeBonus > 30) volumeBonus = 30;\n        \n        return swapBonus + volumeBonus;\n    }\n\n    // ============ VIEW FUNCTIONS ============\n    \n    function getLotteryInfo(uint256 lotteryId) external view returns (\n        uint256 entryFee,\n        uint256 maxParticipants,\n        uint256 currentParticipants,\n        uint256 prizePool,\n        bool isActive,\n        bool isDrawn\n    ) {\n        LotteryConfig memory lottery = lotteries[lotteryId];\n        return (\n            lottery.entryFee,\n            lottery.maxParticipants,\n            lottery.participants.length,\n            lottery.prizePool,\n            lottery.isActive,\n            lottery.isDrawn\n        );\n    }\n\n    function getLotteryDetails(uint256 lotteryId) external view returns (\n        uint256 entryFee,\n        uint256 maxParticipants,\n        uint256 currentParticipants,\n        uint256 prizePool,\n        bool isActive,\n        bool isDrawn,\n        uint256 vrfRequestId,\n        uint64 vrfSequence,\n        RandomnessSource randomnessSource,\n        bool randomnessFulfilled\n    ) {\n        LotteryConfig memory lottery = lotteries[lotteryId];\n        \n        bool fulfilled = false;\n        if (lottery.vrfRequestId != 0) {\n            if (lottery.randomnessSource == RandomnessSource.CHAINLINK_VRF && address(vrfIntegrator) != address(0)) {\n                (, fulfilled) = vrfIntegrator.getRandomWord(lottery.vrfSequence);\n            } else if (lottery.randomnessSource == RandomnessSource.RANDOMNESS_PROVIDER && address(randomnessProvider) != address(0)) {\n                (,, fulfilled,,) = randomnessProvider.getRandomnessRequest(lottery.vrfRequestId);\n            }\n        }\n        \n        return (\n            lottery.entryFee,\n            lottery.maxParticipants,\n            lottery.participants.length,\n            lottery.prizePool,\n            lottery.isActive,\n            lottery.isDrawn,\n            lottery.vrfRequestId,\n            lottery.vrfSequence,\n            lottery.randomnessSource,\n            fulfilled\n        );\n    }\n\n    function getLotteryParticipants(uint256 lotteryId) external view returns (address[] memory) {\n        require(lotteries[lotteryId].participants.length <= MAX_PARTICIPANTS_PER_LOTTERY, \"Too many participants for view\");\n        return lotteries[lotteryId].participants;\n    }\n\n    function getLotteryParticipantsPaginated(\n        uint256 lotteryId, \n        uint256 startIndex, \n        uint256 count\n    ) external view returns (address[] memory participants, uint256 totalCount) {\n        address[] storage allParticipants = lotteries[lotteryId].participants;\n        totalCount = allParticipants.length;\n        \n        require(startIndex < totalCount, \"Start index out of bounds\");\n        \n        uint256 endIndex = startIndex + count;\n        if (endIndex > totalCount) {\n            endIndex = totalCount;\n        }\n        \n        participants = new address[](endIndex - startIndex);\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            participants[i - startIndex] = allParticipants[i];\n        }\n    }\n\n    function getUserStats(address user) external view returns (\n        uint256 totalSwaps,\n        uint256 totalVolume,\n        uint256 totalWins,\n        uint256 totalRewards,\n        uint256 winRate\n    ) {\n        UserStats memory stats = userStats[user];\n        uint256 currentWinRate = stats.totalSwaps > 0 ? (stats.totalWins * 10000) / stats.totalSwaps : 0;\n        \n        return (\n            stats.totalSwaps,\n            stats.totalVolume,\n            stats.totalWins,\n            stats.totalRewards,\n            currentWinRate\n        );\n    }\n\n    function getInstantLotteryConfig() external view returns (\n        uint256 baseWinProbability,\n        uint256 minSwapAmount,\n        uint256 rewardPercentage,\n        bool isActive\n    ) {\n        return (\n            instantLotteryConfig.baseWinProbability,\n            instantLotteryConfig.minSwapAmount,\n            instantLotteryConfig.rewardPercentage,\n            instantLotteryConfig.isActive\n        );\n    }\n\n    function getRewardPoolBalance() external view returns (uint256) {\n        if (address(jackpotDistributor) != address(0)) {\n            return jackpotDistributor.getCurrentJackpot();\n        }\n        return 0;\n    }\n\n    function getJackpotVaultBalance() external view returns (uint256) {\n        if (address(jackpotVault) != address(0)) {\n            return jackpotVault.getJackpotBalance();\n        }\n        return 0;\n    }\n\n    function calculateWinProbability(address user, uint256 swapAmount) external view returns (uint256) {\n        uint256 swapBasedProbability = _calculateSwapBasedProbability(swapAmount);\n        uint256 loyaltyBonus = _calculateLoyaltyBonus(user);\n        uint256 winProbability = swapBasedProbability + loyaltyBonus;\n        if (winProbability > 400) winProbability = 400; // Cap at 4%\n        return winProbability;\n    }\n\n    function calculateWinProbability(address user) external view returns (uint256) {\n        // Legacy function - uses minimum swap amount for probability calculation\n        uint256 minSwap = 10 ether; // $10\n        return this.calculateWinProbability(user, minSwap);\n    }\n\n    function calculatePotentialReward(uint256 /*swapAmount*/) external view returns (uint256) {\n        // Reward now comes from jackpot percentage, not swap percentage\n        uint256 availableJackpot = address(jackpotDistributor) != address(0) ? \n            jackpotDistributor.getCurrentJackpot() : 0;\n        return (availableJackpot * instantLotteryConfig.rewardPercentage) / 10000;\n    }\n\n    function calculateSwapBasedProbability(uint256 swapAmount) external pure returns (uint256) {\n        return _calculateSwapBasedProbability(swapAmount);\n    }\n\n    // ============ VRF CALLBACK FUNCTION ============\n    \n    /**\n     * @notice Receive random words from VRF integrator (automatic callback)\n     * @param randomWords Array of random words\n     * @param sequence The request sequence number\n     */\n    function receiveRandomWords(uint256[] memory randomWords, uint64 sequence) external override {\n        require(msg.sender == address(vrfIntegrator), \"Only VRF integrator can call\");\n        require(randomWords.length > 0, \"No random words provided\");\n        \n        // Find the lottery associated with this sequence\n        uint256 lotteryId = vrfRequestToLottery[sequence];\n        require(lotteryId != 0, \"No lottery found for this sequence\");\n        \n        LotteryConfig storage lottery = lotteries[lotteryId];\n        require(lottery.vrfSequence == sequence, \"Sequence mismatch\");\n        require(!lottery.isDrawn, \"Lottery already drawn\");\n        require(lottery.randomnessSource == RandomnessSource.CHAINLINK_VRF, \"Not a VRF lottery\");\n        \n        // Automatically fulfill the lottery with the received random word\n        uint256 randomness = randomWords[0];\n        uint256 winnerIndex = randomness % lottery.participants.length;\n        address winner = lottery.participants[winnerIndex];\n\n        lottery.isDrawn = true;\n        lottery.isActive = false;\n\n        // Transfer prize to winner\n        (bool success, ) = winner.call{value: lottery.prizePool}(\"\");\n        require(success, \"Prize transfer failed\");\n\n        emit LotteryDrawn(lotteryId, winner, lottery.prizePool);\n        emit RandomnessFulfilled(lottery.vrfRequestId, randomness);\n    }\n\n    // ============ EMERGENCY FUNCTIONS ============\n    \n    function emergencyWithdrawETH() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function emergencyWithdrawS(uint256 amount) external onlyOwner {\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        payable(owner()).transfer(amount);\n    }\n\n    function getJackpotContracts() external view returns (address vault, address distributor) {\n        return (address(jackpotVault), address(jackpotDistributor));\n    }\n\n    /**\n     * @notice Check if this contract is registered for Sonic FeeM\n     * @return isRegistered Whether the contract is registered for fee monetization\n     */\n    function checkFeeMStatus() external view returns (bool isRegistered) {\n    }\n\n    // Required to receive ETH\n    receive() external payable {}\n} "
    },
    "contracts/core/oracles/DragonDataMigrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Ownable } from 'lib/openzeppelin-contracts/contracts/access/Ownable.sol';\nimport { ReentrancyGuard } from 'lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol';\n\n// Legacy contract interfaces\ninterface ILegacyDragonMarketController {\n    function getFees() external view returns (uint256, uint256, uint256, uint256);\n    function getMarketData() external view returns (int256, uint256, uint256, uint256, uint256, uint256);\n    function jackpotSize() external view returns (uint256);\n    function cumulativeVolume() external view returns (uint256);\n    function dailyVolume() external view returns (uint256);\n    function lastVolumeReset() external view returns (uint256);\n}\n\ninterface ILegacyDragonMarketOracle {\n    function getLatestPrice() external view returns (int256, uint256);\n    function getMarketConditions() external view returns (uint256);\n    function totalSwapVolume() external view returns (uint256);\n    function swapCount() external view returns (uint256);\n}\n\ninterface ILegacyOmniDragonMarketOracle {\n    function getCrossChainMarketData() external view returns (\n        int256 aggregatedPrice,\n        uint256 totalJackpot,\n        uint256 totalLiquidity,\n        uint256 networkCount,\n        uint256 lastUpdate\n    );\n    function getSupportedNetworks() external view returns (uint32[] memory, string[] memory);\n}\n\n// New consolidated contract interfaces\ninterface IConsolidatedDragonOracle {\n    function initialize(\n        uint256 _totalFee,\n        uint256 _initialJackpotFee,\n        address _chainlinkSUSD,\n        address _bandProtocol,\n        address _api3Proxy,\n        address _pythNetwork\n    ) external;\n    \n    function addSupportedNetwork(uint32 eid, string calldata name) external;\n    function setOperationMode(uint8 _newMode) external;\n}\n\ninterface IIntegratedDragonMarketManager {\n    function initialize(\n        uint256 _totalFee,\n        uint256 _initialJackpotFee,\n        address _chainlinkSUSD,\n        address _bandProtocol,\n        address _api3Proxy,\n        address _pythNetwork\n    ) external;\n    \n    function updateJackpotSize(uint256 _newJackpotSize) external;\n    function addVolume(uint256 _volumeAmount) external;\n    function addSupportedNetwork(uint32 eid, string calldata name) external;\n    function setOperationMode(uint8 _newMode) external;\n}\n\n/**\n * @title DragonDataMigrator\n * @dev Direct upgrade system for transitioning from old Dragon contracts to new ones\n *\n * DRAGON DATA MIGRATOR SYSTEM\n * This contract handles the upgrade process from legacy Dragon contracts to the new\n * consolidated Dragon system. It automates data transfer, validates upgrades, and\n * provides rollback capabilities if needed.\n *\n * UPGRADE FEATURES:\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * âœ… Automated data transfer from old contracts\n * âœ… Data validation and integrity checks\n * âœ… Rollback capabilities for failed upgrades\n * âœ… Phased upgrade process with progress tracking\n * âœ… Gas-optimized operations\n * âœ… Complete audit trail\n *\n * UPGRADE PHASES:\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * 1. PREPARATION: Validate old contracts and prepare upgrade\n * 2. ORACLE_MIGRATION: Transfer oracle data and settings\n * 3. CONTROLLER_MIGRATION: Transfer controller state and fees\n * 4. CROSS_CHAIN_MIGRATION: Transfer cross-chain configurations\n * 5. VALIDATION: Validate all transferred data\n * 6. FINALIZATION: Complete upgrade and activate new contracts\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract DragonDataMigrator is Ownable, ReentrancyGuard {\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // ENUMS AND STRUCTS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    enum MigrationPhase {\n        NOT_STARTED,\n        PREPARATION,\n        ORACLE_MIGRATION,\n        CONTROLLER_MIGRATION,\n        CROSS_CHAIN_MIGRATION,\n        VALIDATION,\n        FINALIZATION,\n        COMPLETED,\n        FAILED\n    }\n\n    struct LegacyContracts {\n        address controller;\n        address oracle;\n        address omniOracle;\n        address feeManager;\n        address analyzer;\n    }\n\n    struct ConsolidatedContracts {\n        address consolidatedOracle;\n        address integratedManager;\n        address enhancedAnalyzer;\n    }\n\n    struct MigrationState {\n        MigrationPhase currentPhase;\n        uint256 startTime;\n        uint256 lastUpdateTime;\n        uint256 totalSteps;\n        uint256 completedSteps;\n        bool canRollback;\n        string lastError;\n    }\n\n    struct MigratedData {\n        // Oracle data\n        int256 latestPrice;\n        uint256 lastPriceUpdate;\n        uint256 marketScore;\n        \n        // Controller data\n        uint256 totalFee;\n        uint256 jackpotFee;\n        uint256 liquidityFee;\n        uint256 burnFee;\n        uint256 jackpotSize;\n        uint256 cumulativeVolume;\n        uint256 dailyVolume;\n        \n        // Cross-chain data\n        uint32[] supportedNetworks;\n        string[] networkNames;\n        \n        // Validation flags\n        bool oracleDataValid;\n        bool controllerDataValid;\n        bool crossChainDataValid;\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // STATE VARIABLES\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    LegacyContracts public legacyContracts;\n    ConsolidatedContracts public consolidatedContracts;\n    MigrationState public migrationState;\n    MigratedData public migratedData;\n\n    // Migration configuration\n    uint256 public constant MAX_MIGRATION_TIME = 24 hours;\n    uint256 public constant VALIDATION_THRESHOLD = 9500; // 95% accuracy required\n    bool public emergencyStop;\n\n    // Rollback data\n    mapping(string => bytes) public rollbackData;\n    string[] public rollbackKeys;\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // EVENTS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    event MigrationStarted(address indexed initiator, uint256 timestamp);\n    event PhaseCompleted(MigrationPhase indexed phase, uint256 timestamp, uint256 stepCount);\n    event MigrationCompleted(uint256 totalTime, uint256 totalSteps);\n    event MigrationFailed(MigrationPhase indexed phase, string reason);\n    event RollbackInitiated(MigrationPhase indexed fromPhase, address indexed initiator);\n    event RollbackCompleted(uint256 timestamp);\n    event DataValidated(string indexed dataType, bool isValid, uint256 accuracy);\n    event EmergencyStopActivated(address indexed activator, string reason);\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // CONSTRUCTOR\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    constructor(\n        LegacyContracts memory _legacyContracts,\n        ConsolidatedContracts memory _consolidatedContracts\n    ) Ownable(msg.sender) {\n        legacyContracts = _legacyContracts;\n        consolidatedContracts = _consolidatedContracts;\n        \n        migrationState = MigrationState({\n            currentPhase: MigrationPhase.NOT_STARTED,\n            startTime: 0,\n            lastUpdateTime: 0,\n            totalSteps: 0,\n            completedSteps: 0,\n            canRollback: false,\n            lastError: \"\"\n        });\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // MIGRATION CONTROL FUNCTIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Start the migration process\n     */\n    function startMigration() external onlyOwner nonReentrant {\n        require(migrationState.currentPhase == MigrationPhase.NOT_STARTED, \"Migration already started\");\n        require(!emergencyStop, \"Emergency stop active\");\n        \n        migrationState.currentPhase = MigrationPhase.PREPARATION;\n        migrationState.startTime = block.timestamp;\n        migrationState.lastUpdateTime = block.timestamp;\n        migrationState.totalSteps = 25; // Estimated total steps\n        migrationState.completedSteps = 0;\n        migrationState.canRollback = true;\n        \n        emit MigrationStarted(msg.sender, block.timestamp);\n        \n        // Start with preparation phase\n        _executePreparationPhase();\n    }\n\n    /**\n     * @dev Continue migration to next phase\n     */\n    function continueToNextPhase() external onlyOwner nonReentrant {\n        require(!emergencyStop, \"Emergency stop active\");\n        require(migrationState.currentPhase != MigrationPhase.NOT_STARTED, \"Migration not started\");\n        require(migrationState.currentPhase != MigrationPhase.COMPLETED, \"Migration already completed\");\n        require(migrationState.currentPhase != MigrationPhase.FAILED, \"Migration failed\");\n        \n        if (migrationState.currentPhase == MigrationPhase.PREPARATION) {\n            _executeOracleMigration();\n        } else if (migrationState.currentPhase == MigrationPhase.ORACLE_MIGRATION) {\n            _executeControllerMigration();\n        } else if (migrationState.currentPhase == MigrationPhase.CONTROLLER_MIGRATION) {\n            _executeCrossChainMigration();\n        } else if (migrationState.currentPhase == MigrationPhase.CROSS_CHAIN_MIGRATION) {\n            _executeValidation();\n        } else if (migrationState.currentPhase == MigrationPhase.VALIDATION) {\n            _executeFinalization();\n        }\n    }\n\n    /**\n     * @dev Initiate rollback to previous state\n     */\n    function initiateRollback() external onlyOwner {\n        require(migrationState.canRollback, \"Rollback not available\");\n        require(migrationState.currentPhase != MigrationPhase.COMPLETED, \"Cannot rollback completed migration\");\n        \n        emit RollbackInitiated(migrationState.currentPhase, msg.sender);\n        \n        _executeRollback();\n    }\n\n    /**\n     * @dev Activate emergency stop\n     */\n    function activateEmergencyStop(string calldata reason) external onlyOwner {\n        emergencyStop = true;\n        emit EmergencyStopActivated(msg.sender, reason);\n    }\n\n    /**\n     * @dev Deactivate emergency stop\n     */\n    function deactivateEmergencyStop() external onlyOwner {\n        emergencyStop = false;\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // MIGRATION PHASE IMPLEMENTATIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Execute preparation phase\n     */\n    function _executePreparationPhase() internal {\n        try this._validateLegacyContracts() {\n            migrationState.completedSteps += 5;\n            migrationState.currentPhase = MigrationPhase.ORACLE_MIGRATION;\n            migrationState.lastUpdateTime = block.timestamp;\n            \n            emit PhaseCompleted(MigrationPhase.PREPARATION, block.timestamp, 5);\n        } catch Error(string memory reason) {\n            _handleMigrationFailure(reason);\n        }\n    }\n\n    /**\n     * @dev Execute oracle migration phase\n     */\n    function _executeOracleMigration() internal {\n        try this._migrateOracleData() {\n            migrationState.completedSteps += 6;\n            migrationState.currentPhase = MigrationPhase.CONTROLLER_MIGRATION;\n            migrationState.lastUpdateTime = block.timestamp;\n            \n            emit PhaseCompleted(MigrationPhase.ORACLE_MIGRATION, block.timestamp, 6);\n        } catch Error(string memory reason) {\n            _handleMigrationFailure(reason);\n        }\n    }\n\n    /**\n     * @dev Execute controller migration phase\n     */\n    function _executeControllerMigration() internal {\n        try this._migrateControllerData() {\n            migrationState.completedSteps += 7;\n            migrationState.currentPhase = MigrationPhase.CROSS_CHAIN_MIGRATION;\n            migrationState.lastUpdateTime = block.timestamp;\n            \n            emit PhaseCompleted(MigrationPhase.CONTROLLER_MIGRATION, block.timestamp, 7);\n        } catch Error(string memory reason) {\n            _handleMigrationFailure(reason);\n        }\n    }\n\n    /**\n     * @dev Execute cross-chain migration phase\n     */\n    function _executeCrossChainMigration() internal {\n        try this._migrateCrossChainData() {\n            migrationState.completedSteps += 4;\n            migrationState.currentPhase = MigrationPhase.VALIDATION;\n            migrationState.lastUpdateTime = block.timestamp;\n            \n            emit PhaseCompleted(MigrationPhase.CROSS_CHAIN_MIGRATION, block.timestamp, 4);\n        } catch Error(string memory reason) {\n            _handleMigrationFailure(reason);\n        }\n    }\n\n    /**\n     * @dev Execute validation phase\n     */\n    function _executeValidation() internal {\n        try this._validateMigratedData() {\n            migrationState.completedSteps += 2;\n            migrationState.currentPhase = MigrationPhase.FINALIZATION;\n            migrationState.lastUpdateTime = block.timestamp;\n            \n            emit PhaseCompleted(MigrationPhase.VALIDATION, block.timestamp, 2);\n        } catch Error(string memory reason) {\n            _handleMigrationFailure(reason);\n        }\n    }\n\n    /**\n     * @dev Execute finalization phase\n     */\n    function _executeFinalization() internal {\n        try this._finalizeMigration() {\n            migrationState.completedSteps += 1;\n            migrationState.currentPhase = MigrationPhase.COMPLETED;\n            migrationState.lastUpdateTime = block.timestamp;\n            migrationState.canRollback = false;\n            \n            uint256 totalTime = block.timestamp - migrationState.startTime;\n            emit MigrationCompleted(totalTime, migrationState.totalSteps);\n        } catch Error(string memory reason) {\n            _handleMigrationFailure(reason);\n        }\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // MIGRATION IMPLEMENTATION FUNCTIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Validate legacy contracts\n     */\n    function _validateLegacyContracts() external view {\n        require(legacyContracts.controller != address(0), \"Invalid controller address\");\n        require(legacyContracts.oracle != address(0), \"Invalid oracle address\");\n        \n        // Validate contract interfaces by calling key functions\n        ILegacyDragonMarketController(legacyContracts.controller).getFees();\n        ILegacyDragonMarketOracle(legacyContracts.oracle).getLatestPrice();\n        \n        if (legacyContracts.omniOracle != address(0)) {\n            ILegacyOmniDragonMarketOracle(legacyContracts.omniOracle).getCrossChainMarketData();\n        }\n    }\n\n    /**\n     * @dev Migrate oracle data\n     */\n    function _migrateOracleData() external {\n        // Extract oracle data\n        (int256 price, uint256 timestamp) = ILegacyDragonMarketOracle(legacyContracts.oracle).getLatestPrice();\n        uint256 marketConditions = ILegacyDragonMarketOracle(legacyContracts.oracle).getMarketConditions();\n        \n        // Store migrated data\n        migratedData.latestPrice = price;\n        migratedData.lastPriceUpdate = timestamp;\n        migratedData.marketScore = marketConditions;\n        migratedData.oracleDataValid = true;\n        \n        // Store rollback data\n        rollbackData[\"oracle_price\"] = abi.encode(price, timestamp);\n        rollbackData[\"oracle_conditions\"] = abi.encode(marketConditions);\n        rollbackKeys.push(\"oracle_price\");\n        rollbackKeys.push(\"oracle_conditions\");\n        \n        emit DataValidated(\"oracle\", true, 10000);\n    }\n\n    /**\n     * @dev Migrate controller data\n     */\n    function _migrateControllerData() external {\n        // Extract controller data\n        (uint256 jackpotFee, uint256 liquidityFee, uint256 burnFee, uint256 totalFee) = \n            ILegacyDragonMarketController(legacyContracts.controller).getFees();\n        \n        uint256 jackpotSize = ILegacyDragonMarketController(legacyContracts.controller).jackpotSize();\n        uint256 cumulativeVolume = ILegacyDragonMarketController(legacyContracts.controller).cumulativeVolume();\n        uint256 dailyVolume = ILegacyDragonMarketController(legacyContracts.controller).dailyVolume();\n        \n        // Store migrated data\n        migratedData.totalFee = totalFee;\n        migratedData.jackpotFee = jackpotFee;\n        migratedData.liquidityFee = liquidityFee;\n        migratedData.burnFee = burnFee;\n        migratedData.jackpotSize = jackpotSize;\n        migratedData.cumulativeVolume = cumulativeVolume;\n        migratedData.dailyVolume = dailyVolume;\n        migratedData.controllerDataValid = true;\n        \n        // Store rollback data\n        rollbackData[\"controller_fees\"] = abi.encode(jackpotFee, liquidityFee, burnFee, totalFee);\n        rollbackData[\"controller_volumes\"] = abi.encode(jackpotSize, cumulativeVolume, dailyVolume);\n        rollbackKeys.push(\"controller_fees\");\n        rollbackKeys.push(\"controller_volumes\");\n        \n        emit DataValidated(\"controller\", true, 10000);\n    }\n\n    /**\n     * @dev Migrate cross-chain data\n     */\n    function _migrateCrossChainData() external {\n        if (legacyContracts.omniOracle != address(0)) {\n            // Extract cross-chain data\n            (uint32[] memory eids, string[] memory names) = \n                ILegacyOmniDragonMarketOracle(legacyContracts.omniOracle).getSupportedNetworks();\n            \n            // Store migrated data\n            migratedData.supportedNetworks = eids;\n            migratedData.networkNames = names;\n            migratedData.crossChainDataValid = true;\n            \n            // Store rollback data\n            rollbackData[\"cross_chain_networks\"] = abi.encode(eids, names);\n            rollbackKeys.push(\"cross_chain_networks\");\n        } else {\n            migratedData.crossChainDataValid = true; // No cross-chain data to migrate\n        }\n        \n        emit DataValidated(\"cross_chain\", true, 10000);\n    }\n\n    /**\n     * @dev Validate migrated data\n     */\n    function _validateMigratedData() external view {\n        require(migratedData.oracleDataValid, \"Oracle data validation failed\");\n        require(migratedData.controllerDataValid, \"Controller data validation failed\");\n        require(migratedData.crossChainDataValid, \"Cross-chain data validation failed\");\n        \n        // Additional validation checks\n        require(migratedData.latestPrice > 0, \"Invalid migrated price\");\n        require(migratedData.totalFee > 0, \"Invalid migrated total fee\");\n        require(migratedData.totalFee == migratedData.jackpotFee + migratedData.liquidityFee + migratedData.burnFee, \n                \"Fee allocation mismatch\");\n    }\n\n    /**\n     * @dev Finalize migration\n     */\n    function _finalizeMigration() external {\n        // Initialize consolidated oracle\n        if (consolidatedContracts.consolidatedOracle != address(0)) {\n            IConsolidatedDragonOracle(consolidatedContracts.consolidatedOracle).initialize(\n                migratedData.totalFee,\n                migratedData.jackpotFee,\n                address(0), // Oracle addresses to be set separately\n                address(0),\n                address(0),\n                address(0)\n            );\n        }\n        \n        // Initialize integrated manager\n        if (consolidatedContracts.integratedManager != address(0)) {\n            IIntegratedDragonMarketManager(consolidatedContracts.integratedManager).initialize(\n                migratedData.totalFee,\n                migratedData.jackpotFee,\n                address(0), // Oracle addresses to be set separately\n                address(0),\n                address(0),\n                address(0)\n            );\n            \n            // Migrate state data\n            IIntegratedDragonMarketManager(consolidatedContracts.integratedManager).updateJackpotSize(migratedData.jackpotSize);\n            IIntegratedDragonMarketManager(consolidatedContracts.integratedManager).addVolume(migratedData.cumulativeVolume);\n            \n            // Migrate cross-chain networks\n            for (uint256 i = 0; i < migratedData.supportedNetworks.length; i++) {\n                IIntegratedDragonMarketManager(consolidatedContracts.integratedManager).addSupportedNetwork(\n                    migratedData.supportedNetworks[i],\n                    migratedData.networkNames[i]\n                );\n            }\n        }\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // ROLLBACK FUNCTIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Execute rollback\n     */\n    function _executeRollback() internal {\n        // Clear migrated data\n        delete migratedData;\n        \n        // Clear rollback data\n        for (uint256 i = 0; i < rollbackKeys.length; i++) {\n            delete rollbackData[rollbackKeys[i]];\n        }\n        delete rollbackKeys;\n        \n        // Reset migration state\n        migrationState.currentPhase = MigrationPhase.NOT_STARTED;\n        migrationState.startTime = 0;\n        migrationState.lastUpdateTime = 0;\n        migrationState.completedSteps = 0;\n        migrationState.canRollback = false;\n        migrationState.lastError = \"\";\n        \n        emit RollbackCompleted(block.timestamp);\n    }\n\n    /**\n     * @dev Handle migration failure\n     */\n    function _handleMigrationFailure(string memory reason) internal {\n        migrationState.currentPhase = MigrationPhase.FAILED;\n        migrationState.lastError = reason;\n        migrationState.lastUpdateTime = block.timestamp;\n        \n        emit MigrationFailed(migrationState.currentPhase, reason);\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // VIEW FUNCTIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Get migration progress\n     */\n    function getMigrationProgress() external view returns (\n        MigrationPhase phase,\n        uint256 progressPercent,\n        uint256 timeElapsed,\n        uint256 estimatedTimeRemaining\n    ) {\n        phase = migrationState.currentPhase;\n        \n        if (migrationState.totalSteps > 0) {\n            progressPercent = (migrationState.completedSteps * 100) / migrationState.totalSteps;\n        }\n        \n        if (migrationState.startTime > 0) {\n            timeElapsed = block.timestamp - migrationState.startTime;\n            \n            if (migrationState.completedSteps > 0) {\n                uint256 avgTimePerStep = timeElapsed / migrationState.completedSteps;\n                uint256 remainingSteps = migrationState.totalSteps - migrationState.completedSteps;\n                estimatedTimeRemaining = remainingSteps * avgTimePerStep;\n            }\n        }\n    }\n\n    /**\n     * @dev Get migrated data summary\n     */\n    function getMigratedDataSummary() external view returns (\n        bool oracleValid,\n        bool controllerValid,\n        bool crossChainValid,\n        uint256 migratedPrice,\n        uint256 migratedJackpot,\n        uint256 migratedVolume,\n        uint256 networkCount\n    ) {\n        return (\n            migratedData.oracleDataValid,\n            migratedData.controllerDataValid,\n            migratedData.crossChainDataValid,\n            uint256(migratedData.latestPrice),\n            migratedData.jackpotSize,\n            migratedData.cumulativeVolume,\n            migratedData.supportedNetworks.length\n        );\n    }\n\n    /**\n     * @dev Check if migration can proceed\n     */\n    function canProceedToNextPhase() external view returns (bool canProceed, string memory reason) {\n        if (emergencyStop) {\n            return (false, \"Emergency stop active\");\n        }\n        \n        if (migrationState.currentPhase == MigrationPhase.COMPLETED) {\n            return (false, \"Migration already completed\");\n        }\n        \n        if (migrationState.currentPhase == MigrationPhase.FAILED) {\n            return (false, \"Migration failed\");\n        }\n        \n        if (migrationState.startTime > 0 && \n            block.timestamp - migrationState.startTime > MAX_MIGRATION_TIME) {\n            return (false, \"Migration timeout exceeded\");\n        }\n        \n        return (true, \"\");\n    }\n\n    /**\n     * @dev Get rollback data for specific key\n     */\n    function getRollbackData(string calldata key) external view returns (bytes memory data) {\n        return rollbackData[key];\n    }\n\n    /**\n     * @dev Get all rollback keys\n     */\n    function getRollbackKeys() external view returns (string[] memory keys) {\n        return rollbackKeys;\n    }\n}\n\n"
    },
    "contracts/core/oracles/DragonMarketManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Ownable } from 'lib/openzeppelin-contracts/contracts/access/Ownable.sol';\nimport { Pausable } from 'lib/openzeppelin-contracts/contracts/utils/Pausable.sol';\nimport { ReentrancyGuard } from 'lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol';\nimport { EnhancedDragonMarketAnalyzer } from '../../libraries/core/EnhancedDragonMarketAnalyzer.sol';\n\n\n// External Interfaces  \nimport { IUniswapV2Pair } from '../../interfaces/external/uniswap/IUniswapV2Pair.sol';\nimport { AggregatorV3Interface } from 'lib/chainlink-brownie-contracts/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol';\nimport { IStdReference } from 'contracts/interfaces/external/IStdReference.sol';\nimport { IApi3Proxy } from 'contracts/interfaces/external/IApi3Proxy.sol';\nimport { ILayerZeroEndpointV2, Origin, MessagingFee, MessagingParams } from 'lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/ILayerZeroEndpointV2.sol';\nimport { ILayerZeroReceiver } from 'lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/ILayerZeroReceiver.sol';\n\n/**\n * @title DragonPulseOracle\n * @dev Advanced Dragon Market Pulse System with unified oracle and fee intelligence\n *\n * DRAGON PULSE ORACLE SYSTEM\n * This contract represents the beating heart of the Dragon ecosystem, providing\n * real-time market pulse data through a single, highly optimized contract that delivers:\n * - Atomic market data updates and intelligent fee calculations\n * - Multi-oracle price aggregation with cross-chain synchronization\n * - Adaptive fee management based on real-time market pulse\n * - Gas-optimized operations through unified data flow\n * - Comprehensive market pulse analysis and condition scoring\n * - LayerZero V2 integration for cross-chain market awareness\n *\n * ARCHITECTURE BENEFITS:\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * âœ… 20-30% gas savings through eliminated inter-contract calls\n * âœ… Atomic operations ensure consistency between market data and fees\n * âœ… Simplified deployment and configuration management\n * âœ… Enhanced security through reduced external dependencies\n * âœ… Optimized data flow with intelligent caching\n * âœ… Backward compatibility with existing interfaces\n *\n * PULSE OPERATION MODES:\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * 1. LOCAL_ONLY: Basic multi-oracle aggregation with local fee management\n * 2. CROSS_CHAIN_ENABLED: Full LayerZero integration for global market pulse\n * 3. HYBRID_MODE: Cross-chain features with local fallback capabilities\n *\n * FEE STRUCTURE:\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * - Burn Fee: Fixed at 0.69% (69 basis points) - non-configurable\n * - Jackpot Fee: Adaptive based on market pulse conditions (default 6.9%)\n * - LP Fee: Automatically calculated as (totalFee - jackpotFee - burnFee)\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract DragonMarketManager is Ownable, Pausable, ReentrancyGuard, ILayerZeroReceiver {\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // ENUMS AND STRUCTS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    enum OperationMode {\n        LOCAL_ONLY,         // Local pulse only, no cross-chain\n        CROSS_CHAIN_ENABLED,   // Full cross-chain pulse functionality\n        HYBRID_MODE         // Cross-chain pulse with local fallback\n    }\n\n    struct OracleData {\n        int256 price;\n        uint256 timestamp;\n        bool isValid;\n    }\n\n    struct MarketConditions {\n        uint256 score;\n        uint256 liquidityScore;\n        uint256 volatilityScore;\n        uint256 volumeScore;\n        uint256 lastUpdate;\n    }\n\n    struct FeeConfiguration {\n        uint256 totalFee;\n        uint256 burnFee;\n        uint256 jackpotFee;\n        uint256 liquidityFee;\n        uint256 lastUpdate;\n    }\n\n    struct CrossChainData {\n        mapping(uint32 => int256) prices;      // srcEid => price\n        mapping(uint32 => uint256) jackpots;   // srcEid => jackpot\n        mapping(uint32 => uint256) liquidity;  // srcEid => liquidity\n        uint256 totalValue;\n        uint256 lastUpdate;\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // CUSTOM ERRORS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    error TotalFeeTooLow();\n    error FeesExceedTotal();\n    error FeeTooHigh();\n    error IntervalMustBeGreaterThanZero();\n    error AlreadyInitialized();\n    error PriceOracleNotSet();\n    error InvalidPriceOracle();\n    error CircuitBreakerActive();\n    error PriceDataStale();\n    error NoValidOracleData();\n    error CrossChainNotEnabled();\n    error InvalidOperationMode();\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // STATE VARIABLES - CORE SYSTEM\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    // Initialization and configuration\n    bool public initialized;\n    OperationMode public operationMode;\n    \n    // Oracle configuration\n    string public nativeSymbol;\n    string public quoteSymbol;\n    uint8 public constant DECIMALS = 18;\n\n    // Current market state\n    int256 public latestPrice;\n    uint256 public lastPriceUpdate;\n    uint256 public priceDeviation;\n    MarketConditions public marketConditions;\n    FeeConfiguration public feeConfig;\n\n    // Market tracking\n    uint256 public jackpotSize;\n    uint256 public cumulativeVolume;\n    uint256 public dailyVolume;\n    uint256 public lastVolumeReset;\n    uint256 public lastVolumeSnapshot;\n\n    // Circuit breaker and safety\n    uint256 public maxPriceDeviation = 1000; // 10% in basis points\n    uint256 public maxUpdateInterval = 3600; // 1 hour\n    bool public circuitBreakerActive;\n    int256 public minPrice = 1e15; // 0.001 in 18 decimals\n    int256 public maxPrice = 1e24; // 1,000,000 in 18 decimals\n\n    // Update intervals\n    uint256 public feeUpdateInterval = 1 days;\n    uint256 public priceUpdateInterval = 1 hours;\n    uint256 public volumeResetInterval = 1 days;\n    bool public adaptiveFeesEnabled = true;\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // STATE VARIABLES - ORACLE SOURCES\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    // Oracle source weights (basis points, total = 10000)\n    uint256 public chainlinkWeight = 4000; // 40%\n    uint256 public api3Weight = 2000; // 20%\n    uint256 public pythWeight = 1000; // 10%\n    uint256 public bandWeight = 3000; // 30%\n\n    // Oracle contract addresses\n    address public chainlinkSUSDFeed;\n    address public bandProtocolFeed;\n    address public api3ProxyFeed;\n    address public pythNetworkFeed;\n\n    // Oracle data caching\n    mapping(string => OracleData) public oracleCache;\n    uint256 public cacheValidityPeriod = 300; // 5 minutes\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // STATE VARIABLES - CROSS-CHAIN (OPTIONAL)\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    ILayerZeroEndpointV2 public immutable endpoint;\n    bool public crossChainEnabled;\n\n    // Cross-chain data storage\n    CrossChainData internal crossChainData;\n    mapping(uint32 => bool) public supportedNetworks;\n    mapping(uint32 => string) public networkNames;\n    uint32[] public activeNetworks;\n\n    // Channel management\n    mapping(uint32 => mapping(uint32 => bytes)) public channelData; // channel => srcEid => data\n    mapping(uint32 => uint256) public channelLastUpdated; // channel => timestamp\n\n    // Cross-chain constants\n    uint32 public constant PRICE_CHANNEL = 40001;\n    uint32 public constant LIQUIDITY_CHANNEL = 40002;\n    uint32 public constant JACKPOT_CHANNEL = 40003;\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // EVENTS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    // Core system events\n    event Initialized(uint256 totalFee, uint256 jackpotFee, OperationMode mode);\n    event OperationModeChanged(OperationMode indexed oldMode, OperationMode indexed newMode);\n    \n    // Price and market events\n    event PriceUpdated(int256 indexed newPrice, uint256 timestamp, uint256 deviation, uint256 oracleCount);\n    event MarketConditionsUpdated(uint256 score, uint256 liquidity, uint256 volatility, uint256 volume);\n    event CircuitBreakerTriggered(string reason, int256 price, uint256 deviation);\n    event CircuitBreakerReset(address indexed admin);\n    \n    // Fee management events\n    event FeeUpdated(uint256 jackpotFee, uint256 liquidityFee, uint256 burnFee, uint256 totalFee);\n    event JackpotSizeUpdated(uint256 newSize);\n    event VolumeUpdated(uint256 dailyVolume, uint256 totalVolume);\n    event AdaptiveFeesToggled(bool enabled);\n    \n    // Oracle configuration events\n    event OracleAddressUpdated(string indexed oracle, address indexed newAddress);\n    event SourceWeightsUpdated(uint256 chainlink, uint256 api3, uint256 pyth, uint256 band);\n    \n    // Cross-chain events\n    event CrossChainDataReceived(uint32 indexed srcEid, uint32 indexed channel, bytes data, uint256 timestamp);\n    event CrossChainPriceUpdated(uint32 indexed srcEid, int256 price, uint256 timestamp);\n    event NetworkAdded(uint32 indexed eid, string name);\n    event NetworkRemoved(uint32 indexed eid);\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // CONSTRUCTOR\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    constructor(\n        uint256 _totalFee,\n        uint256 _initialJackpotFee,\n        string memory _nativeSymbol,\n        string memory _quoteSymbol,\n        address _chainlinkSUSD,\n        address _bandProtocol,\n        address _api3Proxy,\n        address _pythNetwork,\n        address _endpoint,\n        OperationMode _mode\n    ) Ownable(msg.sender) {\n        // Validate fee configuration\n        if (_totalFee <= EnhancedDragonMarketAnalyzer.BASE_BURN_BPS) revert TotalFeeTooLow();\n        if (_initialJackpotFee + EnhancedDragonMarketAnalyzer.BASE_BURN_BPS > _totalFee) revert FeesExceedTotal();\n\n        // Initialize core configuration\n        nativeSymbol = _nativeSymbol;\n        quoteSymbol = _quoteSymbol;\n        operationMode = _mode;\n        \n        // Initialize fee structure\n        feeConfig = FeeConfiguration({\n            totalFee: _totalFee,\n            burnFee: EnhancedDragonMarketAnalyzer.BASE_BURN_BPS,\n            jackpotFee: _initialJackpotFee,\n            liquidityFee: _totalFee - _initialJackpotFee - EnhancedDragonMarketAnalyzer.BASE_BURN_BPS,\n            lastUpdate: block.timestamp\n        });\n\n        // Initialize price and market state\n        latestPrice = 1e18; // Start at 1.0\n        lastPriceUpdate = block.timestamp;\n        lastVolumeReset = block.timestamp;\n        \n        marketConditions = MarketConditions({\n            score: 5000, // Start at neutral (50%)\n            liquidityScore: 5000,\n            volatilityScore: 5000,\n            volumeScore: 5000,\n            lastUpdate: block.timestamp\n        });\n\n        // Set oracle addresses\n        chainlinkSUSDFeed = _chainlinkSUSD;\n        bandProtocolFeed = _bandProtocol;\n        api3ProxyFeed = _api3Proxy;\n        pythNetworkFeed = _pythNetwork;\n\n        // Initialize LayerZero endpoint\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n        crossChainEnabled = (_mode != OperationMode.LOCAL_ONLY) && (_endpoint != address(0));\n\n        // Mark as initialized if not using placeholder values\n        initialized = !(_totalFee == 1000 && _initialJackpotFee == 690);\n\n        // Register for Sonic FeeM\n\n        emit Initialized(_totalFee, _initialJackpotFee, _mode);\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // INITIALIZATION FUNCTIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Initialize the contract after deployment with placeholder values\n     */\n    function initialize(\n        uint256 _totalFee,\n        uint256 _initialJackpotFee,\n        address _chainlinkSUSD,\n        address _bandProtocol,\n        address _api3Proxy,\n        address _pythNetwork\n    ) external onlyOwner {\n        if (initialized) revert AlreadyInitialized();\n        if (_totalFee <= EnhancedDragonMarketAnalyzer.BASE_BURN_BPS) revert TotalFeeTooLow();\n        if (_initialJackpotFee + EnhancedDragonMarketAnalyzer.BASE_BURN_BPS > _totalFee) revert FeesExceedTotal();\n\n        // Update fee configuration\n        feeConfig.totalFee = _totalFee;\n        feeConfig.jackpotFee = _initialJackpotFee;\n        feeConfig.liquidityFee = _totalFee - _initialJackpotFee - EnhancedDragonMarketAnalyzer.BASE_BURN_BPS;\n        feeConfig.lastUpdate = block.timestamp;\n\n        // Update oracle addresses\n        chainlinkSUSDFeed = _chainlinkSUSD;\n        bandProtocolFeed = _bandProtocol;\n        api3ProxyFeed = _api3Proxy;\n        pythNetworkFeed = _pythNetwork;\n\n        // Initialize price tracking\n        _updatePriceFromOracles();\n\n        initialized = true;\n        emit Initialized(_totalFee, _initialJackpotFee, operationMode);\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // CORE MARKET MANAGEMENT FUNCTIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Update market data and fees atomically\n     * @return success Whether the update was successful\n     * @return newPrice Updated price\n     * @return newJackpotFee Updated jackpot fee\n     */\n    function updateMarketDataAndFees() external onlyOwner returns (\n        bool success,\n        int256 newPrice,\n        uint256 newJackpotFee\n    ) {\n        // Update price from oracles\n        (bool priceSuccess, int256 aggregatedPrice, uint256 oracleCount) = _updatePriceFromOracles();\n        if (!priceSuccess) {\n            return (false, latestPrice, feeConfig.jackpotFee);\n        }\n\n        // Update market conditions based on new price and existing data\n        _updateMarketConditions(aggregatedPrice, oracleCount);\n\n        // Update fees if conditions are met\n        bool feeUpdated = _maybeUpdateFees();\n\n        emit PriceUpdated(aggregatedPrice, block.timestamp, priceDeviation, oracleCount);\n        \n        return (true, aggregatedPrice, feeConfig.jackpotFee);\n    }\n\n    /**\n     * @dev Update jackpot size and trigger fee recalculation if needed\n     */\n    function updateJackpotSize(uint256 _newJackpotSize) external onlyOwner {\n        jackpotSize = _newJackpotSize;\n        emit JackpotSizeUpdated(_newJackpotSize);\n\n        // Update market conditions to reflect new jackpot size\n        _updateMarketConditionsWithJackpot(_newJackpotSize);\n\n        // Consider updating fees\n        _maybeUpdateFees();\n    }\n\n    /**\n     * @dev Add trading volume and update daily metrics\n     */\n    function addVolume(uint256 _volumeAmount) external onlyOwner {\n        cumulativeVolume += _volumeAmount;\n        dailyVolume += _volumeAmount;\n\n        // Check if it's time to reset daily volume\n        if (block.timestamp >= lastVolumeReset + volumeResetInterval) {\n            _resetDailyVolume();\n        }\n\n        // Update market conditions with new volume data\n        _updateMarketConditionsWithVolume();\n\n        // Consider updating fees\n        _maybeUpdateFees();\n    }\n\n    /**\n     * @dev Force update of fee allocation based on current conditions\n     */\n    function updateFees() external onlyOwner {\n        _updateFees();\n    }\n\n    /**\n     * @dev Get current fee percentages\n     */\n    function getFees() external view returns (\n        uint256 _jackpotFee,\n        uint256 _liquidityFee,\n        uint256 _burnFee,\n        uint256 _totalFee\n    ) {\n        return (\n            feeConfig.jackpotFee,\n            feeConfig.liquidityFee,\n            feeConfig.burnFee,\n            feeConfig.totalFee\n        );\n    }\n\n    /**\n     * @dev Get comprehensive market data\n     */\n    function getMarketData() external view returns (\n        int256 price,\n        uint256 marketScore,\n        uint256 liquidityScore,\n        uint256 volatilityScore,\n        uint256 volumeScore,\n        uint256 lastUpdate\n    ) {\n        if (circuitBreakerActive) revert CircuitBreakerActive();\n        \n        int256 currentPrice = latestPrice;\n        \n        // Include cross-chain price if available\n        if (crossChainEnabled && activeNetworks.length > 0) {\n            currentPrice = _getAggregatedCrossChainPrice();\n        }\n        \n        return (\n            currentPrice,\n            marketConditions.score,\n            marketConditions.liquidityScore,\n            marketConditions.volatilityScore,\n            marketConditions.volumeScore,\n            marketConditions.lastUpdate\n        );\n    }\n\n    /**\n     * @dev Get volume data\n     */\n    function getVolumeData() external view returns (\n        uint256 totalVolume,\n        uint256 currentDailyVolume,\n        uint256 lastReset\n    ) {\n        return (cumulativeVolume, dailyVolume, lastVolumeReset);\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // ORACLE FUNCTIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Get latest price data (Oracle interface compatibility)\n     */\n    function getLatestPrice() external view returns (int256 price, uint256 timestamp) {\n        if (circuitBreakerActive) revert CircuitBreakerActive();\n        if (block.timestamp - lastPriceUpdate > maxUpdateInterval) revert PriceDataStale();\n        \n        return (latestPrice, lastPriceUpdate);\n    }\n\n    /**\n     * @dev Get aggregated price data (Oracle interface compatibility)\n     */\n    function getAggregatedPrice() external view returns (int256 price, bool success, uint256 timestamp) {\n        if (circuitBreakerActive) {\n            return (0, false, lastPriceUpdate);\n        }\n        \n        bool dataFresh = (block.timestamp - lastPriceUpdate) <= maxUpdateInterval;\n        int256 currentPrice = latestPrice;\n        \n        if (crossChainEnabled && activeNetworks.length > 0) {\n            currentPrice = _getAggregatedCrossChainPrice();\n        }\n        \n        return (currentPrice, dataFresh, lastPriceUpdate);\n    }\n\n    /**\n     * @dev Get market conditions score (Oracle interface compatibility)\n     */\n    function getMarketConditions() external view returns (uint256 score) {\n        return marketConditions.score;\n    }\n\n    /**\n     * @dev Check if oracle data is fresh (Oracle interface compatibility)\n     */\n    function isFresh() external view returns (bool fresh) {\n        return (block.timestamp - lastPriceUpdate) <= maxUpdateInterval && !circuitBreakerActive;\n    }\n\n    /**\n     * @dev Get total swap volume (Oracle interface compatibility)\n     */\n    function totalSwapVolume() external view returns (uint256 volume) {\n        return cumulativeVolume;\n    }\n\n    /**\n     * @dev Get swap count (Oracle interface compatibility)\n     */\n    function swapCount() external view returns (uint256 count) {\n        // Estimate based on volume (simplified)\n        return cumulativeVolume > 0 ? cumulativeVolume / 1e18 : 0;\n    }\n\n    /**\n     * @dev Get liquidity data (Oracle interface compatibility)\n     */\n    function getLiquidityData() external view returns (\n        uint256 totalTVL,\n        uint256 mainPoolTVL,\n        uint256 dragonBalance,\n        uint256 wrappedNativeBalance,\n        uint256 lastUpdate\n    ) {\n        uint256 baseLiquidity = marketConditions.liquidityScore * 1e18;\n        \n        // Include cross-chain liquidity if available\n        if (crossChainEnabled && crossChainData.totalValue > 0) {\n            baseLiquidity += crossChainData.totalValue;\n        }\n        \n        return (\n            baseLiquidity,\n            baseLiquidity / 2,\n            baseLiquidity / 4,\n            baseLiquidity / 4,\n            marketConditions.lastUpdate\n        );\n    }\n\n    /**\n     * @dev Get liquidity depth ratio (Oracle interface compatibility)\n     */\n    function getLiquidityDepthRatio() external view returns (uint256 ratio) {\n        uint256 score = marketConditions.liquidityScore;\n        if (score == 0) return 0;\n        \n        uint256 baseRatio;\n        if (score >= 8000) {\n            baseRatio = 8000 + ((score - 8000) * 2000) / 2000;\n        } else if (score >= 5000) {\n            baseRatio = 5000 + ((score - 5000) * 3000) / 3000;\n        } else {\n            baseRatio = (score * 5000) / 5000;\n        }\n        \n        // Boost if cross-chain liquidity available\n        if (crossChainEnabled && crossChainData.totalValue > 0) {\n            baseRatio = (baseRatio * 110) / 100;\n            if (baseRatio > 10000) baseRatio = 10000;\n        }\n        \n        return baseRatio;\n    }\n\n    /**\n     * @dev Calculate market impact (Oracle interface compatibility)\n     */\n    function calculateMarketImpact(uint256 tradeSize) external view returns (uint256 impact) {\n        if (tradeSize == 0 || marketConditions.liquidityScore == 0) return 0;\n        \n        uint256 totalSupply = 6942000 * 10 ** 18;\n        uint256 tradeRatio = (tradeSize * 10000) / totalSupply;\n        \n        uint256 liquidityAdjustment = 10000 - marketConditions.liquidityScore;\n        impact = (tradeRatio * (10000 + liquidityAdjustment)) / 10000;\n        \n        // Reduce impact if cross-chain liquidity available\n        if (crossChainEnabled && crossChainData.totalValue > 0) {\n            impact = (impact * 80) / 100;\n        }\n        \n        return impact > 5000 ? 5000 : impact;\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // CROSS-CHAIN FUNCTIONS (OPTIONAL)\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Add supported network for cross-chain operations\n     */\n    function addSupportedNetwork(uint32 eid, string calldata name) external onlyOwner {\n        if (!crossChainEnabled) revert CrossChainNotEnabled();\n        require(!supportedNetworks[eid], 'Network already supported');\n        \n        supportedNetworks[eid] = true;\n        networkNames[eid] = name;\n        activeNetworks.push(eid);\n        \n        emit NetworkAdded(eid, name);\n    }\n\n    /**\n     * @dev Remove supported network\n     */\n    function removeSupportedNetwork(uint32 eid) external onlyOwner {\n        require(supportedNetworks[eid], 'Network not supported');\n        \n        supportedNetworks[eid] = false;\n        delete networkNames[eid];\n        \n        // Remove from active networks array\n        for (uint256 i = 0; i < activeNetworks.length; i++) {\n            if (activeNetworks[i] == eid) {\n                activeNetworks[i] = activeNetworks[activeNetworks.length - 1];\n                activeNetworks.pop();\n                break;\n            }\n        }\n        \n        emit NetworkRemoved(eid);\n    }\n\n    /**\n     * @dev Get cross-chain market data summary\n     */\n    function getCrossChainMarketData() external view returns (\n        int256 aggregatedPrice,\n        uint256 totalJackpot,\n        uint256 totalLiquidity,\n        uint256 networkCount,\n        uint256 lastUpdate\n    ) {\n        if (!crossChainEnabled) {\n            return (latestPrice, jackpotSize, marketConditions.liquidityScore * 1e18, 1, lastPriceUpdate);\n        }\n        \n        return (\n            _getAggregatedCrossChainPrice(),\n            _getTotalCrossChainJackpot(),\n            crossChainData.totalValue,\n            activeNetworks.length,\n            crossChainData.lastUpdate\n        );\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // LAYERZERO V2 MESSAGE HANDLING\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev LayerZero V2 receive function\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable override {\n        if (!crossChainEnabled) revert CrossChainNotEnabled();\n        require(msg.sender == address(endpoint), 'Only endpoint');\n        require(supportedNetworks[_origin.srcEid], 'Unsupported network');\n\n        (uint32 channel, bytes memory data) = abi.decode(_message, (uint32, bytes));\n        \n        channelData[channel][_origin.srcEid] = data;\n        channelLastUpdated[channel] = block.timestamp;\n        \n        _processCrossChainData(channel, _origin.srcEid, data);\n        \n        emit CrossChainDataReceived(_origin.srcEid, channel, data, block.timestamp);\n    }\n\n    /**\n     * @dev LayerZero V2 interface requirement\n     */\n    function allowInitializePath(Origin calldata _origin) external view override returns (bool) {\n        return crossChainEnabled && supportedNetworks[_origin.srcEid];\n    }\n\n    /**\n     * @dev LayerZero V2 interface requirement\n     */\n    function nextNonce(uint32 _eid, bytes32 _sender) external view override returns (uint64) {\n        return 1; // Simplified nonce tracking\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // INTERNAL FUNCTIONS - ORACLE OPERATIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Update price from multiple oracle sources\n     */\n    function _updatePriceFromOracles() internal returns (bool success, int256 aggregatedPrice, uint256 oracleCount) {\n        if (circuitBreakerActive) {\n            return (false, latestPrice, 0);\n        }\n        \n        uint256 totalWeight = 0;\n        uint256 weightedSum = 0;\n        uint256 validOracles = 0;\n        \n        // Get prices from all configured oracles\n        (int256 chainlinkPrice, bool chainlinkValid) = _getChainlinkPrice();\n        if (chainlinkValid) {\n            weightedSum += uint256(chainlinkPrice) * chainlinkWeight;\n            totalWeight += chainlinkWeight;\n            validOracles++;\n            oracleCache[\"chainlink\"] = OracleData(chainlinkPrice, block.timestamp, true);\n        }\n        \n        (int256 bandPrice, bool bandValid) = _getBandProtocolPrice();\n        if (bandValid) {\n            weightedSum += uint256(bandPrice) * bandWeight;\n            totalWeight += bandWeight;\n            validOracles++;\n            oracleCache[\"band\"] = OracleData(bandPrice, block.timestamp, true);\n        }\n        \n        (int256 api3Price, bool api3Valid) = _getAPI3Price();\n        if (api3Valid) {\n            weightedSum += uint256(api3Price) * api3Weight;\n            totalWeight += api3Weight;\n            validOracles++;\n            oracleCache[\"api3\"] = OracleData(api3Price, block.timestamp, true);\n        }\n        \n        if (validOracles == 0) {\n            return (false, latestPrice, 0);\n        }\n        \n        // Calculate weighted average\n        aggregatedPrice = int256(weightedSum / totalWeight);\n        \n        // Validate price bounds\n        if (aggregatedPrice < minPrice || aggregatedPrice > maxPrice) {\n            return (false, latestPrice, validOracles);\n        }\n        \n        // Check for excessive deviation\n        if (latestPrice > 0) {\n            uint256 deviation = uint256((aggregatedPrice > latestPrice ? \n                aggregatedPrice - latestPrice : latestPrice - aggregatedPrice) * 10000) / uint256(latestPrice);\n            \n            if (deviation > maxPriceDeviation) {\n                circuitBreakerActive = true;\n                emit CircuitBreakerTriggered(\"Excessive price deviation\", aggregatedPrice, deviation);\n                return (false, latestPrice, validOracles);\n            }\n            \n            priceDeviation = deviation;\n        }\n        \n        // Update price state\n        latestPrice = aggregatedPrice;\n        lastPriceUpdate = block.timestamp;\n        \n        return (true, aggregatedPrice, validOracles);\n    }\n\n    /**\n     * @dev Get price from Chainlink oracle\n     */\n    function _getChainlinkPrice() internal view returns (int256 price, bool isValid) {\n        if (chainlinkSUSDFeed == address(0)) return (0, false);\n        \n        try AggregatorV3Interface(chainlinkSUSDFeed).latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) {\n            if (answer <= 0 || updatedAt == 0) return (0, false);\n            if (block.timestamp - updatedAt > 3600) return (0, false);\n            \n            uint8 decimals = AggregatorV3Interface(chainlinkSUSDFeed).decimals();\n            if (decimals < 18) {\n                price = answer * int256(10 ** (18 - decimals));\n            } else if (decimals > 18) {\n                price = answer / int256(10 ** (decimals - 18));\n            } else {\n                price = answer;\n            }\n            \n            return (price, true);\n        } catch {\n            return (0, false);\n        }\n    }\n\n    /**\n     * @dev Get price from Band Protocol oracle\n     */\n    function _getBandProtocolPrice() internal view returns (int256 price, bool isValid) {\n        if (bandProtocolFeed == address(0)) return (0, false);\n        \n        try IStdReference(bandProtocolFeed).getReferenceData(\"S\", \"USD\") returns (\n            IStdReference.ReferenceData memory data\n        ) {\n            if (data.rate == 0) return (0, false);\n            price = int256(data.rate);\n            return (price, true);\n        } catch {\n            return (0, false);\n        }\n    }\n\n    /**\n     * @dev Get price from API3 oracle\n     */\n    function _getAPI3Price() internal view returns (int256 price, bool isValid) {\n        if (api3ProxyFeed == address(0)) return (0, false);\n        \n        try IApi3Proxy(api3ProxyFeed).read() returns (int224 value, uint256 timestamp) {\n            if (value <= 0 || timestamp == 0) return (0, false);\n            if (block.timestamp - timestamp > 3600) return (0, false);\n            \n            price = int256(value);\n            return (price, true);\n        } catch {\n            return (0, false);\n        }\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // INTERNAL FUNCTIONS - MARKET CONDITIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Update market conditions based on current data\n     */\n    function _updateMarketConditions(int256 newPrice, uint256 oracleCount) internal {\n        // Calculate price change percentage\n        int256 priceChangePercent = 0;\n        if (latestPrice > 0) {\n            priceChangePercent = ((newPrice - latestPrice) * 100) / latestPrice;\n        }\n        \n        // Calculate market condition score using EnhancedDragonMarketAnalyzer\n        uint256 newScore = EnhancedDragonMarketAnalyzer.calculateMarketConditionScore(\n            marketConditions.liquidityScore * 1e18, // Convert to actual liquidity value\n            dailyVolume,\n            priceChangePercent,\n            0, // stakers - could be enhanced with veDRAGON integration\n            jackpotSize,\n            0  // daysSinceLastJackpot - could be enhanced with jackpot history\n        );\n        \n        // Update market conditions\n        marketConditions.score = newScore;\n        marketConditions.lastUpdate = block.timestamp;\n        \n        // Update component scores based on oracle diversity\n        _updateComponentScores(oracleCount);\n        \n        emit MarketConditionsUpdated(\n            marketConditions.score,\n            marketConditions.liquidityScore,\n            marketConditions.volatilityScore,\n            marketConditions.volumeScore\n        );\n    }\n\n    /**\n     * @dev Update market conditions with jackpot data\n     */\n    function _updateMarketConditionsWithJackpot(uint256 newJackpotSize) internal {\n        // Recalculate market score with new jackpot size\n        uint256 newScore = EnhancedDragonMarketAnalyzer.calculateMarketConditionScore(\n            marketConditions.liquidityScore * 1e18,\n            dailyVolume,\n            0, // No price change for jackpot-only update\n            0,\n            newJackpotSize,\n            0\n        );\n        \n        marketConditions.score = newScore;\n        marketConditions.lastUpdate = block.timestamp;\n        \n        emit MarketConditionsUpdated(\n            marketConditions.score,\n            marketConditions.liquidityScore,\n            marketConditions.volatilityScore,\n            marketConditions.volumeScore\n        );\n    }\n\n    /**\n     * @dev Update market conditions with volume data\n     */\n    function _updateMarketConditionsWithVolume() internal {\n        // Update volume score based on recent activity (simplified calculation)\n        uint256 volumeScore;\n        if (marketConditions.liquidityScore > 0) {\n            uint256 turnoverRatio = (dailyVolume * 10000) / (marketConditions.liquidityScore * 1e18);\n            if (turnoverRatio > 5000) { // >50% turnover\n                volumeScore = 2000;\n            } else if (turnoverRatio > 1000) { // >10% turnover\n                volumeScore = 1000 + (1000 * (turnoverRatio - 1000)) / 4000;\n            } else {\n                volumeScore = (1000 * turnoverRatio) / 1000;\n            }\n        } else {\n            volumeScore = 0;\n        }\n        \n        marketConditions.volumeScore = volumeScore;\n        \n        // Recalculate overall score\n        marketConditions.score = (\n            marketConditions.liquidityScore * 30 +\n            volumeScore * 30 +\n            marketConditions.volatilityScore * 40\n        ) / 100;\n        \n        marketConditions.lastUpdate = block.timestamp;\n    }\n\n    /**\n     * @dev Update component scores based on oracle diversity\n     */\n    function _updateComponentScores(uint256 oracleCount) internal {\n        // Base scores start at current values\n        uint256 baseScore = marketConditions.score;\n        \n        // Oracle diversity affects liquidity score\n        uint256 diversityBonus = oracleCount * 500; // 5% per oracle\n        if (diversityBonus > 2000) diversityBonus = 2000; // Cap at 20%\n        \n        marketConditions.liquidityScore = baseScore + diversityBonus;\n        if (marketConditions.liquidityScore > 10000) {\n            marketConditions.liquidityScore = 10000;\n        }\n        \n        // Volatility score based on price deviation\n        if (priceDeviation > 500) { // > 5%\n            marketConditions.volatilityScore = baseScore + 1000; // High volatility\n        } else if (priceDeviation > 200) { // > 2%\n            marketConditions.volatilityScore = baseScore + 500; // Medium volatility\n        } else {\n            marketConditions.volatilityScore = baseScore; // Low volatility\n        }\n        \n        if (marketConditions.volatilityScore > 10000) {\n            marketConditions.volatilityScore = 10000;\n        }\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // INTERNAL FUNCTIONS - FEE MANAGEMENT\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Update fees if conditions are met\n     */\n    function _maybeUpdateFees() internal returns (bool updated) {\n        if (!adaptiveFeesEnabled) return false;\n        \n        // Check if enough time has passed since last update\n        if (block.timestamp >= feeConfig.lastUpdate + feeUpdateInterval) {\n            _updateFees();\n            return true;\n        }\n        \n        return false;\n    }\n\n    /**\n     * @dev Update fee allocation based on current conditions\n     */\n    function _updateFees() internal {\n        if (!adaptiveFeesEnabled) return;\n\n        // Calculate optimal fee allocation using EnhancedDragonMarketAnalyzer\n        EnhancedDragonMarketAnalyzer.FeeAllocation memory allocation = EnhancedDragonMarketAnalyzer.calculateOptimalFeeAllocation(\n            jackpotSize,\n            dailyVolume,\n            feeConfig.totalFee,\n            marketConditions.score\n        );\n\n        // Update fee configuration\n        feeConfig.jackpotFee = allocation.jackpotFeeBps;\n        feeConfig.liquidityFee = allocation.liquidityFeeBps;\n        feeConfig.lastUpdate = block.timestamp;\n\n        emit FeeUpdated(\n            feeConfig.jackpotFee,\n            feeConfig.liquidityFee,\n            feeConfig.burnFee,\n            feeConfig.totalFee\n        );\n    }\n\n    /**\n     * @dev Reset daily volume counter\n     */\n    function _resetDailyVolume() internal {\n        emit VolumeUpdated(dailyVolume, cumulativeVolume);\n        \n        // Update volume snapshot for cross-chain calculations\n        lastVolumeSnapshot = cumulativeVolume;\n        lastVolumeReset = block.timestamp;\n        dailyVolume = 0;\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // INTERNAL FUNCTIONS - CROSS-CHAIN\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Process cross-chain data\n     */\n    function _processCrossChainData(uint32 channel, uint32 srcEid, bytes memory data) internal {\n        if (channel == PRICE_CHANNEL) {\n            int256 price = abi.decode(data, (int256));\n            crossChainData.prices[srcEid] = price;\n            emit CrossChainPriceUpdated(srcEid, price, block.timestamp);\n        } else if (channel == JACKPOT_CHANNEL) {\n            uint256 jackpot = abi.decode(data, (uint256));\n            crossChainData.jackpots[srcEid] = jackpot;\n        } else if (channel == LIQUIDITY_CHANNEL) {\n            uint256 liquidity = abi.decode(data, (uint256));\n            crossChainData.liquidity[srcEid] = liquidity;\n        }\n        \n        crossChainData.lastUpdate = block.timestamp;\n        _updateCrossChainTotals();\n    }\n\n    /**\n     * @dev Update cross-chain totals\n     */\n    function _updateCrossChainTotals() internal {\n        uint256 totalValue = 0;\n        \n        for (uint256 i = 0; i < activeNetworks.length; i++) {\n            uint32 eid = activeNetworks[i];\n            totalValue += crossChainData.liquidity[eid];\n        }\n        \n        crossChainData.totalValue = totalValue;\n    }\n\n    /**\n     * @dev Get aggregated cross-chain price\n     */\n    function _getAggregatedCrossChainPrice() internal view returns (int256) {\n        if (activeNetworks.length == 0) return latestPrice;\n        \n        int256 totalPrice = latestPrice; // Include local price\n        uint256 validPrices = 1;\n        \n        for (uint256 i = 0; i < activeNetworks.length; i++) {\n            uint32 eid = activeNetworks[i];\n            if (crossChainData.prices[eid] > 0) {\n                totalPrice += crossChainData.prices[eid];\n                validPrices++;\n            }\n        }\n        \n        return validPrices > 0 ? totalPrice / int256(validPrices) : latestPrice;\n    }\n\n    /**\n     * @dev Get total cross-chain jackpot\n     */\n    function _getTotalCrossChainJackpot() internal view returns (uint256) {\n        uint256 total = jackpotSize; // Include local jackpot\n        \n        for (uint256 i = 0; i < activeNetworks.length; i++) {\n            total += crossChainData.jackpots[activeNetworks[i]];\n        }\n        \n        return total;\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // ADMIN FUNCTIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Set operation mode\n     */\n    function setOperationMode(OperationMode _newMode) external onlyOwner {\n        if (_newMode == operationMode) return;\n        \n        OperationMode oldMode = operationMode;\n        operationMode = _newMode;\n        \n        // Update cross-chain enabled status\n        if (_newMode == OperationMode.LOCAL_ONLY) {\n            crossChainEnabled = false;\n        } else if (address(endpoint) != address(0)) {\n            crossChainEnabled = true;\n        }\n        \n        emit OperationModeChanged(oldMode, _newMode);\n    }\n\n    /**\n     * @dev Update total fee\n     */\n    function updateTotalFee(uint256 _totalFee) external onlyOwner {\n        if (_totalFee < EnhancedDragonMarketAnalyzer.BASE_BURN_BPS) revert TotalFeeTooLow();\n        if (_totalFee > EnhancedDragonMarketAnalyzer.MAX_TOTAL_FEE_BPS) revert FeeTooHigh();\n\n        feeConfig.totalFee = _totalFee;\n        _updateFees();\n    }\n\n    /**\n     * @dev Set fee update interval\n     */\n    function setFeeUpdateInterval(uint256 _intervalSeconds) external onlyOwner {\n        if (_intervalSeconds == 0) revert IntervalMustBeGreaterThanZero();\n        feeUpdateInterval = _intervalSeconds;\n    }\n\n    /**\n     * @dev Toggle adaptive fees\n     */\n    function setAdaptiveFeesEnabled(bool _enabled) external onlyOwner {\n        adaptiveFeesEnabled = _enabled;\n        emit AdaptiveFeesToggled(_enabled);\n    }\n\n    /**\n     * @dev Set oracle addresses\n     */\n    function setOracleAddresses(\n        address _chainlink,\n        address _band,\n        address _api3,\n        address _pyth\n    ) external onlyOwner {\n        chainlinkSUSDFeed = _chainlink;\n        bandProtocolFeed = _band;\n        api3ProxyFeed = _api3;\n        pythNetworkFeed = _pyth;\n        \n        emit OracleAddressUpdated(\"chainlink\", _chainlink);\n        emit OracleAddressUpdated(\"band\", _band);\n        emit OracleAddressUpdated(\"api3\", _api3);\n        emit OracleAddressUpdated(\"pyth\", _pyth);\n    }\n\n    /**\n     * @dev Set oracle source weights\n     */\n    function setSourceWeights(\n        uint256 _chainlinkWeight,\n        uint256 _api3Weight,\n        uint256 _pythWeight,\n        uint256 _bandWeight\n    ) external onlyOwner {\n        require(_chainlinkWeight + _api3Weight + _pythWeight + _bandWeight == 10000, 'Weights must sum to 10000');\n\n        chainlinkWeight = _chainlinkWeight;\n        api3Weight = _api3Weight;\n        pythWeight = _pythWeight;\n        bandWeight = _bandWeight;\n\n        emit SourceWeightsUpdated(_chainlinkWeight, _api3Weight, _pythWeight, _bandWeight);\n    }\n\n    /**\n     * @dev Reset circuit breaker\n     */\n    function resetCircuitBreaker() external onlyOwner {\n        circuitBreakerActive = false;\n        emit CircuitBreakerReset(msg.sender);\n    }\n\n    /**\n     * @dev Check Sonic FeeM status\n     */\n    function checkFeeMStatus() external view returns (bool isRegistered) {\n    }\n\n    /**\n     * @dev Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n\n"
    },
    "contracts/core/oracles/OmniDragonRandomnessProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\";\n\nimport { IChainlinkVRFIntegratorV2_5 } from \"../../interfaces/external/chainlink/IChainlinkVRFIntegratorV2_5.sol\";\n\n// ============ INTERFACES ============\n\ninterface IRandomWordsCallbackV2_5 {\n    function receiveRandomWords(uint256[] memory randomWords, uint64 sequence) external;\n}\n\ninterface IRandomnessRequester {\n    function receiveRandomness(uint256 requestId, uint256 randomValue) external;\n}\n\n/**\n * @title OmniDragonRandomnessProvider\n * @dev Advanced randomness provider that wraps ChainlinkVRFIntegratorV2_5 with full cross-chain VRF integration\n * \n * FEATURES:\n * - Full Chainlink VRF integration via ChainlinkVRFIntegratorV2_5 (Sonic â†’ Arbitrum â†’ Chainlink)\n * - Authorization system for consumers\n * - Request mapping and callback handling\n * - Fallback pseudo-randomness for instant decisions\n * - Fee management and withdrawal\n * - Comprehensive event logging\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */ \ncontract OmniDragonRandomnessProvider is Ownable, ReentrancyGuard, IRandomWordsCallbackV2_5 {\n\n    // ============ CONSTANTS ============\n    \n    uint32 constant ARBITRUM_EID = 30110; // Arbitrum's LayerZero V2 Endpoint ID\n\n    // ============ STATE VARIABLES ============\n\n    struct RandomnessRequest {\n        address requester;\n        uint64 timestamp;\n        bool fulfilled;\n        uint256 randomValue;\n        uint32 requestType;\n        uint64 vrfSequence; // Maps to ChainlinkVRFIntegrator sequence\n    }\n\n    enum RequestType {\n        POOL,           // Pool-based randomness (pseudo for now)\n        CHAINLINK_VRF,  // Cross-chain Chainlink VRF\n        INSTANT         // Instant pseudo-randomness\n    }\n\n    mapping(uint256 => RandomnessRequest) public randomnessRequests;\n    mapping(uint64 => uint256) public vrfSequenceToRequestId; // VRF sequence â†’ randomness ID\n    uint256 public nextRandomnessId;\n    \n    // Chainlink VRF integration\n    IChainlinkVRFIntegratorV2_5 public chainlinkVRFIntegrator;\n    bool public chainlinkVRFEnabled;\n    \n    // Authorization\n    mapping(address => bool) public authorizedConsumers;\n    \n    // Fees and limits\n    uint256 public vrfFee = 0.2 ether;      // Fee for cross-chain VRF (covers LayerZero + Chainlink)\n    uint256 public poolFee = 0.001 ether;   // Fee for pool-based randomness\n    uint256 public instantFee = 0;           // No fee for instant pseudo-randomness\n    uint256 public maxPendingRequests = 100; // Prevent spam\n\n    // Statistics\n    uint256 public totalVRFRequests;\n    uint256 public totalPoolRequests;\n    uint256 public totalInstantRequests;\n    uint256 public successfulVRFCallbacks;\n\n    // ============ EVENTS ============\n    \n    event RandomnessRequested(uint256 indexed randomnessId, address indexed requester, RequestType requestType, uint64 vrfSequence);\n    event RandomnessFulfilled(uint256 indexed randomnessId, uint256 randomValue, bool fromVRF);\n    event RandomnessDelivered(uint256 indexed requestId, address indexed requester, uint256 randomValue);\n    event RandomnessDeliveryFailed(uint256 indexed requestId, address indexed requester, string reason);\n    event ChainlinkVRFIntegratorUpdated(address indexed oldIntegrator, address indexed newIntegrator);\n    event VRFCallbackReceived(uint256 indexed randomnessId, uint64 indexed vrfSequence, uint256 randomValue);\n    event ConsumerAuthorized(address indexed consumer, bool authorized);\n    event FeesUpdated(uint256 vrfFee, uint256 poolFee, uint256 instantFee);\n    event EmergencyFallbackUsed(uint256 indexed randomnessId, string reason);\n\n    // ============ CONSTRUCTOR ============\n\n    constructor(address _vrfIntegrator) Ownable(msg.sender) {\n        if (_vrfIntegrator != address(0)) {\n            chainlinkVRFIntegrator = IChainlinkVRFIntegratorV2_5(_vrfIntegrator);\n            chainlinkVRFEnabled = true;\n        } else {\n            chainlinkVRFEnabled = false;\n        }\n        \n        // Register for Sonic FeeM automatically\n    }\n\n    // ============ EXTERNAL FUNCTIONS ============\n\n    /**\n     * @dev Request randomness from pool (uses pseudo-randomness for now)\n     * @return randomnessId The unique identifier for this randomness request\n     */\n    function requestRandomnessFromPool() external payable nonReentrant returns (uint256) {\n        require(msg.value >= poolFee, \"Insufficient fee\");\n        require(_getPendingRequestCount() < maxPendingRequests, \"Too many pending requests\");\n        \n        uint256 randomnessId = nextRandomnessId++;\n        randomnessRequests[randomnessId] = RandomnessRequest({\n            requester: msg.sender,\n            timestamp: uint64(block.timestamp),\n            fulfilled: false,\n            randomValue: 0,\n            requestType: uint32(RequestType.POOL),\n            vrfSequence: 0\n        });\n\n        totalPoolRequests++;\n        emit RandomnessRequested(randomnessId, msg.sender, RequestType.POOL, 0);\n        \n        // Generate strong pseudo-randomness\n        uint256 pseudoRandom = _generatePseudoRandom(randomnessId, msg.sender);\n        \n        // Fulfill immediately\n        randomnessRequests[randomnessId].randomValue = pseudoRandom;\n        randomnessRequests[randomnessId].fulfilled = true;\n        \n        emit RandomnessFulfilled(randomnessId, pseudoRandom, false);\n        _deliverRandomness(randomnessId);\n        \n        return randomnessId;\n    }\n\n    /**\n     * @dev Request randomness from Chainlink VRF via cross-chain integrator\n     * @return randomnessId The unique identifier for this randomness request\n     */\n    function requestRandomnessFromChainlinkVRF() external payable nonReentrant returns (uint256) {\n        require(chainlinkVRFEnabled, \"Chainlink VRF not enabled\");\n        require(address(chainlinkVRFIntegrator) != address(0), \"VRF integrator not set\");\n        require(msg.value >= vrfFee, \"Insufficient fee for VRF\");\n        require(_getPendingRequestCount() < maxPendingRequests, \"Too many pending requests\");\n        \n        uint256 randomnessId = nextRandomnessId++;\n        \n                 // Make the VRF request to the integrator\n         try chainlinkVRFIntegrator.requestRandomWordsSimple{value: msg.value}(ARBITRUM_EID) {\n            \n            // For simplicity, we'll track by request ID instead of VRF sequence for now\n            // The callback will match by finding pending VRF requests\n            randomnessRequests[randomnessId] = RandomnessRequest({\n                requester: msg.sender,\n                timestamp: uint64(block.timestamp),\n                fulfilled: false,\n                randomValue: 0,\n                requestType: uint32(RequestType.CHAINLINK_VRF),\n                vrfSequence: 0 // Will be updated in callback if needed\n            });\n            \n            totalVRFRequests++;\n            emit RandomnessRequested(randomnessId, msg.sender, RequestType.CHAINLINK_VRF, 0);\n            \n        } catch (bytes memory reason) {\n            // If VRF request fails, use fallback pseudo-randomness\n            emit EmergencyFallbackUsed(randomnessId, string(reason));\n            \n            randomnessRequests[randomnessId] = RandomnessRequest({\n                requester: msg.sender,\n                timestamp: uint64(block.timestamp),\n                fulfilled: false,\n                randomValue: 0,\n                requestType: uint32(RequestType.CHAINLINK_VRF),\n                vrfSequence: 0\n            });\n            \n            uint256 fallbackRandom = _generatePseudoRandom(randomnessId, msg.sender);\n            randomnessRequests[randomnessId].randomValue = fallbackRandom;\n            randomnessRequests[randomnessId].fulfilled = true;\n            \n            emit RandomnessFulfilled(randomnessId, fallbackRandom, false);\n            _deliverRandomness(randomnessId);\n        }\n        \n        return randomnessId;\n    }\n\n    /**\n     * @dev Get instant randomness for per-swap lotteries (no fee, pseudo-random)\n     * @param swapper The address of the user making the swap\n     * @param tokenA The first token in the swap\n     * @param tokenB The second token in the swap  \n     * @param amountIn The input amount\n     * @param amountOut The output amount\n     * @return randomness The generated random value\n     */\n    function drawUnpredictableFromPool(\n        address swapper,\n        address tokenA,\n        address tokenB,\n        uint256 amountIn,\n        uint256 amountOut\n    ) external returns (uint256 randomness) {\n        require(authorizedConsumers[msg.sender], \"Not authorized consumer\");\n        \n        // Generate high-quality pseudo-randomness for instant decisions\n        randomness = uint256(keccak256(abi.encodePacked(\n            swapper, tokenA, tokenB, amountIn, amountOut,\n            block.timestamp, block.prevrandao, block.coinbase,\n            tx.gasprice, gasleft(), msg.sender,\n            totalInstantRequests++ // Ensures uniqueness\n        )));\n        \n        return randomness;\n    }\n\n    // ============ VRF CALLBACK ============\n\n    /**\n     * @dev Receives random words from ChainlinkVRFIntegratorV2_5\n     * @param randomWords Array of random words from Chainlink VRF\n     * @param sequence The VRF sequence number from the integrator\n     */\n    function receiveRandomWords(uint256[] memory randomWords, uint64 sequence) external override {\n        require(msg.sender == address(chainlinkVRFIntegrator), \"Only VRF integrator can call\");\n        require(randomWords.length > 0, \"No random words provided\");\n        \n        // Find the corresponding randomness request\n        uint256 randomnessId = vrfSequenceToRequestId[sequence];\n        require(randomnessId != 0 || sequence == 0, \"Unknown VRF sequence\"); // Allow sequence 0 for first request\n        \n        // Handle case where sequence 0 maps to first request\n        if (sequence == 0 && randomnessId == 0) {\n            randomnessId = _findPendingVRFRequest();\n        }\n        \n        if (randomnessId == 0) {\n            // No matching request found, log and return\n            return;\n        }\n        \n        RandomnessRequest storage request = randomnessRequests[randomnessId];\n        \n        // Verify this is a VRF request that hasn't been fulfilled\n        if (request.requestType != uint32(RequestType.CHAINLINK_VRF) || request.fulfilled) {\n            return;\n        }\n        \n        // Store the random value and mark as fulfilled\n        uint256 randomValue = randomWords[0];\n        request.randomValue = randomValue;\n        request.fulfilled = true;\n        \n        // Update statistics\n        successfulVRFCallbacks++;\n        \n        // Clean up the mapping\n        delete vrfSequenceToRequestId[sequence];\n        \n        // Emit events\n        emit VRFCallbackReceived(randomnessId, sequence, randomValue);\n        emit RandomnessFulfilled(randomnessId, randomValue, true);\n        \n        // Deliver the randomness to the requester\n        _deliverRandomness(randomnessId);\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    function setChainlinkVRFIntegrator(address _integrator) external onlyOwner {\n        address oldIntegrator = address(chainlinkVRFIntegrator);\n        chainlinkVRFIntegrator = IChainlinkVRFIntegratorV2_5(_integrator);\n        chainlinkVRFEnabled = _integrator != address(0);\n        \n        emit ChainlinkVRFIntegratorUpdated(oldIntegrator, _integrator);\n    }\n\n    function authorizeConsumer(address consumer, bool authorized) external onlyOwner {\n        authorizedConsumers[consumer] = authorized;\n        emit ConsumerAuthorized(consumer, authorized);\n    }\n\n    function setFees(uint256 _vrfFee, uint256 _poolFee, uint256 _instantFee) external onlyOwner {\n        vrfFee = _vrfFee;\n        poolFee = _poolFee;\n        instantFee = _instantFee;\n        \n        emit FeesUpdated(_vrfFee, _poolFee, _instantFee);\n    }\n\n    function setMaxPendingRequests(uint256 _maxPendingRequests) external onlyOwner {\n        maxPendingRequests = _maxPendingRequests;\n    }\n\n    function withdrawFees() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No fees to withdraw\");\n        \n        payable(owner()).transfer(balance);\n    }\n\n    function emergencyFulfillRequest(uint256 randomnessId, uint256 randomValue) external onlyOwner {\n        RandomnessRequest storage request = randomnessRequests[randomnessId];\n        require(!request.fulfilled, \"Request already fulfilled\");\n        require(request.requester != address(0), \"Request does not exist\");\n        \n        request.randomValue = randomValue;\n        request.fulfilled = true;\n        \n        emit EmergencyFallbackUsed(randomnessId, \"Emergency fulfillment by owner\");\n        emit RandomnessFulfilled(randomnessId, randomValue, false);\n        \n        _deliverRandomness(randomnessId);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    function getRandomnessRequest(uint256 randomnessId) external view returns (\n        address requester,\n        uint64 timestamp,\n        bool fulfilled,\n        uint256 randomValue,\n        uint32 requestType\n    ) {\n        RandomnessRequest memory request = randomnessRequests[randomnessId];\n        return (\n            request.requester,\n            request.timestamp,\n            request.fulfilled,\n            request.randomValue,\n            request.requestType\n        );\n    }\n\n    function getEstimatedFees() external view returns (\n        uint256 poolFeeAmount, \n        uint256 vrfFeeAmount, \n        uint256 instantFeeAmount\n    ) {\n        return (poolFee, vrfFee, instantFee);\n    }\n\n    function getStatistics() external view returns (\n        uint256 totalVRF,\n        uint256 totalPool,\n        uint256 totalInstant,\n        uint256 successfulCallbacks,\n        uint256 pendingRequests\n    ) {\n        return (\n            totalVRFRequests,\n            totalPoolRequests,\n            totalInstantRequests,\n            successfulVRFCallbacks,\n            _getPendingRequestCount()\n        );\n    }\n\n    function isVRFEnabled() external view returns (bool) {\n        return chainlinkVRFEnabled && address(chainlinkVRFIntegrator) != address(0);\n    }\n\n    function checkFeeMStatus() external view returns (bool isRegistered) {\n    }\n\n    // ============ INTERNAL FUNCTIONS ============\n\n    function _deliverRandomness(uint256 randomnessId) internal {\n        RandomnessRequest storage request = randomnessRequests[randomnessId];\n        \n        // Try to deliver randomness to requester if it implements the interface\n        if (request.requester.code.length > 0) {\n            try IRandomnessRequester(request.requester).receiveRandomness(randomnessId, request.randomValue) {\n                emit RandomnessDelivered(randomnessId, request.requester, request.randomValue);\n            } catch Error(string memory reason) {\n                emit RandomnessDeliveryFailed(randomnessId, request.requester, reason);\n            } catch (bytes memory) {\n                emit RandomnessDeliveryFailed(randomnessId, request.requester, \"Low-level delivery failure\");\n            }\n        } else {\n            // For EOA requests, just emit the delivered event\n            emit RandomnessDelivered(randomnessId, request.requester, request.randomValue);\n        }\n    }\n\n    function _generatePseudoRandom(uint256 randomnessId, address requester) internal view returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(\n            block.timestamp,\n            block.prevrandao,\n            block.coinbase,\n            requester,\n            randomnessId,\n            tx.gasprice,\n            gasleft(),\n            address(this).balance\n        )));\n    }\n\n    function _getPendingRequestCount() internal view returns (uint256) {\n        uint256 count = 0;\n        uint256 endId = nextRandomnessId;\n        uint256 startId = endId > 100 ? endId - 100 : 0; // Check last 100 requests\n        \n        for (uint256 i = startId; i < endId; i++) {\n            if (!randomnessRequests[i].fulfilled && randomnessRequests[i].requester != address(0)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    function _findPendingVRFRequest() internal view returns (uint256) {\n        uint256 endId = nextRandomnessId;\n        uint256 startId = endId > 10 ? endId - 10 : 0; // Check last 10 requests\n        \n        for (uint256 i = endId; i > startId; i--) {\n            uint256 requestId = i - 1;\n            RandomnessRequest memory request = randomnessRequests[requestId];\n            \n            if (request.requestType == uint32(RequestType.CHAINLINK_VRF) && \n                !request.fulfilled && \n                request.requester != address(0)) {\n                return requestId;\n            }\n        }\n        \n        return 0;\n    }\n\n    // Required to receive ETH\n    receive() external payable {}\n} "
    },
    "contracts/core/tokens/omniDRAGON.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\";\nimport \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IDragonRevenueDistributor } from \"contracts/interfaces/governance/fees/IDragonRevenueDistributor.sol\";\nimport { IOmniDragonLotteryManager } from \"contracts/interfaces/lottery/IOmniDragonLotteryManager.sol\";\nimport { IDragonJackpotVault } from \"contracts/interfaces/vault/IDragonJackpotVault.sol\";\nimport { IUniswapV2Router02 } from \"contracts/interfaces/external/uniswap/v2/IUniswapV2Router02.sol\";\nimport { ILayerZeroEndpointV2, MessagingParams, MessagingReceipt, MessagingFee, Origin } from \"contracts/interfaces/external/layerzero/ILayerZeroEndpointV2.sol\";\nimport { IomniDRAGON } from \"contracts/interfaces/tokens/IomniDRAGON.sol\";\n\n/**\n * @title omniDRAGON\n * @dev Specialized token with built-in fees, lottery entries, and cross-chain functionality\n *\n * IMPORTANT DRAGON PROJECT RULES:\n * - On all DRAGON swaps:\n *   1. 6.9% goes to jackpot\n *   2. 2.41% goes to veDRAGON fee distributor\n *   3. 0.69% is burned\n *   4. Only buys qualify for lottery entries\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\ncontract omniDRAGON is ERC20, Ownable, ReentrancyGuard, IomniDRAGON {\n    using SafeERC20 for IERC20;\n\n    // ======== STORAGE LAYOUT ========\n    \n    // Slot 1-2: Core addresses\n    address public jackpotVault;\n    address public revenueDistributor;\n    \n    // Slot 3-4: Core addresses continued\n    address public wrappedNativeTokenAddress;\n    address public uniswapRouter;\n    \n    // Slot 5-6: LayerZero and lottery\n    address public lzEndpoint;\n    address public lotteryManager;\n    \n    // Slot 7-8: Emergency and treasury\n    address public emergencyTreasury;\n    address public emergencyPauser;\n\n    // Slot 9: Packed configuration values (256 bits total)\n    struct PackedConfig {\n        uint128 swapThreshold;           // 128 bits\n        uint128 minimumAmountForProcessing; // 128 bits\n    }\n    PackedConfig public config;\n\n    // Slot 10: Packed limits and thresholds\n    struct PackedLimits {\n        uint64 maxSingleTransfer;        // 64 bits - sufficient for token amounts\n        uint64 minSlippageProtectionBps; // 64 bits\n        uint64 maxSlippageProtectionBps; // 64 bits\n        uint64 minSwapDelay;             // 64 bits\n    }\n    PackedLimits public limits;\n\n    // Slot 11: Packed flags and version (256 bits total)\n    struct PackedFlags {\n        bool transfersPaused;            // 1 bit\n        bool feesEnabled;                // 1 bit\n        bool swapEnabled;                // 1 bit\n        bool inSwap;                     // 1 bit\n        bool initialMintingDone;         // 1 bit\n        bool emergencyPaused;            // 1 bit\n        uint8 configurationVersion;      // 8 bits\n        uint240 reserved;                // 240 bits for future flags\n    }\n    PackedFlags public flags;\n\n    // Slot 12: Timelock configuration\n    struct PackedTimelock {\n        uint128 timelockDelay;           // 128 bits\n        uint128 lastSwapTimestamp;       // 128 bits\n    }\n    PackedTimelock public timelock;\n\n    // Fee structures\n    struct Fees {\n        uint256 jackpot;\n        uint256 veDRAGON;\n        uint256 burn;\n        uint256 total;\n    }\n    \n    Fees public buyFees;\n    Fees public sellFees;\n    Fees public transferFees;\n\n    // Constants (no storage cost)\n    uint256 public constant MAX_SUPPLY = 6942000 * 10 ** 18;\n    uint256 public constant INITIAL_SUPPLY = 6942000 * 10 ** 18;\n    uint32 public constant SONIC_EID = 30332;\n    uint32 public constant ARBITRUM_EID = 30110;\n    uint256 public constant MAX_FEE_BASIS_POINTS = 1500;\n    address public constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n    uint256 public constant TIMELOCK_DELAY = 48 hours;\n    uint256 public constant MAX_BATCH_SIZE = 50;\n\n    // Multi-DEX support\n    enum DexType {\n        UNKNOWN,\n        UNISWAP_V2,\n        UNISWAP_V3,\n        BALANCER,\n        CURVE\n    }\n\n    // Mappings (each takes a full slot when first used)\n    mapping(address => bool) public isExcludedFromFees;\n    mapping(address => bool) public isPair;\n    mapping(address => DexType) public pairToDexType;\n    mapping(uint32 => bytes32) public peers; // LayerZero V2 peer management\n    mapping(address => bool) public isPartnerPool;\n    mapping(address => uint256) public partnerPoolIds;\n    mapping(address => bool) public isAuthorizedCaller;\n\n    // Additional configuration\n    uint256 public allowedInitialMintingChainId = 146; // Default to Sonic\n\n    // ======== CUSTOM ERRORS (Gas Optimized) ========\n    error ZeroAddress();\n    error ZeroAmount();\n    error NotAuthorized();\n    error AlreadyConfigured();\n    error MaxSupplyExceeded();\n    error TransfersPaused();\n    error EmergencyPaused();\n    error FeesTooHigh();\n    error InvalidConfiguration();\n    error ExternalContractFailure();\n    error MaxSingleTransferExceeded();\n    error InsufficientBalance();\n    error InvalidEndpoint();\n    error InvalidSource();\n\n    // ======== OPTIMIZED EVENTS ========\n    event ConfigurationUpdated(string indexed component, address indexed newValue);\n    event FeesUpdated(string indexed feeType, uint256 totalFee);\n    event FeeDistributed(address indexed recipient, uint256 amount, string indexed feeType);\n    event TokensBurned(uint256 amount);\n    event CrossChainTransfer(uint32 indexed dstEid, address indexed from, address indexed to, uint256 amount);\n    event LotteryEntry(address indexed user, uint256 amount);\n    event EmergencyAction(string indexed action, address indexed actor);\n    event SwapExecuted(uint256 tokensSwapped, uint256 nativeReceived);\n\n    // ======== MODIFIERS (Optimized) ========\n    modifier lockTheSwap() {\n        flags.inSwap = true;\n        _;\n        flags.inSwap = false;\n    }\n\n    modifier notEmergencyPaused() {\n        if (flags.emergencyPaused) revert EmergencyPaused();\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        if (!isAuthorizedCaller[msg.sender] && msg.sender != owner()) revert NotAuthorized();\n        _;\n    }\n\n    modifier validAddress(address addr) {\n        if (addr == address(0)) revert ZeroAddress();\n        _;\n    }\n\n    modifier nonZeroAmount(uint256 amount) {\n        if (amount == 0) revert ZeroAmount();\n        _;\n    }\n\n    // ======== CONSTRUCTOR ========\n    constructor() ERC20(\"Dragon\", \"DRAGON\") Ownable(msg.sender) {\n        // Initialize fee structures\n        buyFees = Fees({\n            jackpot: 690,   // 6.9%\n            veDRAGON: 241,  // 2.41%\n            burn: 0,       // 0%\n            total: 1000     // 10%\n        });\n\n        sellFees = Fees({\n            jackpot: 690,  // 6.9%\n            veDRAGON: 241,  // 2.41%\n            burn: 0,      // 0%\n            total: 1000     // 10%\n        });\n\n        transferFees = Fees({\n            jackpot: 0,    // 0.00%\n            veDRAGON: 0,   // 0.00%\n            burn: 69,        // 0.69%\n            total: 69      // 0.69%\n        });\n\n        // Initialize packed configuration\n        config = PackedConfig({\n            swapThreshold: 10_000 * 1e18,\n            minimumAmountForProcessing: 100 * 1e18\n        });\n\n        // Initialize packed limits\n        limits = PackedLimits({\n            maxSingleTransfer: 1000000,  // 1M tokens (without decimals to fit in uint64)\n            minSlippageProtectionBps: 500,\n            maxSlippageProtectionBps: 1000,\n            minSwapDelay: 60\n        });\n\n        // Initialize flags\n        flags = PackedFlags({\n            transfersPaused: false,\n            feesEnabled: true,\n            swapEnabled: true,\n            inSwap: false,\n            initialMintingDone: false,\n            emergencyPaused: false,\n            configurationVersion: 0,\n            reserved: 0\n        });\n\n        // Initialize timelock\n        timelock = PackedTimelock({\n            timelockDelay: uint128(TIMELOCK_DELAY),\n            lastSwapTimestamp: 0\n        });\n\n        // Set emergency treasury to owner initially\n        emergencyTreasury = msg.sender;\n        emergencyPauser = msg.sender;\n\n        // Exclude owner from fees\n        isExcludedFromFees[msg.sender] = true;\n        isExcludedFromFees[address(this)] = true;\n    }\n\n    // ======== INTERFACE IMPLEMENTATION (REQUIRED) ========\n\n    /**\n     * @dev Process swap of native tokens ($S) to Dragon tokens and apply fees\n     * @param _user The user who is swapping\n     * @param _nativeAmount The amount of native tokens ($S) being swapped\n     * @return swappableAmount The amount to be used for the actual swap after fees\n     * @return nativeFeeAmount Total native amount that should be converted to fees\n     * @return jackpotFeeAmount Native amount for jackpot (within nativeFeeAmount)\n     * @return veDRAGONFeeAmount Native amount for veDRAGON (within nativeFeeAmount)\n     */\n    function processNativeSwapFees(\n        address _user, \n        uint256 _nativeAmount\n    ) external override onlyAuthorized nonZeroAmount(_nativeAmount) returns (\n        uint256 swappableAmount,\n        uint256 nativeFeeAmount,\n        uint256 jackpotFeeAmount,\n        uint256 veDRAGONFeeAmount\n    ) {\n        // Get current buy fees (since this is a native -> DRAGON swap)\n        Fees memory currentFees = buyFees;\n        \n        // Calculate fee amounts\n        jackpotFeeAmount = (_nativeAmount * currentFees.jackpot) / 10000;\n        veDRAGONFeeAmount = (_nativeAmount * currentFees.veDRAGON) / 10000;\n        nativeFeeAmount = jackpotFeeAmount + veDRAGONFeeAmount;\n        swappableAmount = _nativeAmount - nativeFeeAmount;\n        \n        // Emit event for tracking\n        emit FeeDistributed(_user, nativeFeeAmount, \"NativeSwap\");\n        \n        return (swappableAmount, nativeFeeAmount, jackpotFeeAmount, veDRAGONFeeAmount);\n    }\n\n    /**\n     * @dev Distribute fees to jackpot and veDRAGON without triggering lottery entry\n     * @param jackpotAmount Amount to send to jackpot\n     * @param veDRAGONAmount Amount to send to veDRAGON\n     */\n    function distributeFees(\n        uint256 jackpotAmount, \n        uint256 veDRAGONAmount\n    ) external override onlyAuthorized {\n        if (jackpotAmount > 0 && jackpotVault != address(0)) {\n            _safeTransferNative(jackpotVault, jackpotAmount);\n            emit FeeDistributed(jackpotVault, jackpotAmount, \"Jackpot\");\n        }\n        \n        if (veDRAGONAmount > 0 && revenueDistributor != address(0)) {\n            _safeTransferNative(revenueDistributor, veDRAGONAmount);\n            // Call the proper interface method to notify the distributor\n            try IDragonRevenueDistributor(revenueDistributor).distributeGeneralFees(address(0), veDRAGONAmount) {\n                emit FeeDistributed(revenueDistributor, veDRAGONAmount, \"veDRAGON\");\n            } catch {\n                // Silent failure to prevent transaction reversion - funds already transferred\n                emit FeeDistributed(revenueDistributor, veDRAGONAmount, \"veDRAGON\");\n            }\n        }\n    }\n\n    /**\n     * @dev Get wrapped native token address\n     * @return Address of the wrapped native token (WETH, wS, etc.)\n     */\n    function wrappedNativeToken() external view override returns (address) {\n        return wrappedNativeTokenAddress;\n    }\n\n    // ======== CORE FUNCTIONALITY (Optimized) ========\n\n    /**\n     * @dev Optimized transfer function with reduced gas usage\n     */\n    function transfer(address to, uint256 amount) public override nonReentrant notEmergencyPaused returns (bool) {\n        _optimizedTransfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Optimized transferFrom function\n     */\n    function transferFrom(address from, address to, uint256 amount) public override nonReentrant notEmergencyPaused returns (bool) {\n        _spendAllowance(from, msg.sender, amount);\n        _optimizedTransfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Optimized internal transfer function\n     */\n    function _optimizedTransfer(address from, address to, uint256 amount) internal {\n        // Quick validation\n        if (amount == 0) return;\n        if (amount > uint256(limits.maxSingleTransfer) * 1e18 && from != owner() && to != owner()) {\n            revert MaxSingleTransferExceeded();\n        }\n        if (flags.transfersPaused && !isExcludedFromFees[from]) {\n            revert TransfersPaused();\n        }\n\n        // Skip fees for excluded addresses or during swaps\n        if (isExcludedFromFees[from] || isExcludedFromFees[to] || flags.inSwap) {\n            super._transfer(from, to, amount);\n            return;\n        }\n\n        // Skip processing for small amounts\n        if (amount < config.minimumAmountForProcessing) {\n            super._transfer(from, to, amount);\n            return;\n        }\n\n        // Handle swap if needed\n        _handleSwapIfNeeded(from);\n\n        // Process transfer with fees\n        _processTransferWithFees(from, to, amount);\n    }\n\n    /**\n     * @dev Handle token swap if conditions are met\n     */\n    function _handleSwapIfNeeded(address from) internal {\n        if (!flags.swapEnabled || flags.inSwap || from == owner()) return;\n        \n        uint256 contractBalance = balanceOf(address(this));\n        if (contractBalance >= config.swapThreshold) {\n            // MEV protection\n            if (block.timestamp < timelock.lastSwapTimestamp + limits.minSwapDelay) return;\n            \n            _swapTokensForWrappedNative(config.swapThreshold);\n            timelock.lastSwapTimestamp = uint128(block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Process transfer with fees (optimized)\n     */\n    function _processTransferWithFees(address from, address to, uint256 amount) internal {\n        // Determine transaction type efficiently\n        uint8 transactionType = _getTransactionType(from, to);\n        \n        // Get fees\n        Fees memory currentFees = _getCurrentFees(transactionType);\n        \n        if (!flags.feesEnabled || currentFees.total == 0) {\n            super._transfer(from, to, amount);\n            _postTransferProcessing(to, amount, transactionType);\n            return;\n        }\n        \n        // Calculate and apply fees\n        _applyFeesAndTransfer(from, to, amount, currentFees);\n        \n        // Post-transfer processing\n        _postTransferProcessing(to, amount, transactionType);\n    }\n\n    /**\n     * @dev Get transaction type efficiently\n     */\n    function _getTransactionType(address from, address to) internal view returns (uint8) {\n        bool fromPair = isPair[from] || isPartnerPool[from];\n        bool toPair = isPair[to] || isPartnerPool[to];\n        \n        if (fromPair && !toPair) return 0; // Buy\n        if (!fromPair && toPair) return 1; // Sell\n        return 2; // Transfer\n    }\n\n    /**\n     * @dev Get current fees based on transaction type\n     */\n    function _getCurrentFees(uint8 transactionType) internal view returns (Fees memory) {\n        if (transactionType == 0) {\n            return buyFees;\n        } else if (transactionType == 1) {\n            return sellFees;\n        } else {\n            return transferFees;\n        }\n    }\n\n    /**\n     * @dev Apply fees and transfer (optimized)\n     */\n    function _applyFeesAndTransfer(\n        address from,\n        address to,\n        uint256 amount,\n        Fees memory currentFees\n    ) internal {\n        uint256 burnAmount = (amount * currentFees.burn) / 10000;\n        uint256 jackpotAmount = (amount * currentFees.jackpot) / 10000;\n        uint256 veDRAGONAmount = (amount * currentFees.veDRAGON) / 10000;\n        uint256 totalFeeAmount = burnAmount + jackpotAmount + veDRAGONAmount;\n\n        // Burn tokens\n        if (burnAmount > 0) {\n            super._transfer(from, DEAD_ADDRESS, burnAmount);\n            emit TokensBurned(burnAmount);\n        }\n\n        // Transfer fees to contract\n        uint256 contractFeeAmount = jackpotAmount + veDRAGONAmount;\n        if (contractFeeAmount > 0) {\n            super._transfer(from, address(this), contractFeeAmount);\n        }\n\n        // Transfer remaining to recipient\n        super._transfer(from, to, amount - totalFeeAmount);\n    }\n\n    /**\n     * @dev Post-transfer processing (optimized)\n     */\n    function _postTransferProcessing(address to, uint256 amount, uint8 transactionType) internal {\n        // Only process lottery for buys\n        if (transactionType == 0 && lotteryManager != address(0)) {\n            _tryProcessLotteryEntry(to, amount);\n        }\n    }\n\n    /**\n     * @dev Try to process lottery entry (with gas limit)\n     */\n    function _tryProcessLotteryEntry(address user, uint256 amount) internal {\n        try IOmniDragonLotteryManager(lotteryManager).processEntry(user, amount) {\n            emit LotteryEntry(user, amount);\n        } catch {\n            // Silent failure to prevent transaction reversion\n        }\n    }\n\n    /**\n     * @dev Swap tokens for wrapped native (optimized)\n     */\n    function _swapTokensForWrappedNative(uint256 tokenAmount) internal lockTheSwap {\n        if (uniswapRouter == address(0) || wrappedNativeTokenAddress == address(0)) return;\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = wrappedNativeTokenAddress;\n\n        _approve(address(this), uniswapRouter, tokenAmount);\n\n        try IUniswapV2Router02(uniswapRouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // Accept any amount of wrapped native\n            path,\n            address(this),\n            block.timestamp + 300\n        ) {\n            emit SwapExecuted(tokenAmount, IERC20(wrappedNativeTokenAddress).balanceOf(address(this)));\n        } catch {\n            // Silent failure\n        }\n    }\n\n    /**\n     * @dev Safe transfer of native tokens\n     */\n    function _safeTransferNative(address to, uint256 amount) internal {\n        (bool success, ) = payable(to).call{value: amount}(\"\");\n        if (!success) revert ExternalContractFailure();\n    }\n\n    // ======== CONFIGURATION FUNCTIONS (Optimized) ========\n\n    /**\n     * @dev Set core addresses (batch function for gas efficiency)\n     */\n    function setCoreAddresses(\n        address _jackpotVault,\n        address _revenueDistributor,\n        address _wrappedNativeToken,\n        address _uniswapRouter\n    ) external onlyOwner {\n        if (flags.configurationVersion >= 1) revert AlreadyConfigured();\n        \n        if (_jackpotVault != address(0)) {\n            jackpotVault = _jackpotVault;\n            isExcludedFromFees[_jackpotVault] = true;\n        }\n        \n        if (_revenueDistributor != address(0)) {\n            revenueDistributor = _revenueDistributor;\n            isExcludedFromFees[_revenueDistributor] = true;\n        }\n        \n        if (_wrappedNativeToken != address(0)) {\n            wrappedNativeTokenAddress = _wrappedNativeToken;\n            isExcludedFromFees[_wrappedNativeToken] = true;\n        }\n        \n        if (_uniswapRouter != address(0)) {\n            uniswapRouter = _uniswapRouter;\n            isExcludedFromFees[_uniswapRouter] = true;\n        }\n        \n        emit ConfigurationUpdated(\"CoreAddresses\", address(0));\n    }\n\n    /**\n     * @dev Set LayerZero configuration\n     */\n    function setLayerZeroConfig(address _lzEndpoint) external onlyOwner validAddress(_lzEndpoint) {\n        if (flags.configurationVersion >= 1) revert AlreadyConfigured();\n        lzEndpoint = _lzEndpoint;\n        emit ConfigurationUpdated(\"LayerZero\", _lzEndpoint);\n    }\n\n    /**\n     * @dev Add liquidity pair\n     */\n    function addPair(address pair, DexType dexType) external onlyOwner validAddress(pair) {\n        isPair[pair] = true;\n        pairToDexType[pair] = dexType;\n        emit ConfigurationUpdated(\"Pair\", pair);\n    }\n\n    /**\n     * @dev Set fees (optimized)\n     */\n    function setFees(\n        uint256[3] calldata buyFeesBps,    // [jackpot, veDRAGON, burn]\n        uint256[3] calldata sellFeesBps,   // [jackpot, veDRAGON, burn]\n        uint256[3] calldata transferFeesBps // [jackpot, veDRAGON, burn]\n    ) external onlyOwner {\n        _validateAndSetFees(buyFeesBps, \"Buy\");\n        _validateAndSetFees(sellFeesBps, \"Sell\");\n        _validateAndSetFees(transferFeesBps, \"Transfer\");\n    }\n\n    /**\n     * @dev Validate and set fees\n     */\n    function _validateAndSetFees(uint256[3] calldata feesBps, string memory feeType) internal {\n        uint256 total = feesBps[0] + feesBps[1] + feesBps[2];\n        if (total > MAX_FEE_BASIS_POINTS) revert FeesTooHigh();\n        \n        if (keccak256(bytes(feeType)) == keccak256(bytes(\"Buy\"))) {\n            buyFees = Fees(feesBps[0], feesBps[1], feesBps[2], total);\n        } else if (keccak256(bytes(feeType)) == keccak256(bytes(\"Sell\"))) {\n            sellFees = Fees(feesBps[0], feesBps[1], feesBps[2], total);\n        } else {\n            transferFees = Fees(feesBps[0], feesBps[1], feesBps[2], total);\n        }\n        \n        emit FeesUpdated(feeType, total);\n    }\n\n    /**\n     * @dev Set configuration parameters\n     */\n    function setConfigParameters(\n        uint128 _swapThreshold,\n        uint128 _minimumAmountForProcessing,\n        uint64 _maxSingleTransfer,\n        uint64 _minSwapDelay\n    ) external onlyOwner {\n        config.swapThreshold = _swapThreshold;\n        config.minimumAmountForProcessing = _minimumAmountForProcessing;\n        limits.maxSingleTransfer = _maxSingleTransfer;\n        limits.minSwapDelay = _minSwapDelay;\n        \n        emit ConfigurationUpdated(\"Parameters\", address(0));\n    }\n\n    /**\n     * @dev Toggle flags\n     */\n    function setFlags(\n        bool _feesEnabled,\n        bool _swapEnabled,\n        bool _transfersPaused\n    ) external onlyOwner {\n        flags.feesEnabled = _feesEnabled;\n        flags.swapEnabled = _swapEnabled;\n        flags.transfersPaused = _transfersPaused;\n        \n        emit ConfigurationUpdated(\"Flags\", address(0));\n    }\n\n    /**\n     * @dev Set authorized caller\n     */\n    function setAuthorizedCaller(address caller, bool authorized) external onlyOwner {\n        isAuthorizedCaller[caller] = authorized;\n        emit ConfigurationUpdated(\"AuthorizedCaller\", caller);\n    }\n\n    /**\n     * @dev Set excluded from fees\n     */\n    function setExcludedFromFees(address account, bool excluded) external onlyOwner {\n        isExcludedFromFees[account] = excluded;\n        emit ConfigurationUpdated(\"ExcludedFromFees\", account);\n    }\n\n    /**\n     * @dev Mark configuration as complete\n     */\n    function markConfigurationComplete(uint8 version) external onlyOwner {\n        flags.configurationVersion = version;\n        emit ConfigurationUpdated(\"Version\", address(uint160(version)));\n    }\n\n    // ======== LAYERZERO V2 FUNCTIONS (Optimized) ========\n\n    /**\n     * @dev Set peer for LayerZero\n     */\n    function setPeer(uint32 eid, bytes32 peer) external onlyOwner {\n        peers[eid] = peer;\n        emit ConfigurationUpdated(\"Peer\", address(uint160(uint256(peer))));\n    }\n\n    /**\n     * @dev Send tokens cross-chain\n     */\n    function send(\n        uint32 dstEid,\n        bytes32 toAddress,\n        uint256 amount,\n        bytes calldata options,\n        MessagingFee calldata fee\n    ) external payable nonReentrant {\n        if (peers[dstEid] == bytes32(0)) revert InvalidEndpoint();\n        \n        // Debit tokens\n        _transfer(msg.sender, DEAD_ADDRESS, amount);\n        \n        // Send via LayerZero\n        bytes memory payload = abi.encode(toAddress, amount);\n        ILayerZeroEndpointV2(lzEndpoint).send{value: msg.value}(\n            MessagingParams(dstEid, peers[dstEid], payload, options, fee.lzTokenFee > 0),\n            payable(msg.sender)\n        );\n        \n        emit CrossChainTransfer(dstEid, msg.sender, address(uint160(uint256(toAddress))), amount);\n    }\n\n    /**\n     * @dev Receive tokens from LayerZero\n     */\n    function lzReceive(\n        Origin calldata origin,\n        bytes32 /* guid */,\n        bytes calldata message,\n        address /* executor */,\n        bytes calldata /* extraData */\n    ) external payable {\n        if (msg.sender != lzEndpoint) revert InvalidSource();\n        if (peers[origin.srcEid] != origin.sender) revert InvalidSource();\n        \n        (bytes32 toAddressBytes32, uint256 amount) = abi.decode(message, (bytes32, uint256));\n        address toAddress = address(uint160(uint256(toAddressBytes32)));\n        \n        // Mint tokens (with supply check)\n        if (totalSupply() + amount > MAX_SUPPLY) revert MaxSupplyExceeded();\n        _mint(toAddress, amount);\n        \n        emit CrossChainTransfer(origin.srcEid, address(uint160(uint256(origin.sender))), toAddress, amount);\n    }\n\n    // ======== EMERGENCY FUNCTIONS ========\n\n    /**\n     * @dev Emergency pause\n     */\n    function emergencyPause() external {\n        if (msg.sender != emergencyPauser && msg.sender != owner()) revert NotAuthorized();\n        flags.emergencyPaused = true;\n        emit EmergencyAction(\"Pause\", msg.sender);\n    }\n\n    /**\n     * @dev Emergency unpause\n     */\n    function emergencyUnpause() external onlyOwner {\n        flags.emergencyPaused = false;\n        emit EmergencyAction(\"Unpause\", msg.sender);\n    }\n\n    /**\n     * @dev Recover native tokens\n     */\n    function recoverNativeTokens() external onlyOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            _safeTransferNative(emergencyTreasury, balance);\n        }\n    }\n\n    /**\n     * @dev Recover ERC20 tokens (except DRAGON)\n     */\n    function recoverERC20(address token, uint256 amount) external onlyOwner {\n        if (token == address(this)) revert InvalidConfiguration();\n        IERC20(token).safeTransfer(emergencyTreasury, amount);\n    }\n\n    // ======== VIEW FUNCTIONS ========\n\n    /**\n     * @dev Get current configuration\n     */\n    function getConfiguration() external view returns (\n        PackedConfig memory,\n        PackedLimits memory,\n        PackedFlags memory,\n        PackedTimelock memory\n    ) {\n        return (config, limits, flags, timelock);\n    }\n\n    /**\n     * @dev Get fee information\n     */\n    function getFeeInfo() external view returns (\n        Fees memory,\n        Fees memory,\n        Fees memory\n    ) {\n        return (buyFees, sellFees, transferFees);\n    }\n\n    /**\n     * @dev Get contract size information for deployment verification\n     */\n    function getContractInfo() external pure returns (string memory) {\n        return \"omniDRAGON v2.0 - Optimized for production deployment\";\n    }\n\n    // ======== UTILITY FUNCTIONS ========\n\n    /**\n     * @dev Convert address to bytes32 for LayerZero V2\n     */\n    function addressToBytes32(address _addr) public pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Convert bytes32 to address for LayerZero V2\n     */\n    function bytes32ToAddress(bytes32 _b) public pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n\n    // ======== RECEIVE FUNCTION ========\n    receive() external payable {\n        // Accept native tokens for fee distribution\n    }\n}\n\n"
    },
    "contracts/core/vault/DragonJackpotDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"lib/openzeppelin-contracts/contracts/utils/Pausable.sol\";\n\n\n/**\n * @title DragonJackpotDistributor\n * @dev Contract for distributing jackpot prizes using optimized token utils\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IDragonJackpotDistributor {\n    function addToJackpot(uint256 amount) external;\n    function distributeJackpot(address winner, uint256 amount) external;\n    function getCurrentJackpot() external view returns (uint256);\n}\n\ncontract DragonJackpotDistributor is IDragonJackpotDistributor, Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    // Constants\n    uint256 public constant PERCENTAGE_DENOMINATOR = 10000; // 100% = 10000\n    uint256 public constant MAX_BATCH_SIZE = 100; // Maximum array size for batch operations\n    uint256 public constant MAX_RECIPIENTS = 50; // Maximum recipients for reward distribution\n\n    // State variables\n    IERC20 public immutable token; // The token to distribute (made immutable for security)\n    address public treasury; // Treasury wallet for emergency functions\n    address public swapTrigger; // The swap trigger oracle contract\n    uint256 public distributionPercentage = 6900; // 69% of jackpot per win\n    uint256 public jackpotBalance; // Current jackpot balance\n    uint256 public lastDistributionTime; // Last time a jackpot was distributed\n\n    // Mapping of authorized distributors\n    mapping(address => bool) public authorizedDistributors;\n\n    // History of jackpot wins\n    struct JackpotWin {\n        address winner;\n        uint256 amount;\n        uint256 timestamp;\n    }\n    JackpotWin[] public jackpotHistory;\n\n    // Counters\n    uint256 public totalDistributed;\n\n    // Events\n    event JackpotAdded(uint256 amount, uint256 newTotal);\n    event JackpotDistributed(address indexed winner, uint256 amount, uint256 timestamp);\n    event DistributionPercentageUpdated(uint256 oldPercentage, uint256 newPercentage);\n    event AuthorizedDistributorUpdated(address distributor, bool authorized);\n    event EmergencyWithdrawal(address indexed to, uint256 amount);\n    event RewardsDistributed(uint256 totalAmount, uint256 recipientCount);\n    event BatchTransferCompleted(uint256 tokenCount, address indexed treasury);\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n    event SwapTriggerUpdated(address indexed oldSwapTrigger, address indexed newSwapTrigger);\n\n    /**\n     * @dev Constructor\n     * @param _token The token to distribute\n     * @param _swapTrigger The swap trigger oracle contract\n     * @param _treasury Treasury address for emergency functions\n     */\n    constructor(\n        address _token,\n        address _swapTrigger,\n        address _treasury\n    ) Ownable(msg.sender) {\n        require(_token != address(0), \"Token cannot be zero address\");\n        require(_swapTrigger != address(0), \"Swap trigger oracle cannot be zero address\");\n        require(_treasury != address(0), \"Treasury cannot be zero address\");\n\n        token = IERC20(_token);\n        swapTrigger = _swapTrigger;\n        treasury = _treasury;\n\n        authorizedDistributors[_swapTrigger] = true;\n\n        // Register for Sonic FeeM automatically\n    }\n\n    /**\n     * @dev Modifier to only allow authorized contracts to call function\n     */\n    modifier onlyAuthorized() {\n        require(\n            msg.sender == swapTrigger ||\n            authorizedDistributors[msg.sender],\n            \"Not authorized\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Add funds to the jackpot\n     * @dev Caller must have pre-approved this contract to spend `amount` tokens\n     * using IERC20.approve() before calling this function\n     * @param amount Amount to add\n     */\n    function addToJackpot(uint256 amount) external override {\n        require(amount > 0, \"Amount must be > 0\");\n\n        // Transfer tokens from sender to contract\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Update jackpot balance\n        jackpotBalance += amount;\n\n        emit JackpotAdded(amount, jackpotBalance);\n    }\n\n    /**\n     * @dev Distribute a jackpot to a winner\n     * @param winner Address of the winner\n     * @param amount Amount to distribute\n     */\n    function distributeJackpot(address winner, uint256 amount) external override onlyAuthorized nonReentrant whenNotPaused {\n        require(winner != address(0), \"Winner cannot be zero address\");\n        require(amount > 0, \"Amount must be > 0\");\n\n        // Calculate distribution amount (capped by percentage)\n        uint256 maxDistribution = (jackpotBalance * distributionPercentage) / PERCENTAGE_DENOMINATOR;\n        uint256 distributionAmount = amount > maxDistribution ? maxDistribution : amount;\n\n        require(distributionAmount > 0, \"No distribution amount\");\n        // Note: This check is technically redundant since distributionAmount <= maxDistribution <= jackpotBalance\n        // but kept for defensive programming\n        require(jackpotBalance >= distributionAmount, \"Insufficient balance\");\n\n        // Update balances and counters\n        jackpotBalance -= distributionAmount;\n        totalDistributed += distributionAmount;\n        lastDistributionTime = block.timestamp;\n\n        // Record win in history\n        jackpotHistory.push(JackpotWin({\n            winner: winner,\n            amount: distributionAmount,\n            timestamp: block.timestamp\n        }));\n\n        // Transfer tokens to winner\n        token.safeTransfer(winner, distributionAmount);\n\n        emit JackpotDistributed(winner, distributionAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Distribute rewards to multiple recipients by basis points\n     * @dev Gas limit warning: Large arrays may exceed block gas limit.\n     * Maximum recipients limited to MAX_RECIPIENTS to prevent gas issues.\n     * @param amount Amount to distribute\n     * @param recipients Array of recipient addresses (max MAX_RECIPIENTS)\n     * @param basisPoints Array of basis points for each recipient (totaling 10000)\n     */\n    function distributeRewards(\n        uint256 amount,\n        address[] memory recipients,\n        uint256[] memory basisPoints\n    ) external onlyOwner nonReentrant whenNotPaused {\n        require(amount > 0, \"Amount must be > 0\");\n        require(jackpotBalance >= amount, \"Insufficient balance\");\n        require(recipients.length == basisPoints.length, \"Array length mismatch\");\n        require(recipients.length > 0, \"Empty arrays\");\n        require(recipients.length <= MAX_RECIPIENTS, \"Too many recipients\");\n\n        uint256 totalBasisPoints = 0;\n        for (uint256 i = 0; i < basisPoints.length; i++) {\n            require(recipients[i] != address(0), \"Zero address recipient\");\n            totalBasisPoints += basisPoints[i];\n        }\n        require(totalBasisPoints == PERCENTAGE_DENOMINATOR, \"Basis points must total 10000\");\n\n        // Update jackpot balance\n        jackpotBalance -= amount;\n\n        // Distribute to each recipient based on their basis points\n        // Note: Due to integer division, small fractions may remain in contract\n        for (uint256 i = 0; i < recipients.length; i++) {\n            uint256 recipientAmount = (amount * basisPoints[i]) / PERCENTAGE_DENOMINATOR;\n            if (recipientAmount > 0) {\n                token.safeTransfer(recipients[i], recipientAmount);\n            }\n        }\n\n        emit RewardsDistributed(amount, recipients.length);\n    }\n\n    /**\n     * @notice Emergency withdraw all funds to treasury\n     * @dev Administrative function to rescue all main token funds in emergency situations\n     */\n    function emergencyWithdraw() external onlyOwner {\n        uint256 balance = token.balanceOf(address(this));\n        require(balance > 0, \"No balance to withdraw\");\n\n        // Transfer tokens to treasury\n        token.safeTransfer(treasury, balance);\n\n        jackpotBalance = 0;\n\n        emit EmergencyWithdrawal(treasury, balance);\n    }\n\n    /**\n     * @notice Batch transfer multiple tokens to the treasury\n     * @dev Administrative function for rescuing various tokens (excluding main jackpot token).\n     * Gas limit warning: Large arrays may exceed block gas limit.\n     * Maximum batch size limited to MAX_BATCH_SIZE to prevent gas issues.\n     * Use emergencyWithdraw for the main jackpot token.\n     * @param tokens Array of token addresses (max MAX_BATCH_SIZE)\n     * @param amounts Array of amounts to transfer\n     */\n    function batchTransferToTreasury(\n        address[] memory tokens,\n        uint256[] memory amounts\n    ) external onlyOwner {\n        require(tokens.length == amounts.length, \"Array length mismatch\");\n        require(tokens.length > 0, \"Empty arrays\");\n        require(tokens.length <= MAX_BATCH_SIZE, \"Batch size too large\");\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            require(tokens[i] != address(0), \"Cannot batch transfer zero address token\");\n            require(tokens[i] != address(token), \"Use emergencyWithdraw for main token\");\n            require(amounts[i] > 0, \"Amount must be > 0\");\n\n            IERC20 tokenContract = IERC20(tokens[i]);\n            tokenContract.safeTransfer(treasury, amounts[i]);\n        }\n\n        emit BatchTransferCompleted(tokens.length, treasury);\n    }\n\n    // Admin functions\n\n    /**\n     * @dev Set distribution percentage\n     * @param _percentage New distribution percentage (in basis points, 10000 = 100%)\n     */\n    function setDistributionPercentage(uint256 _percentage) external onlyOwner {\n        require(_percentage <= PERCENTAGE_DENOMINATOR, \"Percentage too high\");\n        require(_percentage > 0, \"Percentage must be > 0\");\n        uint256 oldPercentage = distributionPercentage;\n        distributionPercentage = _percentage;\n        emit DistributionPercentageUpdated(oldPercentage, _percentage);\n    }\n\n    /**\n     * @dev Set authorized distributor\n     * @param _distributor Distributor address\n     * @param _authorized Whether the distributor is authorized\n     */\n    function setAuthorizedDistributor(address _distributor, bool _authorized) external onlyOwner {\n        require(_distributor != address(0), \"Distributor cannot be zero address\");\n        authorizedDistributors[_distributor] = _authorized;\n        emit AuthorizedDistributorUpdated(_distributor, _authorized);\n    }\n\n    /**\n     * @dev Set treasury address\n     * @param _treasury New treasury address\n     */\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0), \"Treasury cannot be zero address\");\n        address oldTreasury = treasury;\n        treasury = _treasury;\n        emit TreasuryUpdated(oldTreasury, _treasury);\n    }\n\n    /**\n     * @dev Set swap trigger address\n     * @param _swapTrigger New swap trigger address\n     */\n    function setSwapTrigger(address _swapTrigger) external onlyOwner {\n        require(_swapTrigger != address(0), \"Swap trigger cannot be zero address\");\n\n        // Remove authorization from old swap trigger\n        if (swapTrigger != address(0)) {\n            authorizedDistributors[swapTrigger] = false;\n        }\n\n        address oldSwapTrigger = swapTrigger;\n        swapTrigger = _swapTrigger;\n\n        // Authorize new swap trigger\n        authorizedDistributors[_swapTrigger] = true;\n\n        emit SwapTriggerUpdated(oldSwapTrigger, _swapTrigger);\n        emit AuthorizedDistributorUpdated(oldSwapTrigger, false);\n        emit AuthorizedDistributorUpdated(_swapTrigger, true);\n    }\n\n    /**\n     * @dev Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // View functions\n\n    /**\n     * @dev Get the current jackpot balance\n     * @return Current jackpot balance\n     */\n    function getCurrentJackpot() external view override returns (uint256) {\n        return jackpotBalance;\n    }\n\n    /**\n     * @dev Get a jackpot win by index\n     * @param index Index of the win\n     * @return winner The address of the winner\n     * @return amount The amount won\n     * @return timestamp The time when the jackpot was won\n     */\n    function getJackpotHistory(uint256 index) external view returns (\n        address winner,\n        uint256 amount,\n        uint256 timestamp\n    ) {\n        require(index < jackpotHistory.length, \"Invalid index\");\n        JackpotWin memory win = jackpotHistory[index];\n        return (win.winner, win.amount, win.timestamp);\n    }\n\n    /**\n     * @dev Get jackpot history count\n     * @return Number of jackpot history entries\n     */\n    function getJackpotHistoryCount() external view returns (uint256) {\n        return jackpotHistory.length;\n    }\n\n    /**\n     * @dev Get a slice of jackpot history to avoid gas limit issues\n     * @param startIndex Starting index (inclusive)\n     * @param endIndex Ending index (exclusive)\n     * @return winners Array of winner addresses\n     * @return amounts Array of amounts won\n     * @return timestamps Array of win timestamps\n     */\n    function getJackpotHistorySlice(\n        uint256 startIndex,\n        uint256 endIndex\n    ) external view returns (\n        address[] memory winners,\n        uint256[] memory amounts,\n        uint256[] memory timestamps\n    ) {\n        require(startIndex < jackpotHistory.length, \"Start index out of bounds\");\n        require(endIndex <= jackpotHistory.length, \"End index out of bounds\");\n        require(startIndex < endIndex, \"Invalid range\");\n        require(endIndex - startIndex <= MAX_BATCH_SIZE, \"Range too large\");\n\n        uint256 length = endIndex - startIndex;\n        winners = new address[](length);\n        amounts = new uint256[](length);\n        timestamps = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            JackpotWin memory win = jackpotHistory[startIndex + i];\n            winners[i] = win.winner;\n            amounts[i] = win.amount;\n            timestamps[i] = win.timestamp;\n        }\n\n        return (winners, amounts, timestamps);\n    }\n\n    /**\n     * @dev Get the token address\n     * @return The token contract address\n     */\n    function getToken() external view returns (address) {\n        return address(token);\n    }\n\n    /**\n     * @notice Check if this contract is registered for Sonic FeeM\n     * @return isRegistered Whether the contract is registered for fee monetization\n     */\n    function checkFeeMStatus() external view returns (bool isRegistered) {\n    }\n}\n"
    },
    "contracts/core/vault/DragonJackpotVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20 } from 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from 'lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { ReentrancyGuard } from 'lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol';\nimport { Ownable } from 'lib/openzeppelin-contracts/contracts/access/Ownable.sol';\nimport { IDragonJackpotVault } from \"../../interfaces/vault/IDragonJackpotVault.sol\";\n\n\n/**\n * @title DragonJackpotVault\n * @dev Jackpot vault with lottery mechanics and adaptive fee management\n *\n * Central component for Dragon ecosystem lottery system and jackpot distribution\n * Integrates with OmniDragon token to provide engaging lottery experiences\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract DragonJackpotVault is IDragonJackpotVault, Ownable, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // Track jackpot balances by token\n  mapping(address => uint256) public jackpotBalances;\n\n  // Wrapped native token (WETH, WrappedNativeToken)\n  address public wrappedNativeToken;\n\n  // Last win timestamp\n  uint256 public lastWinTimestamp;\n\n  // Fee manager address for registration\n  address public feeManagerAddress;\n\n  // Events\n  event JackpotAdded(address indexed token, uint256 amount);\n  event JackpotPaid(address indexed token, address indexed winner, uint256 amount);\n  event WrappedNativeTokenSet(address indexed oldToken, address indexed newToken);\n  event FeeManagerAddressSet(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Constructor\n   * @param _wrappedNativeToken Initial wrapped native token address\n   * @param _feeManagerAddress Initial fee manager address for registration\n   */\n  constructor(address _wrappedNativeToken, address _feeManagerAddress) Ownable(msg.sender) {\n    require(_wrappedNativeToken != address(0), 'Zero address');\n    require(_feeManagerAddress != address(0), 'Zero address');\n    wrappedNativeToken = _wrappedNativeToken;\n    feeManagerAddress = _feeManagerAddress;\n\n    // Register for Sonic FeeM automatically\n  }\n\n  /**\n   * @dev Add ERC20 tokens to the jackpot with proper token tracking\n   * @param token Token address\n   * @param amount Amount to add\n   */\n  function addERC20ToJackpot(address token, uint256 amount) external {\n    require(amount > 0, 'Amount must be > 0');\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    jackpotBalances[token] += amount;\n    emit JackpotAdded(token, amount);\n  }\n\n  /**\n   * @dev Add collected funds that are already in the vault (for trusted callers only)\n   * @param token Token address\n   * @param amount Amount to add to accounting\n   */\n  function addCollectedFunds(address token, uint256 amount) external onlyOwner {\n    require(amount > 0, 'Amount must be > 0');\n    require(token != address(0), 'Invalid token');\n    jackpotBalances[token] += amount;\n    emit JackpotAdded(token, amount);\n  }\n\n  /**\n   * @dev Get the current jackpot balance (in wrapped native token)\n   * @return balance The current jackpot balance\n   */\n  function getJackpotBalance() external view override returns (uint256 balance) {\n    return jackpotBalances[wrappedNativeToken];\n  }\n\n  /**\n   * @dev Pay jackpot to winner (owner only) with specific token\n   * @param token Token address\n   * @param winner Winner address\n   * @param amount Amount to pay\n   */\n  function payJackpotWithToken(address token, address winner, uint256 amount) external onlyOwner nonReentrant {\n    require(winner != address(0), 'Zero address');\n    require(amount > 0, 'Amount must be > 0');\n    require(jackpotBalances[token] >= amount, 'Insufficient balance');\n\n    // Checks-Effects-Interactions pattern\n    jackpotBalances[token] -= amount;\n    lastWinTimestamp = block.timestamp;\n\n    IERC20(token).safeTransfer(winner, amount);\n    emit JackpotPaid(token, winner, amount);\n  }\n\n  /**\n   * @dev Pay jackpot to winner using wrapped native token (implements interface method)\n   * @param winner Winner address\n   * @param amount Amount to pay\n   */\n  function payJackpot(address winner, uint256 amount) external override onlyOwner nonReentrant {\n    require(wrappedNativeToken != address(0), 'Wrapped token not set');\n    require(winner != address(0), 'Zero address');\n    require(amount > 0, 'Amount must be > 0');\n    require(jackpotBalances[wrappedNativeToken] >= amount, 'Insufficient balance');\n\n    // Checks-Effects-Interactions pattern\n    jackpotBalances[wrappedNativeToken] -= amount;\n    lastWinTimestamp = block.timestamp;\n\n    IERC20(wrappedNativeToken).safeTransfer(winner, amount);\n    emit JackpotPaid(wrappedNativeToken, winner, amount);\n  }\n\n  /**\n   * @dev Get the time of the last jackpot win\n   * @return timestamp The last win timestamp\n   */\n  function getLastWinTime() external view override returns (uint256 timestamp) {\n    return lastWinTimestamp;\n  }\n\n  /**\n   * @dev Set the wrapped native token address\n   * @param _wrappedNativeToken The new wrapped native token address\n   */\n  function setWrappedNativeToken(address _wrappedNativeToken) external override onlyOwner {\n    require(_wrappedNativeToken != address(0), 'Zero address');\n    address oldToken = wrappedNativeToken;\n    wrappedNativeToken = _wrappedNativeToken;\n    emit WrappedNativeTokenSet(oldToken, _wrappedNativeToken);\n  }\n\n  /**\n   * @dev Set the fee manager address for registration\n   * @param _feeManagerAddress The new fee manager address\n   */\n  function setFeeManagerAddress(address _feeManagerAddress) external onlyOwner {\n    require(_feeManagerAddress != address(0), 'Zero address');\n    address oldAddress = feeManagerAddress;\n    feeManagerAddress = _feeManagerAddress;\n    emit FeeManagerAddressSet(oldAddress, _feeManagerAddress);\n  }\n\n  /**\n   * @dev Get jackpot balance for a specific token\n   * @param token Token address\n   * @return Jackpot balance\n   */\n  function getJackpotBalance(address token) external view returns (uint256) {\n    return jackpotBalances[token];\n  }\n\n  /**\n   * @dev Allow receiving ETH and track it as wrapped native token balance\n   */\n  receive() external payable {\n    require(wrappedNativeToken != address(0), 'Wrapped token not set for ETH');\n    require(msg.value > 0, 'No ETH sent');\n\n    // Track received ETH as wrapped native token balance\n    jackpotBalances[wrappedNativeToken] += msg.value;\n    emit JackpotAdded(wrappedNativeToken, msg.value);\n  }\n\n  /**\n   * @notice Check if this contract is registered for Sonic FeeM\n   * @return isRegistered Whether the contract is registered for fee monetization\n   */\n  function checkFeeMStatus() external view returns (bool isRegistered) {\n  }\n}\n"
    },
    "contracts/interfaces/config/IChainRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Interface: IChainRegistry\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonic_reddragon_bot\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IChainRegistry\n * @dev Interface for chain registry and cross-chain verification\n *\n * Manages chain IDs and validates cross-chain operations within the OmniDragon ecosystem\n * Ensures secure LayerZero communication between supported chains\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IChainRegistry {\n    /**\n     * @dev Struct to hold chain-specific configuration\n     */\n    struct ChainConfig {\n        uint16 chainId;\n        string chainName;\n        address wrappedNativeToken;    // WETH, WrappedNativeToken, WSOL, WBERA, etc.\n        address lotteryManager;        // Chain-specific lottery manager (replaces swapTrigger)\n        address randomnessProvider;    // Chain-specific randomness provider\n        address priceOracle;           // Chain-specific price oracle\n        address vrfConsumer;           // Chain-specific VRF consumer\n        address dragonToken;           // Dragon token address on this chain\n        bool isActive;                 // Whether this chain is active\n    }\n\n    /**\n     * @notice Register a new chain configuration\n     * @param _chainId The LayerZero chain ID\n     * @param _chainName The human-readable chain name\n     * @param _wrappedNativeToken The wrapped native token address (WETH, WrappedNativeToken, WSOL, WBERA, etc.)\n     * @param _lotteryManager The chain-specific lottery manager address\n     * @param _randomnessProvider The chain-specific randomness provider address\n     * @param _priceOracle The chain-specific price oracle address\n     * @param _vrfConsumer The chain-specific VRF consumer address\n     * @param _dragonToken The Dragon token address on this chain\n     */\n    function registerChain(\n        uint16 _chainId,\n        string calldata _chainName,\n        address _wrappedNativeToken,\n        address _lotteryManager,\n        address _randomnessProvider,\n        address _priceOracle,\n        address _vrfConsumer,\n        address _dragonToken\n    ) external;\n\n    /**\n     * @notice Update an existing chain configuration\n     * @param _chainId The LayerZero chain ID to update\n     * @param _wrappedNativeToken The wrapped native token address\n     * @param _lotteryManager The chain-specific lottery manager address\n     * @param _randomnessProvider The chain-specific randomness provider address\n     * @param _priceOracle The chain-specific price oracle address\n     * @param _vrfConsumer The chain-specific VRF consumer address\n     * @param _dragonToken The Dragon token address on this chain\n     */\n    function updateChain(\n        uint16 _chainId,\n        address _wrappedNativeToken,\n        address _lotteryManager,\n        address _randomnessProvider,\n        address _priceOracle,\n        address _vrfConsumer,\n        address _dragonToken\n    ) external;\n\n    /**\n     * @notice Set chain active status\n     * @param _chainId The LayerZero chain ID\n     * @param _isActive Whether the chain is active\n     */\n    function setChainActive(uint16 _chainId, bool _isActive) external;\n\n    /**\n     * @notice Set the current chain ID\n     * @param _chainId The current chain's LayerZero ID\n     */\n    function setCurrentChainId(uint16 _chainId) external;\n\n    /**\n     * @notice Get chain configuration\n     * @param _chainId The LayerZero chain ID\n     * @return Chain configuration struct\n     */\n    function getChainConfig(uint16 _chainId) external view returns (ChainConfig memory);\n\n    /**\n     * @dev Get the current chain's LayerZero ID\n     * @return The LayerZero chain ID of the current chain\n     */\n    function getCurrentChainId() external view returns (uint16);\n\n    /**\n     * @dev Get the wrapped native token address for a specific chain\n     * @param _chainId The LayerZero chain ID\n     * @return The wrapped native token address for the specified chain\n     */\n    function getWrappedNativeToken(uint16 _chainId) external view returns (address);\n\n    /**\n     * @dev Get the lottery manager address for a specific chain\n     * @param _chainId The LayerZero chain ID\n     * @return The lottery manager address\n     */\n    function getLotteryManager(uint16 _chainId) external view returns (address);\n\n    /**\n     * @dev Get the randomness provider address for a specific chain\n     * @param _chainId The LayerZero chain ID\n     * @return The randomness provider address\n     */\n    function getRandomnessProvider(uint16 _chainId) external view returns (address);\n\n    /**\n     * @dev Get the price oracle address for a specific chain\n     * @param _chainId The LayerZero chain ID\n     * @return The price oracle address\n     */\n    function getPriceOracle(uint16 _chainId) external view returns (address);\n\n    /**\n     * @dev Get the swap trigger address for a specific chain (deprecated - returns lottery manager)\n     * @param _chainId The LayerZero chain ID\n     * @return The lottery manager address (for backward compatibility)\n     */\n    function getSwapTrigger(uint16 _chainId) external view returns (address);\n\n    /**\n     * @dev Get the VRF consumer address for a specific chain\n     * @param _chainId The LayerZero chain ID\n     * @return The VRF consumer address\n     */\n    function getVRFConsumer(uint16 _chainId) external view returns (address);\n\n    /**\n     * @dev Get the Dragon token address for a specific chain\n     * @param _chainId The LayerZero chain ID\n     * @return The Dragon token address\n     */\n    function getDragonToken(uint16 _chainId) external view returns (address);\n\n    /**\n     * @dev Get all supported chain IDs\n     * @return Array of supported chain IDs\n     */\n    function getSupportedChains() external view returns (uint16[] memory);\n\n    /**\n     * @dev Check if a chain is supported\n     * @param _chainId The LayerZero chain ID to check\n     * @return True if the chain is supported, false otherwise\n     */\n    function isChainSupported(uint16 _chainId) external view returns (bool);\n\n    /**\n     * @notice Updates the chain-specific LZ endpoint address\n     * @param _newEndpoint The new chain-specific LZ endpoint address\n     */\n    function updateEndpoint(address _newEndpoint) external;\n\n    /**\n     * @dev Returns whether the endpoint has been updated\n     * @return True if updated, false otherwise\n     */\n    function isEndpointUpdated() external view returns (bool);\n\n    /**\n     * @dev Returns the deadline for updating the endpoint\n     * @return Timestamp of the update deadline\n     */\n    function updateDeadline() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title AggregatorV3Interface\n * @dev Standard Chainlink price feed interface\n *\n * Provides access to decentralized price data for various asset pairs\n * Used throughout the OmniDragon ecosystem for oracle-based pricing\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/interfaces/external/chainlink/IChainlinkVRFIntegratorV2_5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { MessagingFee } from \"../../../../lib/devtools/packages/oapp-evm/contracts/oapp/OApp.sol\";\nimport { MessagingReceipt } from \"../../../../lib/devtools/packages/oapp-evm/contracts/oapp/OAppSender.sol\";\n\n/**\n * @title IChainlinkVRFIntegratorV2_5\n * @dev Interface for Chainlink VRF 2.5 integration with cross-chain support\n * \n * This contract forwards VRF requests to peer chains for Chainlink VRF 2.5 processing via LayerZero V2.\n */\ninterface IChainlinkVRFIntegratorV2_5 {\n    \n    // Events\n    event RandomWordsRequested(uint64 indexed requestId, address indexed requester, uint32 dstEid);\n    event MessageSent(uint64 indexed requestId, uint32 indexed dstEid, bytes message);\n    event RandomWordsReceived(uint256[] randomWords, uint64 indexed sequence, address indexed provider);\n    event CallbackFailed(uint64 indexed sequence, address indexed provider, string reason);\n    event CallbackSucceeded(uint64 indexed sequence, address indexed provider);\n    event RequestExpired(uint64 indexed sequence, address indexed provider);\n    event GasLimitUpdated(uint32 oldLimit, uint32 newLimit);\n    event RequestTimeoutUpdated(uint256 oldTimeout, uint256 newTimeout); // AUDIT FIX: Add missing event\n    event FeeMRegistered(address indexed contractAddress, uint256 indexed feeId);\n    event ContractFunded(address indexed funder, uint256 amount, uint256 newBalance);\n\n    /**\n     * @notice Check the status of a request\n     * @param requestId The request ID to check\n     * @return fulfilled Whether the request has been fulfilled\n     * @return exists Whether the request exists\n     * @return provider The address that made the request\n     * @return randomWord The random word (0 if not fulfilled)\n     * @return timestamp When the request was made\n     * @return expired Whether the request has expired\n     */\n    function checkRequestStatus(uint64 requestId) external view returns (\n        bool fulfilled,\n        bool exists,\n        address provider,\n        uint256 randomWord,\n        uint256 timestamp,\n        bool expired\n    );\n\n    /**\n     * @notice Get the random word for a fulfilled request\n     * @param requestId The request ID to query\n     * @return randomWord The random word (0 if not fulfilled)\n     * @return fulfilled Whether the request has been fulfilled\n     */\n    function getRandomWord(uint64 requestId) external view returns (uint256 randomWord, bool fulfilled);\n\n    /**\n     * @dev Request random words from a peer VRF Consumer\n     * @param _dstEid The destination endpoint ID\n     * @param _options LayerZero options for the cross-chain message\n     */\n    function requestRandomWords(uint32 _dstEid, bytes calldata _options) external payable returns (MessagingReceipt memory receipt, uint64 requestId);\n\n    /**\n     * @dev Request random words with default gas limit\n     * @param _dstEid The destination endpoint ID\n     */\n    function requestRandomWordsSimple(uint32 _dstEid) external payable returns (MessagingReceipt memory receipt, uint64 requestId);\n    \n    /**\n     * @dev Quote the fee for a random words request\n     * @param _dstEid The destination endpoint ID\n     * @param _options LayerZero options for the cross-chain message\n     */\n    function quote(uint32 _dstEid, bytes calldata _options) external view returns (MessagingFee memory fee);\n\n    /**\n     * @dev Update default gas limit (owner only)\n     */\n    function setDefaultGasLimit(uint32 _gasLimit) external;\n\n    /**\n     * @dev Update request timeout (owner only)\n     */\n    function setRequestTimeout(uint256 _timeout) external;\n\n    /**\n     * @dev Clean up expired requests (anyone can call)\n     * @param requestIds Array of request IDs to clean up\n     */\n    function cleanupExpiredRequests(uint64[] calldata requestIds) external;\n\n    /**\n     * @dev Register contract on Sonic FeeM\n     */\n    function registerMe() external; // TEMPORARILY DISABLED - requires valid FeeM Project ID\n\n    /**\n     * @dev Emergency withdraw (owner only)\n     */\n    function withdraw() external;\n\n    /**\n     * @dev Fund contract with ETH for LayerZero operations\n     */\n    function fundContract() external payable;\n\n    /**\n     * @dev Authorize/deauthorize callers\n     * @param caller The address to authorize/deauthorize\n     * @param authorized Whether to authorize or deauthorize\n     */\n    function setAuthorizedCaller(address caller, bool authorized) external;\n\n    /**\n     * @dev Get current contract balance and status\n     * @return balance Current ETH balance\n     * @return canOperate Whether contract has sufficient funds for operations\n     */\n    function getContractStatus() external view returns (uint256 balance, bool canOperate);\n\n    /* ========== STATE VARIABLES ========== */\n\n    function requestCounter() external view returns (uint64);\n    function defaultGasLimit() external view returns (uint32);\n    function requestTimeout() external view returns (uint256);\n    function s_requests(uint64 requestId) external view returns (\n        bool fulfilled,\n        bool exists,\n        address provider,\n        uint256 randomWord,\n        uint256 timestamp,\n        bool isContract\n    );\n    // AUDIT FIX: Removed redundant randomWordsProviders mapping from interface\n} "
    },
    "contracts/interfaces/external/chainlink/IOmniDragonVRFConsumerV2_5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { Origin } from \"lib/devtools/packages/oapp-evm/contracts/oapp/OApp.sol\";\nimport { MessagingFee } from \"lib/devtools/packages/oapp-evm/contracts/oapp/OAppSender.sol\";\n\n/**\n * @title IOmniDragonVRFConsumerV2_5\n * @dev Interface for OmniDragon VRF Consumer V2.5 - Chainlink VRF 2.5 integration contract\n * \n * This contract resides on a destination chain (e.g., Arbitrum), receives VRF requests from a source chain via LayerZero,\n * gets randomness from Chainlink VRF 2.5, and sends responses back to the source chain.\n */\ninterface IOmniDragonVRFConsumerV2_5 {\n    \n    // Events\n    event RandomWordsRequested(uint256 indexed requestId, uint32 indexed srcEid, bytes32 indexed requester, uint256 timestamp);\n    event VRFRequestSent(uint64 indexed sequence, uint256 indexed vrfRequestId);\n    event RandomnessFulfilled(uint256 indexed requestId, uint256[] randomWords);\n    event ResponseSentToSonic(uint64 indexed sequence, uint256 randomWord, uint256 fee);\n    event ResponsePending(uint64 indexed sequence, uint256 indexed requestId, string reason);\n    event VRFConfigUpdated(uint256 subscriptionId, bytes32 keyHash, uint32 callbackGasLimit, uint16 requestConfirmations);\n    event MinimumBalanceUpdated(uint256 oldBalance, uint256 newBalance);\n    event SonicGasLimitUpdated(uint32 oldLimit, uint32 newLimit);\n    event ContractFunded(address indexed funder, uint256 amount, uint256 newBalance);\n\n    /**\n     * @notice Retry sending a pending response\n     * @param sequence The sequence number to retry\n     */\n    function retryPendingResponse(uint64 sequence) external payable;\n\n    /**\n     * @notice Quote LayerZero fee for sending response to Sonic\n     * @dev Provides accurate fee estimation for responses\n     */\n    function quoteSendToSonic() external view returns (MessagingFee memory fee);\n\n    /**\n     * @notice LayerZero V2 clear method for manual message recovery\n     * @dev Use this if messages get stuck and need manual clearing\n     * @param _origin Original message origin\n     * @param _guid Message GUID\n     * @param _message Original message content\n     */\n    function clearStuckMessage(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message\n    ) external;\n\n    /**\n     * @notice Test VRF request function (owner only) - for testing purposes\n     */\n    function testVRFRequest() external returns (uint256 requestId);\n\n    /* ========== CONFIGURATION FUNCTIONS ========== */\n\n    /**\n     * @dev Set VRF 2.5 configuration (owner only)\n     */\n    function setVRFConfig(\n        uint256 _subscriptionId,\n        bytes32 _keyHash,\n        uint32 _callbackGasLimit,\n        uint16 _requestConfirmations,\n        bool _nativePayment\n    ) external;\n\n    function setMinimumBalance(uint256 _minimumBalance) external;\n    function setSonicGasLimit(uint32 _gasLimit) external;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @dev Get VRF configuration\n     */\n    function getVRFConfig() external view returns (\n        uint256 _subscriptionId,\n        bytes32 _keyHash,\n        uint32 _callbackGasLimit,\n        uint16 _requestConfirmations,\n        bool _nativePayment\n    );\n\n    /**\n     * @dev Get request details by sequence\n     */\n    function getRequestBySequence(uint64 sequence) external view returns (\n        uint256 requestId,\n        bool exists,\n        bool fulfilled,\n        bool responseSent,\n        uint256 randomWord,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Get request details by VRF request ID\n     */\n    function getRequestById(uint256 requestId) external view returns (\n        uint64 sequence,\n        bool exists,\n        bool fulfilled,\n        bool responseSent,\n        uint256 randomWord,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Check contract status\n     */\n    function getContractStatus() external view returns (\n        uint256 balance,\n        uint256 minBalance,\n        bool canSendResponses,\n        uint32 gasLimit\n    );\n\n    /* ========== STATE VARIABLES ========== */\n\n    function subscriptionId() external view returns (uint256);\n    function keyHash() external view returns (bytes32);\n    function callbackGasLimit() external view returns (uint32);\n    function requestConfirmations() external view returns (uint16);\n    function numWords() external view returns (uint32);\n    function nativePayment() external view returns (bool);\n    function minimumBalance() external view returns (uint256);\n    function sonicGasLimit() external view returns (uint32);\n    function sequenceToRequestId(uint64 sequence) external view returns (uint256);\n    function pendingResponses(uint64 sequence) external view returns (bool);\n\n    /* ========== ADMIN FUNCTIONS ========== */\n\n    function withdraw() external;\n\n    /**\n     * @dev Fund contract with ETH for LayerZero fees and VRF operations\n     */\n    function fundContract() external payable;\n}\n"
    },
    "contracts/interfaces/external/chainlink/IRandomWordsCallbackV2_5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n/**\n * @title IRandomWordsCallbackV2_5\n * @dev Interface for contracts that can receive random words from the ChainlinkVRFIntegratorV2_5.\n *      This matches the callback pattern used by Chainlink VRF 2.5 consumers.\n */\ninterface IRandomWordsCallbackV2_5 {\n    /**\n     * @notice Callback function to receive fulfilled random words.\n     * @param randomWords An array containing the fulfilled random words. For the current\n     *                    integrator, this will be an array with a single word.\n     * @param sequence The unique sequence number (request ID) of the VRF request.\n     */\n    function receiveRandomWords(uint256[] memory randomWords, uint64 sequence) external;\n} "
    },
    "contracts/interfaces/external/chainlink/IVRFCoordinatorV2Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { VRFV2PlusClient } from \"./VRFV2PlusClient.sol\";\n\n/**\n * @title IVRFCoordinatorV2Plus\n * @dev Interface for the Chainlink VRF Coordinator V2.5.\n *      It uses a struct-based approach for requesting random words.\n */\ninterface IVRFCoordinatorV2Plus {\n    /**\n     * @notice Request a set of random words using the VRF 2.5 struct format.\n     * @param req The RandomWordsRequest struct containing all parameters for the VRF request.\n     * @return requestId A unique identifier for the request.\n     */\n    function requestRandomWords(\n        VRFV2PlusClient.RandomWordsRequest calldata req\n    ) external returns (uint256 requestId);\n\n    // Other functions from the coordinator can be added here if needed.\n    // For example: getRequestConfig, getSubscription, etc.\n} "
    },
    "contracts/interfaces/external/chainlink/VRFV2PlusClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n/**\n * @title VRFV2PlusClient\n * @dev A client library for formatting requests to Chainlink VRF V2.5.\n *      This library provides the necessary structs and helper functions to interact\n *      with the VRF Coordinator using its struct-based interface.\n */\nlibrary VRFV2PlusClient {\n    /**\n     * @dev Extra arguments structure for VRF 2.5, allowing specification of payment method.\n     */\n    struct ExtraArgsV1 {\n        bool nativePayment; // true for native token payment, false for LINK payment\n    }\n\n    /**\n     * @dev Main request structure for VRF 2.5, encapsulating all request parameters.\n     */\n    struct RandomWordsRequest {\n        bytes32 keyHash;              // The gas lane key hash\n        uint256 subId;                // The subscription ID\n        uint16 requestConfirmations;  // Minimum number of confirmations\n        uint32 callbackGasLimit;      // Gas limit for the callback function\n        uint32 numWords;              // The number of random words to request\n        bytes extraArgs;              // Encoded extra arguments (e.g., payment type)\n    }\n\n    /**\n     * @dev The official tag for encoding VRF V2.5 ExtraArgsV1.\n     *      This ensures the coordinator can correctly decode the extra arguments.\n     */\n    bytes4 public constant EXTRA_ARGS_V1_TAG = bytes4(keccak256(\"VRF ExtraArgsV1\"));\n\n    /**\n     * @notice Encodes the ExtraArgsV1 struct into bytes with the correct V2.5 tag.\n     * @param extraArgs The struct containing extra arguments to encode.\n     * @return The ABI-encoded bytes payload for the `extraArgs` field of the request.\n     */\n    function _argsToBytes(ExtraArgsV1 memory extraArgs) internal pure returns (bytes memory) {\n        return abi.encodePacked(EXTRA_ARGS_V1_TAG, abi.encode(extraArgs.nativePayment));\n    }\n} "
    },
    "contracts/interfaces/external/IApi3Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IApi3Proxy\n * @dev Interface for API3 dAPI proxy contracts\n * Based on official API3 documentation: https://docs.api3.org/\n * \n * API3 dAPIs provide first-party oracle data directly from data providers\n * without intermediaries. This interface allows reading price data from\n * API3 proxy contracts obtained through the API3 Market.\n */\ninterface IApi3Proxy {\n    /**\n     * @notice Reads the latest data from the dAPI\n     * @dev This is the primary function for reading API3 dAPI data\n     * @return value The latest price value (typically 18 decimals for USD pairs)\n     * @return timestamp The timestamp of when the data was last updated\n     */\n    function read() external view returns (int224 value, uint256 timestamp);\n}\n\n/**\n * @title IApi3ReaderProxyV1\n * @dev Extended interface for API3 ReaderProxyV1 contracts\n * These contracts also implement Chainlink's AggregatorV2V3Interface\n * for drop-in compatibility with existing Chainlink integrations.\n */\ninterface IApi3ReaderProxyV1 is IApi3Proxy {\n    /**\n     * @notice Returns the description of the data feed\n     * @return The description string\n     */\n    function description() external view returns (string memory);\n    \n    /**\n     * @notice Returns the number of decimals for the data feed\n     * @return The number of decimals (typically 18 for USD pairs)\n     */\n    function decimals() external view returns (uint8);\n    \n    /**\n     * @notice Returns the version of the aggregator\n     * @return The version number\n     */\n    function version() external view returns (uint256);\n    \n    /**\n     * @notice Chainlink-compatible interface for latest round data\n     * @return roundId The round ID (always 1 for API3)\n     * @return answer The price answer\n     * @return startedAt The timestamp when the round started\n     * @return updatedAt The timestamp when the round was updated\n     * @return answeredInRound The round ID in which the answer was computed\n     */\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/interfaces/external/IJackpot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IJackpot\n * @dev Interface for Jackpot\n * @notice This file was auto-generated during repository restructure\n */\ninterface IJackpot {\n  // TODO: Add interface methods based on implementation\n}\n"
    },
    "contracts/interfaces/external/IPyth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IPyth\n * @dev Interface for Pyth Network price feeds\n * @notice Pyth Network provides pull-based oracle data with sub-second updates\n * \n * DRAGON INTELLIGENCE SYSTEM - PYTH INTEGRATION\n * Used by DragonMarketOracle for multi-source price aggregation\n * Pyth provides high-frequency, institutional-grade price data\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\n/**\n * @dev A price with a degree of uncertainty, represented as a price +- a confidence interval.\n *\n * The confidence interval roughly corresponds to the standard error of a normal distribution.\n * Both the price and confidence are stored in a fixed-point numeric representation,\n * `x * (10^expo)`, where `expo` is the exponent.\n *\n * Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how\n * to how this price safely.\n */\nstruct PythPrice {\n    // Price\n    int64 price;\n    // Confidence interval around the price\n    uint64 conf;\n    // Price exponent\n    int32 expo;\n    // Unix timestamp describing when the price was published\n    uint publishTime;\n}\n\n/**\n * @dev PriceFeed represents a current aggregate price from pyth publisher feeds.\n */\nstruct PythPriceFeed {\n    // The price ID.\n    bytes32 id;\n    // Latest available price\n    PythPrice price;\n    // Latest available exponentially-weighted moving average price\n    PythPrice emaPrice;\n}\n\ninterface IPyth {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(bytes32 id) external view returns (PythPrice memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(bytes32 id) external view returns (PythPrice memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update (which may be arbitrarily far in the past)\n    /// if the price feed exists.\n    /// This function makes no guarantees that the returned price update is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(bytes32 id) external view returns (PythPrice memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(bytes32 id, uint age) external view returns (PythPrice memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(bytes32 id) external view returns (PythPrice memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(bytes32 id, uint age) external view returns (PythPrice memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(bytes[] calldata updateData) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method does not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythPriceFeed[] memory priceFeeds);\n}\n"
    },
    "contracts/interfaces/external/IRedstoneOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IRedstoneOracle\n * @dev Interface for RedStone oracle price feeds\n *\n * Used by OmniDragonSwapTriggerOracle to read RedStone price data\n * RedStone uses a unique model where data is attached to transactions\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IRedstoneOracle {\n    /**\n     * @dev Get the latest value for a given data feed ID\n     * @param dataFeedId The identifier for the data feed (e.g., \"SONIC\", \"USD\")\n     * @return value The latest value with specified decimals\n     */\n    function getValue(bytes32 dataFeedId) external view returns (uint256 value);\n\n    /**\n     * @dev Get value with timestamp\n     * @param dataFeedId The identifier for the data feed\n     * @return value The latest value\n     * @return timestamp The timestamp of the value\n     */\n    function getValueWithTimestamp(bytes32 dataFeedId) external view returns (\n        uint256 value,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Get multiple values at once\n     * @param dataFeedIds Array of data feed identifiers\n     * @return values Array of values corresponding to the feed IDs\n     */\n    function getValues(bytes32[] calldata dataFeedIds) external view returns (uint256[] memory values);\n}\n"
    },
    "contracts/interfaces/external/IStdReference.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IStdReference\n * @dev Interface for Band Protocol's Standard Reference oracle contract\n *\n * Used by OmniDragonSwapTriggerOracle to read Band Protocol price feeds\n * Band provides cross-chain data oracle aggregating real-world data\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IStdReference {\n    /**\n     * @dev Structure returned for standard reference data\n     */\n    struct ReferenceData {\n        uint256 rate; // base/quote exchange rate, multiplied by 1e18\n        uint256 lastUpdatedBase; // UNIX epoch of last base price update\n        uint256 lastUpdatedQuote; // UNIX epoch of last quote price update\n    }\n\n    /**\n     * @dev Returns the price data for the given base/quote pair\n     * @param _base The base symbol (e.g., \"BTC\")\n     * @param _quote The quote symbol (e.g., \"USD\")\n     * @return Reference data containing rate and update times\n     */\n    function getReferenceData(string memory _base, string memory _quote)\n        external\n        view\n        returns (ReferenceData memory);\n\n    /**\n     * @dev Similar to getReferenceData, but with multiple base/quote pairs\n     * @param _bases Array of base symbols\n     * @param _quotes Array of quote symbols\n     * @return Array of reference data for each pair\n     */\n    function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes)\n        external\n        view\n        returns (ReferenceData[] memory);\n}\n"
    },
    "contracts/interfaces/external/IStorkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IStorkOracle\n * @dev Interface for STORK oracle price feeds\n *\n * Used by OmniDragonSwapTriggerOracle to read STORK price data\n * STORK provides ultra low latency price feeds for DeFi\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IStorkOracle {\n    /**\n     * @dev Get the latest price for a given asset ID\n     * @param assetId The identifier for the asset (e.g., hash of \"BTCUSD\")\n     * @return price The latest price (with decimals as configured)\n     * @return timestamp The timestamp of the price update\n     */\n    function getLatestPrice(bytes32 assetId) external view returns (uint256 price, uint256 timestamp);\n\n    /**\n     * @dev Get price with additional metadata\n     * @param assetId The identifier for the asset\n     * @return price The latest price\n     * @return timestamp The timestamp of the price update\n     * @return decimals The number of decimals in the price\n     */\n    function getPriceWithMetadata(bytes32 assetId) external view returns (\n        uint256 price,\n        uint256 timestamp,\n        uint8 decimals\n    );\n}\n"
    },
    "contracts/interfaces/external/layerzero/IDVNManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDVNManager\n * @dev LayerZero v2 DVN (Decentralized Verifier Network) management interface\n *\n * Provides standardized DVN configuration and management for OmniDragon ecosystem\n * Enables proper verification setup across different chains and message libraries\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IDVNManager {\n    // DVN Configuration structure\n    struct DVNConfig {\n        address dvnAddress;\n        uint64 confirmations;\n        uint16 multiplierBps;\n        uint128 floorMarginUSD;\n        bool isActive;\n        uint256 gasLimit;\n    }\n\n    // Send/Receive library configuration\n    struct LibraryConfig {\n        address sendLibrary;\n        address receiveLibrary;\n        uint32 eid;\n        uint256 gracePeriod;\n        bool isDefault;\n    }\n\n    // DVN assignment parameters\n    struct DVNAssignment {\n        uint32 dstEid;\n        address[] requiredDVNs;\n        address[] optionalDVNs;\n        uint8 requiredDVNCount;\n        uint8 optionalDVNThreshold;\n    }\n\n    // Events\n    event DVNConfigured(uint32 indexed eid, address indexed dvn, DVNConfig config);\n    event DVNRemoved(uint32 indexed eid, address indexed dvn);\n    event DVNAssignmentSet(uint32 indexed eid, address[] requiredDVNs, address[] optionalDVNs);\n    event LibraryConfigured(uint32 indexed eid, address sendLib, address receiveLib);\n    event DefaultDVNSet(address indexed dvn);\n    event DVNFeePaid(address indexed dvn, uint256 fee);\n    event DVNVerificationCompleted(uint32 indexed srcEid, bytes32 indexed messageHash, address indexed dvn);\n\n    // Errors\n    error DVNNotConfigured(address dvn);\n    error InvalidDVNConfig(address dvn);\n    error DVNAlreadyConfigured(address dvn);\n    error InsufficientDVNs(uint8 required, uint8 available);\n    error InvalidLibraryConfig(address libraryAddress);\n    error DVNVerificationFailed(address dvn, bytes32 messageHash);\n    error UnauthorizedDVN(address dvn);\n\n    /**\n     * @notice Configure DVN for a specific endpoint\n     * @param _eid Endpoint ID\n     * @param _dvn DVN address\n     * @param _config DVN configuration parameters\n     */\n    function configureDVN(uint32 _eid, address _dvn, DVNConfig calldata _config) external;\n\n    /**\n     * @notice Configure multiple DVNs for an endpoint\n     * @param _eid Endpoint ID\n     * @param _dvns Array of DVN addresses\n     * @param _configs Array of DVN configurations\n     */\n    function configureDVNs(\n        uint32 _eid,\n        address[] calldata _dvns,\n        DVNConfig[] calldata _configs\n    ) external;\n\n    /**\n     * @notice Set DVN assignment for message verification\n     * @param _assignment DVN assignment configuration\n     */\n    function setDVNAssignment(DVNAssignment calldata _assignment) external;\n\n    /**\n     * @notice Configure send/receive libraries for an endpoint\n     * @param _config Library configuration\n     */\n    function configureLibrary(LibraryConfig calldata _config) external;\n\n    /**\n     * @notice Remove DVN configuration\n     * @param _eid Endpoint ID\n     * @param _dvn DVN address to remove\n     */\n    function removeDVN(uint32 _eid, address _dvn) external;\n\n    /**\n     * @notice Get DVN configuration for an endpoint\n     * @param _eid Endpoint ID\n     * @param _dvn DVN address\n     * @return config DVN configuration\n     */\n    function getDVNConfig(uint32 _eid, address _dvn) external view returns (DVNConfig memory config);\n\n    /**\n     * @notice Get all configured DVNs for an endpoint\n     * @param _eid Endpoint ID\n     * @return dvns Array of DVN addresses\n     */\n    function getConfiguredDVNs(uint32 _eid) external view returns (address[] memory dvns);\n\n    /**\n     * @notice Get DVN assignment for an endpoint\n     * @param _eid Endpoint ID\n     * @return assignment DVN assignment configuration\n     */\n    function getDVNAssignment(uint32 _eid) external view returns (DVNAssignment memory assignment);\n\n    /**\n     * @notice Check if DVN is configured and active\n     * @param _eid Endpoint ID\n     * @param _dvn DVN address\n     * @return isActive True if DVN is active\n     */\n    function isDVNActive(uint32 _eid, address _dvn) external view returns (bool isActive);\n\n    /**\n     * @notice Estimate DVN fees for verification\n     * @param _eid Destination endpoint ID\n     * @param _confirmations Number of confirmations required\n     * @param _options Verification options\n     * @return totalFee Total estimated fee\n     */\n    function estimateDVNFees(\n        uint32 _eid,\n        uint64 _confirmations,\n        bytes calldata _options\n    ) external view returns (uint256 totalFee);\n\n    /**\n     * @notice Assign verification job to DVNs\n     * @param _eid Destination endpoint ID\n     * @param _packetHeader Packet header for verification\n     * @param _payloadHash Hash of the payload\n     * @param _confirmations Required confirmations\n     * @param _options Verification options\n     * @return assignedDVNs Array of DVNs assigned to the job\n     * @return totalFee Total fee for the assignment\n     */\n    function assignVerificationJob(\n        uint32 _eid,\n        bytes calldata _packetHeader,\n        bytes32 _payloadHash,\n        uint64 _confirmations,\n        bytes calldata _options\n    ) external payable returns (address[] memory assignedDVNs, uint256 totalFee);\n\n    /**\n     * @notice Verify message using assigned DVNs\n     * @param _srcEid Source endpoint ID\n     * @param _messageHash Message hash to verify\n     * @param _confirmations Number of confirmations\n     * @return isVerified True if verification succeeded\n     * @return verifyingDVNs DVNs that completed verification\n     */\n    function verifyMessage(\n        uint32 _srcEid,\n        bytes32 _messageHash,\n        uint64 _confirmations\n    ) external view returns (bool isVerified, address[] memory verifyingDVNs);\n\n    /**\n     * @notice Get library configuration for an endpoint\n     * @param _eid Endpoint ID\n     * @return config Library configuration\n     */\n    function getLibraryConfig(uint32 _eid) external view returns (LibraryConfig memory config);\n\n    /**\n     * @notice Emergency function to disable all DVNs\n     * @dev Only for emergency situations\n     */\n    function emergencyDisableAllDVNs() external;\n\n    /**\n     * @notice Set default DVN for unspecified endpoints\n     * @param _dvn Default DVN address\n     */\n    function setDefaultDVN(address _dvn) external;\n\n    /**\n     * @notice Get default DVN address\n     * @return dvn Default DVN address\n     */\n    function getDefaultDVN() external view returns (address dvn);\n} "
    },
    "contracts/interfaces/external/layerzero/ILayerZero.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV1 } from \"./ILayerZeroEndpointV1.sol\";\nimport { ILayerZeroEndpointV2 } from \"./ILayerZeroEndpointV2.sol\";\n\n/**\n * @title ILayerZero\n * @dev Combined interfaces for LayerZero V1 and V2\n *\n * Resolves function overload clashes between different LayerZero versions\n * Enables seamless cross-chain communication for the OmniDragon ecosystem\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\n// LayerZero V1 interfaces\ninterface ILayerZeroReceiverV1 {\n    /**\n     * @dev Receive messages from the LayerZero endpoint (V1)\n     * @param _srcChainId Chain ID of the source chain\n     * @param _srcAddress Address of the source contract (in bytes)\n     * @param _nonce Nonce of the message\n     * @param _payload Payload of the message\n     */\n    function lzReceiveV1(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n}\n\n// LayerZero V2 interfaces\ninterface ILayerZeroReceiverV2 {\n    /**\n     * @notice Origin information for incoming messages\n     */\n    struct Origin {\n        uint32 srcEid;        // Source endpoint ID\n        bytes32 sender;       // Source sender address (as bytes32)\n        uint64 nonce;         // Message nonce\n    }\n\n    /**\n     * @dev Receive messages from the LayerZero endpoint (V2)\n     * @param _origin Origin information\n     * @param _guid Message GUID\n     * @param _message Message content\n     * @param _executor Executor address\n     * @param _extraData Extra data\n     */\n    function lzReceiveV2(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external;\n}\n"
    },
    "contracts/interfaces/external/layerzero/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ILayerZeroUserApplicationConfig } from \"./ILayerZeroUserApplicationConfig.sol\";\n\n/**\n * @title ILayerZeroEndpoint\n * @dev Complete LayerZero Endpoint interface\n *\n * Provides full endpoint functionality for cross-chain message passing\n * Essential for OmniDragon's multi-chain token and communication operations\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "contracts/interfaces/external/layerzero/ILayerZeroEndpointV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ILayerZeroUserApplicationConfig } from \"./ILayerZeroUserApplicationConfig.sol\";\n\n/**\n * @title ILayerZeroEndpointV1\n * @dev Interface for the LayerZero endpoint V1\n *\n * Provides V1-specific functionality for cross-chain messaging\n * Legacy compatibility layer for OmniDragon's LayerZero integration\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface ILayerZeroEndpointV1 is ILayerZeroUserApplicationConfig {\n    // @notice Returns the LayerZero endpoint version\n    function getVersion() external view returns (uint16);\n\n    // @notice Returns the chain ID used by the endpoint\n    function getChainId() external view returns (uint16);\n\n    // @notice Get the default receive library address\n    function defaultReceiveLibraryAddress() external view returns (address);\n\n    // @notice Get the inbound nonce for a specific chain and address\n    function getInboundNonce(uint16 _chainId, bytes calldata _path) external view returns (uint64);\n\n    // @notice Get the outbound nonce for a specific chain and address\n    function getOutboundNonce(uint16 _chainId, address _srcAddress) external view returns (uint64);\n\n    // @notice Estimate fees for sending a message\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice Send a cross-chain message\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/layerzero/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Structs used by the interface\nstruct MessagingParams {\n  uint32 dstEid;\n  bytes32 receiver;\n  bytes message;\n  bytes options;\n  bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n  bytes32 guid;\n  uint64 nonce;\n  MessagingFee fee;\n}\n\nstruct MessagingFee {\n  uint256 nativeFee;\n  uint256 lzTokenFee;\n}\n\nstruct Origin {\n  uint32 srcEid;\n  bytes32 sender;\n  uint64 nonce;\n}\n\nstruct SetConfigParam {\n  uint32 eid;\n  uint32 configType;\n  bytes config;\n}\n\n/**\n * @title ILayerZeroEndpointV2\n * @dev Interface for LayerZero V2 endpoint\n */\ninterface ILayerZeroEndpointV2 {\n  /**\n   * @dev Send a message to another chain\n   * @param _params Messaging parameters\n   * @param _refundAddress Address to refund excess fees\n   * @return receipt Messaging receipt with GUID and fee info\n   */\n  function send(\n    MessagingParams calldata _params,\n    address _refundAddress\n  ) external payable returns (MessagingReceipt memory receipt);\n\n  /**\n   * @dev Quote the fee for sending a message\n   * @param _params Messaging parameters\n   * @param _sender Sender address\n   * @return fee The messaging fee quote\n   */\n  function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory fee);\n\n  /**\n   * @dev Set configuration for a specific endpoint and library\n   * @param _oappAddress OApp address\n   * @param _lib Library address\n   * @param _params Configuration parameters\n   */\n  function setConfig(address _oappAddress, address _lib, SetConfigParam[] calldata _params) external;\n\n  /**\n   * @dev Get configuration\n   * @param _oappAddress OApp address\n   * @param _lib Library address\n   * @param _eid Endpoint ID\n   * @param _configType Configuration type\n   * @return config Configuration bytes\n   */\n  function getConfig(\n    address _oappAddress,\n    address _lib,\n    uint32 _eid,\n    uint32 _configType\n  ) external view returns (bytes memory config);\n\n  /**\n   * @dev Check if path is initialized\n   * @param _oappAddress OApp address\n   * @param _eid Endpoint ID\n   * @param _sender Sender address\n   * @return initialized Whether the path is initialized\n   */\n  function isInitialized(address _oappAddress, uint32 _eid, bytes32 _sender) external view returns (bool initialized);\n}\n"
    },
    "contracts/interfaces/external/layerzero/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @title ILayerZeroReceiver\n * @dev Interface for contracts that receive LayerZero messages\n *\n * Defines callback functionality for processing cross-chain messages\n * Essential for contracts that receive LayerZero communications in OmniDragon\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface ILayerZeroReceiver {\n  /**\n   * @dev Handle incoming LayerZero message\n   * @param _origin Origin information\n   * @param _guid Message GUID\n   * @param _message Message payload\n   * @param _executor Executor address\n   * @param _extraData Extra data\n   */\n  function lzReceive(\n    Origin calldata _origin,\n    bytes32 _guid,\n    bytes calldata _message,\n    address _executor,\n    bytes calldata _extraData\n  ) external;\n}\n\n/**\n * @dev Origin information for incoming messages\n */\nstruct Origin {\n  uint32 srcEid; // Source endpoint ID\n  bytes32 sender; // Source sender address\n  uint64 nonce; // Message nonce\n}\n"
    },
    "contracts/interfaces/external/layerzero/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title ILayerZeroUserApplicationConfig\n * @dev Interface for LayerZero user application configuration\n *\n * Enables configuration and management of LayerZero messaging parameters\n * Essential for customizing cross-chain communication behavior in OmniDragon\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.18;\n\ninterface ILayerZeroUserApplicationConfig {\n    /**\n     * @notice Set the configuration for the LayerZero endpoint\n     * @param _version The messaging library version\n     * @param _chainId The destination chain ID\n     * @param _configType Type of configuration\n     * @param _config The configuration data\n     */\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint256 _configType,\n        bytes calldata _config\n    ) external;\n\n    /**\n     * @notice Set the send messaging library version\n     * @param _version The messaging library version\n     */\n    function setSendVersion(uint16 _version) external;\n\n    /**\n     * @notice Set the receive messaging library version\n     * @param _version The messaging library version\n     */\n    function setReceiveVersion(uint16 _version) external;\n\n    /**\n     * @notice Force resume a message that got stuck because of a failed send\n     * @param _srcChainId The source chain ID\n     * @param _srcAddress The source address\n     * @param _nonce The nonce of the message\n     * @param _payload The message payload\n     */\n    function forceResumeReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n\n    /**\n     * @notice Get the configuration of the LayerZero messaging library of the specified version\n     * @param _version - messaging library version\n     * @param _chainId - the chainId for the pending config change\n     * @param _configType - type of configuration. every messaging library has its own convention\n     */\n    function getConfig(uint16 _version, uint16 _chainId, uint256 _configType) external view returns (bytes memory);\n\n    /**\n     * @notice Get the send() LayerZero messaging library version\n     */\n    function getSendVersion() external view returns (uint16);\n\n    /**\n     * @notice Get the lzReceive() LayerZero messaging library version\n     */\n    function getReceiveVersion() external view returns (uint16);\n}\n"
    },
    "contracts/interfaces/external/layerzero/IOAppPeerManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IOAppPeerManager\n * @dev LayerZero v2 peer management interface for OmniDragon ecosystem\n *\n * Provides standardized peer management across all OmniDragon contracts\n * Enables seamless cross-chain communication setup and maintenance\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IOAppPeerManager {\n    // Events\n    event PeerSet(uint32 indexed eid, bytes32 indexed peer);\n    event PeerRemoved(uint32 indexed eid, bytes32 indexed peer);\n    event DefaultDelegateSet(address indexed delegate);\n    event EmergencyPeerRemoval(uint32 indexed eid, string reason);\n\n    // Errors\n    error PeerNotSet(uint32 eid);\n    error PeerAlreadySet(uint32 eid, bytes32 peer);\n    error InvalidPeer(bytes32 peer);\n    error InvalidEndpointId(uint32 eid);\n    error UnauthorizedPeer(uint32 eid, bytes32 sender);\n    error DelegateNotSet();\n\n    /**\n     * @notice Set peer address for a specific endpoint\n     * @param _eid Endpoint ID (uint32 for LayerZero v2)\n     * @param _peer Peer contract address as bytes32\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Set multiple peers in a single transaction\n     * @param _eids Array of endpoint IDs\n     * @param _peers Array of peer addresses (must match _eids length)\n     */\n    function setPeers(uint32[] calldata _eids, bytes32[] calldata _peers) external;\n\n    /**\n     * @notice Remove peer for a specific endpoint\n     * @param _eid Endpoint ID to remove peer for\n     */\n    function removePeer(uint32 _eid) external;\n\n    /**\n     * @notice Get peer address for an endpoint\n     * @param _eid Endpoint ID\n     * @return peer Peer address as bytes32\n     */\n    function getPeer(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Check if peer is set for an endpoint\n     * @param _eid Endpoint ID\n     * @return isSet True if peer is set\n     */\n    function isPeerSet(uint32 _eid) external view returns (bool isSet);\n\n    /**\n     * @notice Check if sender is authorized peer for an endpoint\n     * @param _eid Endpoint ID\n     * @param _sender Sender address to check\n     * @return isAuthorized True if sender is authorized\n     */\n    function isAuthorizedPeer(uint32 _eid, bytes32 _sender) external view returns (bool isAuthorized);\n\n    /**\n     * @notice Get all configured endpoint IDs\n     * @return eids Array of configured endpoint IDs\n     */\n    function getConfiguredEids() external view returns (uint32[] memory eids);\n\n    /**\n     * @notice Get peer configuration for multiple endpoints\n     * @param _eids Array of endpoint IDs to query\n     * @return peers Array of peer addresses\n     */\n    function getPeers(uint32[] calldata _eids) external view returns (bytes32[] memory peers);\n\n    /**\n     * @notice Emergency function to remove all peers\n     * @dev Only for emergency situations - requires special authorization\n     */\n    function emergencyRemoveAllPeers() external;\n\n    /**\n     * @notice Helper to convert address to bytes32\n     * @param _addr Address to convert\n     * @return bytes32 representation\n     */\n    function addressToBytes32(address _addr) external pure returns (bytes32);\n\n    /**\n     * @notice Helper to convert bytes32 to address\n     * @param _bytes Bytes32 to convert\n     * @return address representation\n     */\n    function bytes32ToAddress(bytes32 _bytes) external pure returns (address);\n} "
    },
    "contracts/interfaces/external/layerzero/IReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IReceiver\n * @dev Interface for LayerZero message receiving functionality\n *\n * Defines callback interface for processing incoming LayerZero messages\n * Essential for contracts that need to receive cross-chain communications\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.18;\n\ninterface IReceiver {\n    /**\n     * @notice Called when a message is received from LayerZero\n     * @param _srcChainId The source chain ID\n     * @param _srcAddress The source address from the source chain\n     * @param _nonce A number that indicates the order of messages\n     * @param _payload The message payload\n     */\n    function lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) external;\n}\n"
    },
    "contracts/interfaces/external/sonic/ISonicFeeMRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title ISonicFeeMRegistry\n * @dev Interface for Sonic FeeM (Fee Monetization) Registry\n */\ninterface ISonicFeeMRegistry {\n    /**\n     * @dev Self-register for fee monetization\n     * @param registrationValue Magic value required for registration (143)\n     */\n    function selfRegister(uint256 registrationValue) external;\n    \n    /**\n     * @dev Check if a contract is registered for fee monetization\n     * @param contractAddress Contract to check\n     * @return registered Whether the contract is registered\n     */\n    function isRegistered(address contractAddress) external view returns (bool registered);\n    \n    /**\n     * @dev Get registration details\n     * @param contractAddress Contract to check\n     * @return registrationBlock Block number when registered\n     * @return isActive Whether the registration is active\n     */\n    function getRegistrationDetails(address contractAddress) \n        external \n        view \n        returns (uint256 registrationBlock, bool isActive);\n} "
    },
    "contracts/interfaces/external/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IUniswapV2Pair\n * @dev Minimal interface for Uniswap V2 Pair interactions\n */\ninterface IUniswapV2Pair {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    \n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    \n    function price0CumulativeLast() external view returns (uint256);\n    function price1CumulativeLast() external view returns (uint256);\n    function kLast() external view returns (uint256);\n    \n    function mint(address to) external returns (uint256 liquidity);\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    \n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n} "
    },
    "contracts/interfaces/external/uniswap/v2/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n} "
    },
    "contracts/interfaces/factory/ICREATE2FactoryWithOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title ICREATE2FactoryWithOwnership\n * @notice Interface for CREATE2 factory that automatically transfers ownership of deployed contracts\n */\ninterface ICREATE2FactoryWithOwnership {\n    // Events\n    event ContractDeployed(\n        address indexed deployer,\n        address indexed deployed,\n        bytes32 indexed salt,\n        string contractType\n    );\n    \n    /**\n     * @notice Deploy a contract using CREATE2 with automatic ownership transfer\n     * @param bytecode The bytecode of the contract to deploy\n     * @param salt The salt for deterministic deployment\n     * @param contractType A string identifier for the contract type\n     * @return deployed The address of the deployed contract\n     */\n    function deploy(\n        bytes memory bytecode,\n        bytes32 salt,\n        string memory contractType\n    ) external returns (address deployed);\n    \n    /**\n     * @notice Deploy with auto-generated salt\n     * @param bytecode The bytecode of the contract to deploy\n     * @param contractType A string identifier for the contract type\n     * @return deployed The address of the deployed contract\n     */\n    function deployWithAutoSalt(\n        bytes memory bytecode,\n        string memory contractType\n    ) external returns (address deployed);\n    \n    /**\n     * @notice Compute the deployment address for given bytecode and salt\n     * @param salt The salt for deterministic deployment\n     * @param bytecodeHash The keccak256 hash of the bytecode\n     * @return The computed address\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash\n    ) external view returns (address);\n    \n    /**\n     * @notice Get all deployments by a specific deployer\n     * @param deployer The address of the deployer\n     * @return An array of deployed contract addresses\n     */\n    function getDeployments(address deployer) external view returns (address[] memory);\n    \n    /**\n     * @notice Batch deploy multiple contracts\n     * @param bytecodes Array of bytecodes to deploy\n     * @param salts Array of salts for each deployment\n     * @param types Array of contract type identifiers\n     * @return deployed Array of deployed contract addresses\n     */\n    function batchDeploy(\n        bytes[] memory bytecodes,\n        bytes32[] memory salts,\n        string[] memory types\n    ) external returns (address[] memory deployed);\n    \n    /**\n     * @notice Emergency function to transfer ownership of a deployed contract\n     * @dev Only callable by factory owner\n     * @param deployed The deployed contract address\n     * @param newOwner The new owner address\n     */\n    function emergencyTransferOwnership(\n        address deployed,\n        address newOwner\n    ) external;\n    \n    // View functions for tracking\n    function deploymentsByDeployer(address deployer, uint256 index) external view returns (address);\n    function isDeployedContract(address deployed) external view returns (bool);\n    function deploymentBySalt(bytes32 salt) external view returns (address);\n    function contractTypes(address deployed) external view returns (string memory);\n} "
    },
    "contracts/interfaces/factory/IOmniDragonTokenDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IOmniDragonTokenDeployer\n * @dev Interface for the specialized omniDRAGON token deployer\n */\ninterface IOmniDragonTokenDeployer {\n    \n    // ======== STRUCTS ========\n    struct DeploymentResult {\n        address deployedAddress;\n        bytes32 salt;\n        bool ownershipTransferred;\n    }\n    \n    // ======== EVENTS ========\n    event TokenDeployed(\n        address indexed token,\n        address indexed owner,\n        bytes32 indexed salt,\n        string deploymentType\n    );\n    \n    event OwnershipTransferred(\n        address indexed token,\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    \n    // ======== CORE DEPLOYMENT FUNCTIONS ========\n    \n    /**\n     * @dev Deploy omniDRAGON token with immediate ownership transfer\n     * @param bytecode The compiled bytecode of the omniDRAGON contract\n     * @param newOwner The address that should own the deployed token\n     * @param salt Custom salt for CREATE2 (use 0x0 for auto-generated)\n     * @return result Deployment result with address and ownership status\n     */\n    function deployWithOwnership(\n        bytes memory bytecode,\n        address newOwner,\n        bytes32 salt\n    ) external returns (DeploymentResult memory result);\n    \n    /**\n     * @dev Deploy universal omniDRAGON (same address on all chains)\n     * @param bytecode The compiled bytecode of the omniDRAGON contract\n     * @param newOwner The address that should own the deployed token\n     * @return result Deployment result with address and ownership status\n     */\n    function deployUniversal(\n        bytes memory bytecode,\n        address newOwner\n    ) external returns (DeploymentResult memory result);\n    \n    /**\n     * @dev Deploy chain-specific omniDRAGON (different address per chain)\n     * @param bytecode The compiled bytecode of the omniDRAGON contract\n     * @param newOwner The address that should own the deployed token\n     * @return result Deployment result with address and ownership status\n     */\n    function deployChainSpecific(\n        bytes memory bytecode,\n        address newOwner\n    ) external returns (DeploymentResult memory result);\n    \n    // ======== SALT GENERATION ========\n    \n    /**\n     * @dev Generate universal salt (same on all chains)\n     * @param contractName Name of the contract\n     * @param version Version string\n     * @return salt Universal salt\n     */\n    function generateUniversalSalt(\n        string memory contractName,\n        string memory version\n    ) external pure returns (bytes32 salt);\n    \n    /**\n     * @dev Generate chain-specific salt\n     * @param contractName Name of the contract\n     * @param version Version string\n     * @param chainId Chain ID\n     * @return salt Chain-specific salt\n     */\n    function generateChainSpecificSalt(\n        string memory contractName,\n        string memory version,\n        uint256 chainId\n    ) external pure returns (bytes32 salt);\n    \n    /**\n     * @dev Generate custom salt with timestamp\n     * @param owner Owner address\n     * @param timestamp Timestamp\n     * @return salt Custom salt\n     */\n    function generateSalt(address owner, uint256 timestamp) external pure returns (bytes32 salt);\n    \n    // ======== PREDICTION FUNCTIONS ========\n    \n    /**\n     * @dev Predict deployment address\n     * @param bytecode Contract bytecode\n     * @param salt Salt for CREATE2\n     * @return predicted Predicted deployment address\n     */\n    function predictAddress(\n        bytes memory bytecode,\n        bytes32 salt\n    ) external view returns (address predicted);\n    \n    /**\n     * @dev Predict universal deployment address\n     * @param bytecode Contract bytecode\n     * @return predicted Predicted address\n     * @return salt Universal salt used\n     */\n    function predictUniversalAddress(\n        bytes memory bytecode\n    ) external view returns (address predicted, bytes32 salt);\n    \n    /**\n     * @dev Predict chain-specific deployment address\n     * @param bytecode Contract bytecode\n     * @return predicted Predicted address\n     * @return salt Chain-specific salt used\n     */\n    function predictChainSpecificAddress(\n        bytes memory bytecode\n    ) external view returns (address predicted, bytes32 salt);\n    \n    // ======== VIEW FUNCTIONS ========\n    \n    /**\n     * @dev Check if token was deployed by this contract\n     * @param token Token address\n     * @return deployed Whether token was deployed by us\n     */\n    function isTokenDeployedByUs(address token) external view returns (bool deployed);\n    \n    /**\n     * @dev Get deployment info by salt\n     * @param salt Deployment salt\n     * @return tokenAddress Address of deployed token\n     */\n    function getDeploymentBySalt(bytes32 salt) external view returns (address tokenAddress);\n    \n    /**\n     * @dev Get deployment count\n     * @return count Number of tokens deployed\n     */\n    function deploymentCount() external view returns (uint256 count);\n    \n    // ======== EMERGENCY FUNCTIONS ========\n    \n    /**\n     * @dev Emergency function to transfer ownership of a token we deployed\n     * @param token Token address\n     * @param newOwner New owner address\n     */\n    function emergencyTransferOwnership(\n        address token,\n        address newOwner\n    ) external;\n} "
    },
    "contracts/interfaces/governance/fees/IDragonRevenueDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDragonRevenueDistributor\n * @dev Minimal stub interface for testing - handles veDRAGON fee distribution\n */\ninterface IDragonRevenueDistributor {\n    function distributeGeneralFees(address token, uint256 amount) external;\n    function depositFees(uint256 partnerId, address token, uint256 amount) external payable;\n    function claimRewards(address user) external;\n    function getClaimableRewards(address user) external view returns (uint256);\n} "
    },
    "contracts/interfaces/governance/partners/IDragonPartnerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IDragonPartnerFactory\n * @dev Interface for the DragonPartnerFactory contract which creates partner pool contracts\n *\n * Enables partner onboarding and pool creation for ecosystem partnerships\n * Facilitates creation and management of partner-specific liquidity pools\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IDragonPartnerFactory {\n    // Events\n    event PartnerPoolCreated(uint256 indexed partnerId, address indexed partnerPool, address indexed partnerAddress);\n    event PartnerPoolWhitelisted(address indexed partnerPool);\n    event PartnerPoolRemoved(address indexed partnerPool);\n\n    /**\n     * @dev Creates a new partner pool\n     * @param _partnerId ID of the partner\n     * @param _boostBasisPoints Initial boost in basis points (e.g., 690 = 6.9%)\n     * @return pool Address of the newly created pool\n     */\n    function createPartnerPool(uint256 _partnerId, uint256 _boostBasisPoints) external returns (address pool);\n\n    /**\n     * @dev Gets a partner pool address by partner ID\n     * @param _partnerId ID of the partner\n     * @return pool Address of the partner pool\n     */\n    function getPartnerPool(uint256 _partnerId) external view returns (address pool);\n\n    /**\n     * @dev Gets the partner ID for a pool address\n     * @param _pool Address of the partner pool\n     * @return partnerId ID of the partner\n     */\n    function getPoolPartnerId(address _pool) external view returns (uint256 partnerId);\n\n    /**\n     * @dev Checks if a pool address is a valid partner pool\n     * @param _pool Address to check\n     * @return isValid Whether the address is a valid partner pool\n     */\n    function isValidPartnerPool(address _pool) external view returns (bool isValid);\n\n    /**\n     * @dev Whitelists an externally created partner pool\n     * @param _partnerId ID of the partner\n     * @param _pool Address of the externally created pool\n     */\n    function whitelistPartnerPool(uint256 _partnerId, address _pool) external;\n\n    /**\n     * @dev Gets the partner pool at a specific index\n     * @param _index Index of the partner pool\n     * @return pool Address of the partner pool\n     */\n    function partnerPools(uint256 _index) external view returns (address pool);\n\n    /**\n     * @dev Gets the total number of partner pools\n     * @return count Number of pools\n     */\n    function getPartnerPoolCount() external view returns (uint256 count);\n}\n"
    },
    "contracts/interfaces/governance/partners/IDragonPartnerFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IDragonPartnerFeeDistributor {\n    function depositFees(uint256 _partnerId, address _token, uint256 _amount) external;\n    function recordVote(address voter, uint256 partnerId, uint256 votes) external;\n    function getUserClaimable(uint256 _period, uint256 _partnerId, address _user, address _token) external view returns (uint256);\n    function checkAndRollPeriod() external;\n    function setProtocolFee(uint256 _fee) external;\n} "
    },
    "contracts/interfaces/governance/partners/IDragonPartnerPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IDragonPartnerPool\n * @dev Interface for the DragonPartnerPool contract which represents a partner pool\n *\n * Manages individual partner pools receiving votes and providing probability boosts\n * Core component for partner-based lottery enhancements and fee sharing\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IDragonPartnerPool {\n    // Events\n    event BoostUpdated(uint256 oldBoostBasisPoints, uint256 newBoostBasisPoints);\n    event JackpotEntryAdded(address indexed user, uint256 amount);\n    event FeeDistributed(address indexed token, address indexed partner, uint256 amount);\n\n    /**\n     * @dev Initializes a new partner pool\n     * @param _partnerId ID of the partner\n     * @param _partnerAddress Address of the partner\n     * @param _factory Address of the factory that created this pool\n     * @param _initialBoostBasisPoints Initial boost in basis points\n     */\n    function initialize(\n        uint256 _partnerId,\n        address _partnerAddress,\n        address _factory,\n        uint256 _initialBoostBasisPoints\n    ) external;\n\n    /**\n     * @dev Updates the probability boost for this partner pool\n     * @param _newBoostBasisPoints New boost in basis points\n     */\n    function updateProbabilityBoost(uint256 _newBoostBasisPoints) external;\n\n    /**\n     * @dev Allows a user to enter the jackpot via this partner pool\n     * @param _amount Amount to base the entry on\n     */\n    function enterJackpot(uint256 _amount) external;\n\n    /**\n     * @dev Distribute rewards to this partner pool\n     * @param _token Token address to distribute\n     * @param _amount Amount to distribute\n     */\n    function distributeRewards(address _token, uint256 _amount) external;\n\n    /**\n     * @dev Gets the current boost in basis points\n     * @return boostBasisPoints Current boost in basis points\n     */\n    function getBoostBasisPoints() external view returns (uint256 boostBasisPoints);\n\n    /**\n     * @dev Gets the partner address\n     * @return address Partner address\n     */\n    function partnerAddress() external view returns (address);\n\n    /**\n     * @dev Gets the partner ID\n     * @return partnerId ID of the partner\n     */\n    function partnerId() external view returns (uint256 partnerId);\n}\n"
    },
    "contracts/interfaces/governance/partners/IDragonPartnerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Interface: IDragonPartnerRegistry\n *\n * Manages partner registration and configuration for the OmniDragon ecosystem\n * Defines partnership structures, fee sharing, and probability boost mechanisms\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IDragonPartnerRegistry\n * @dev Interface for the DragonPartnerRegistry contract\n */\ninterface IDragonPartnerRegistry {\n    /**\n     * @dev Partner structure\n     */\n    struct Partner {\n        string name;\n        uint256 feeShare; // Basis points (e.g., 5000 = 50%)\n        uint256 probabilityBoost; // Basis points (e.g., 200 = 2%)\n        bool isActive;\n    }\n\n    /**\n     * @dev Get partner at specified index\n     * @param index The index in the partner list\n     * @return Partner address\n     */\n    function partnerList(uint256 index) external view returns (address);\n\n    /**\n     * @dev Get partner data\n     * @param partnerAddress Partner address\n     * @return name The partner name\n     * @return feeShare The fee share in basis points\n     * @return probabilityBoost The probability boost in basis points\n     * @return isActive Whether the partner is active\n     */\n    function partners(address partnerAddress) external view returns (\n        string memory name,\n        uint256 feeShare,\n        uint256 probabilityBoost,\n        bool isActive\n    );\n\n    /**\n     * @dev Check if a distributor is authorized\n     * @param distributor Distributor address\n     * @return Authorization status\n     */\n    function authorizedDistributors(address distributor) external view returns (bool);\n\n    /**\n     * @dev Get default probability boost\n     * @return Default probability boost in basis points\n     */\n    function defaultProbabilityBoost() external view returns (uint256);\n\n    /**\n     * @dev Set the default probability boost for all partners\n     * @param boost Default probability boost in basis points (e.g., 690 = 6.9%)\n     */\n    function setDefaultProbabilityBoost(uint256 boost) external;\n\n    /**\n     * @dev Add a new partner to the registry with default probability boost\n     * @param partnerAddress Address of the partner\n     * @param name Name of the partner\n     * @param feeShare Fee share in basis points (e.g., 5000 = 50%)\n     */\n    function addPartnerWithDefaultBoost(\n        address partnerAddress,\n        string memory name,\n        uint256 feeShare\n    ) external;\n\n    /**\n     * @dev Add a new partner to the registry\n     * @param partnerAddress Address of the partner\n     * @param name Name of the partner\n     * @param feeShare Fee share in basis points (e.g., 5000 = 50%)\n     * @param probabilityBoost Probability boost in basis points (e.g., 200 = 2%)\n     */\n    function addPartner(\n        address partnerAddress,\n        string memory name,\n        uint256 feeShare,\n        uint256 probabilityBoost\n    ) external;\n\n    /**\n     * @dev Update an existing partner's details\n     * @param partnerAddress Address of the partner\n     * @param name New name of the partner\n     * @param feeShare New fee share in basis points\n     * @param probabilityBoost New probability boost in basis points\n     */\n    function updatePartner(\n        address partnerAddress,\n        string memory name,\n        uint256 feeShare,\n        uint256 probabilityBoost\n    ) external;\n\n    /**\n     * @dev Update an existing partner's details with default probability boost\n     * @param partnerAddress Address of the partner\n     * @param name New name of the partner\n     * @param feeShare New fee share in basis points\n     */\n    function updatePartnerWithDefaultBoost(\n        address partnerAddress,\n        string memory name,\n        uint256 feeShare\n    ) external;\n\n    /**\n     * @dev Deactivate a partner\n     * @param partnerAddress Address of the partner to deactivate\n     */\n    function deactivatePartner(address partnerAddress) external;\n\n    /**\n     * @dev Set authorization for a distributor\n     * @param distributor Address of the distributor\n     * @param authorized Whether the distributor is authorized\n     */\n    function setDistributorAuthorization(address distributor, bool authorized) external;\n\n    /**\n     * @dev Check if a partner is active\n     * @param partnerAddress Address of the partner\n     * @return True if partner is active\n     */\n    function isPartnerActive(address partnerAddress) external view returns (bool);\n\n    /**\n     * @dev Get partner details\n     * @param partnerAddress Address of the partner\n     * @return name Name of the partner\n     * @return feeShare Fee share in basis points\n     * @return probabilityBoost Probability boost in basis points\n     * @return isActive Whether the partner is active\n     */\n    function getPartnerDetails(address partnerAddress) external view returns (\n        string memory name,\n        uint256 feeShare,\n        uint256 probabilityBoost,\n        bool isActive\n    );\n\n    /**\n     * @dev Get the total number of partners\n     * @return Number of partners\n     */\n    function getPartnerCount() external view returns (uint256);\n\n    /**\n     * @dev Check if a distributor is authorized\n     * @param distributor Address of the distributor\n     * @return True if the distributor is authorized\n     */\n    function isDistributorAuthorized(address distributor) external view returns (bool);\n\n    function isWhitelistedPartner(address partner) external view returns (bool);\n    function getPartnerBoost(address partner) external view returns (uint256);\n    function registerPartner(address partner, uint256 boost) external;\n    function removePartner(address partner) external;\n}\n"
    },
    "contracts/interfaces/governance/partners/IDragonRevenueDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IDragonRevenueDistributor\n * @dev Interface for the DragonRevenueDistributor contract which distributes fees\n *\n * Manages fee distribution to voters based on voting weight and partner participation\n * Facilitates democratic revenue sharing within the OmniDragon ecosystem\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IDragonRevenueDistributor {\n    // Events\n    event VotesRecorded(uint256 indexed period, uint256 indexed partnerId, address indexed user, uint256 votes);\n    event FeesDeposited(uint256 indexed period, uint256 indexed partnerId, address indexed token, uint256 amount);\n    event FeesClaimed(uint256 indexed period, uint256 indexed partnerId, address indexed user, address token, uint256 amount);\n    event PeriodRolled(uint256 indexed oldPeriod, uint256 indexed newPeriod);\n    event GeneralFeesDistributed(address indexed token, uint256 amount);\n\n    /**\n     * @dev Records votes for a partner by a user\n     * @param _partnerId ID of the partner being voted for\n     * @param _user Address of the voter\n     * @param _votes Amount of votes cast\n     */\n    function recordVotes(uint256 _partnerId, address _user, uint256 _votes) external;\n\n    /**\n     * @dev Deposits fees for a specific partner\n     * @param _partnerId ID of the partner\n     * @param _token Token address of the fee\n     * @param _amount Amount of fees\n     */\n    function depositFees(uint256 _partnerId, address _token, uint256 _amount) external;\n\n    /**\n     * @dev Distributes general fees not associated with a specific partner\n     * @param _token Token address of the fee\n     * @param _amount Amount of fees\n     */\n    function distributeGeneralFees(address _token, uint256 _amount) external;\n\n    /**\n     * @dev Claims fees for a specific period, partner, and token\n     * @param _period Period to claim for\n     * @param _partnerId ID of the partner\n     * @param _token Token address to claim\n     * @return amount Amount claimed\n     */\n    function claimFees(uint256 _period, uint256 _partnerId, address _token) external returns (uint256 amount);\n\n    /**\n     * @dev Gets the amount of fees claimable by a user\n     * @param _period Period to check\n     * @param _partnerId ID of the partner\n     * @param _user Address of the user\n     * @param _token Token address to check\n     * @return amount Claimable amount\n     */\n    function getUserClaimable(uint256 _period, uint256 _partnerId, address _user, address _token) external view returns (uint256 amount);\n\n    /**\n     * @dev Gets the current period\n     * @return period Current period\n     */\n    function getCurrentPeriod() external view returns (uint256 period);\n\n    /**\n     * @dev Checks and rolls to a new period if needed\n     * @return newPeriod The current period after checking\n     */\n    function checkAndRollPeriod() external returns (uint256 newPeriod);\n\n    /**\n     * @dev Gets the total votes for a partner in a period\n     * @param _period Period to check\n     * @param _partnerId ID of the partner\n     * @return votes Total votes\n     */\n    function getPartnerTotalVotes(uint256 _period, uint256 _partnerId) external view returns (uint256 votes);\n\n    /**\n     * @dev Gets a user's votes for a partner in a period\n     * @param _period Period to check\n     * @param _partnerId ID of the partner\n     * @param _user Address of the user\n     * @return votes User's votes\n     */\n    function getUserVotes(uint256 _period, uint256 _partnerId, address _user) external view returns (uint256 votes);\n}\n"
    },
    "contracts/interfaces/governance/partners/IveDRAGONBoostManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IveDRAGONBoostManager\n * @dev Interface for the veDRAGON boost manager contract\n *\n * Provides additional functionality for veDRAGON holders including boosts for protocol actions\n * Manages partner probability boosts and voting-based lottery enhancements\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IveDRAGONBoostManager\n * @dev Interface for the veDRAGON boost manager contract\n *\n * Provides additional functionality for veDRAGON holders including boosts for protocol actions\n * Manages partner probability boosts and voting-based lottery enhancements\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IveDRAGONBoostManager {\n    // === Events ===\n    event BoostCalculated(address indexed user, uint256 boost);\n\n    // === View Functions ===\n    /**\n     * @dev Get the probability boost for a partner\n     * @param partnerId Partner ID\n     * @return Probability boost in basis points (e.g., 100 = 1%)\n     */\n    function getPartnerProbabilityBoost(uint256 partnerId) external view returns (uint256);\n\n    // === Action Functions ===\n    /**\n     * @dev Calculate boost for a user and emit an event\n     * @param user User address\n     * @return Boost multiplier\n     */\n    function getBoostWithEvent(address user) external returns (uint256);\n\n    /**\n     * @dev Enter jackpot with a boosted amount\n     * @param user User address\n     * @param amount Base amount to boost\n     * @return Boosted amount\n     */\n    function enterJackpotWithBoost(address user, uint256 amount) external returns (uint256);\n\n    /**\n     * @dev Vote for a partner to allocate probability boost\n     * @param partnerId Partner ID\n     * @param weight Voting weight (optional, may be unused in some implementations)\n     */\n    function voteForPartner(uint256 partnerId, uint256 weight) external;\n}\n"
    },
    "contracts/interfaces/lottery/IOmniDragonLotteryManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IOmniDragonLotteryManager\n * @dev Interface for the unified OmniDragon Lottery Manager\n */\ninterface IOmniDragonLotteryManager {\n    /**\n     * @dev Lottery entry structure\n     */\n    struct LotteryEntry {\n        address user;                    // User address\n        uint256 swapAmountUSD;          // Swap amount in USD (scaled by 1e18)\n        uint256 userVotingPower;        // User's veDRAGON voting power\n        uint256 probabilityBps;         // Calculated win probability in basis points\n        uint256 timestamp;              // Entry timestamp\n        uint256 randomnessRequestId;    // Request ID for randomness\n        bool processed;                 // Whether entry has been processed\n        bool won;                       // Whether user won the lottery\n        uint256 payoutAmount;           // Payout amount if won\n    }\n\n    /**\n     * @dev Create a lottery entry for a user's swap\n     * @param user User address\n     * @param swapAmountUSD Swap amount in USD (scaled by 1e18)\n     * @param userVotingPower User's veDRAGON voting power\n     * @return entryId The created lottery entry ID (0 if entry not created)\n     */\n    function createLotteryEntry(\n        address user,\n        uint256 swapAmountUSD,\n        uint256 userVotingPower\n    ) external returns (uint256 entryId);\n\n    /**\n     * @dev Process a lottery entry (backward compatibility method)\n     * @param user User address\n     * @param amount Swap amount (will be treated as USD amount)\n     * @dev This is a simplified version for backward compatibility\n     */\n    function processEntry(address user, uint256 amount) external;\n\n    /**\n     * @dev Process a lottery entry with randomness (called by RandomnessProvider)\n     * @param randomnessRequestId The randomness request ID\n     * @param randomValue Secure random value from VRF\n     */\n    function fulfillRandomness(uint256 randomnessRequestId, uint256 randomValue) external;\n\n    /**\n     * @dev Get lottery entry details\n     * @param entryId Lottery entry ID\n     * @return entry Lottery entry details\n     */\n    function getLotteryEntry(uint256 entryId) external view returns (LotteryEntry memory entry);\n\n    /**\n     * @dev Get user's lottery entries\n     * @param user User address\n     * @return entryIds Array of entry IDs for the user\n     */\n    function getUserEntries(address user) external view returns (uint256[] memory entryIds);\n\n    /**\n     * @dev Get user's pending entries count\n     * @param user User address\n     * @return count Number of pending entries\n     */\n    function getUserPendingEntries(address user) external view returns (uint256 count);\n\n    /**\n     * @dev Get lottery statistics\n     * @return totalEntries Total entries created\n     * @return totalWins Total wins\n     * @return totalPayouts Total payout amount\n     * @return winRate Win rate in basis points\n     */\n    function getLotteryStats() external view returns (\n        uint256 totalEntries,\n        uint256 totalWins,\n        uint256 totalPayouts,\n        uint256 winRate\n    );\n\n    /**\n     * @dev Check if user can create lottery entry\n     * @param user User address\n     * @return canCreate Whether user can create entry\n     * @return reason Reason if cannot create\n     */\n    function canCreateEntry(address user) external view returns (bool canCreate, string memory reason);\n\n    // Events\n    event LotteryEntryCreated(\n        uint256 indexed entryId,\n        address indexed user,\n        uint256 swapAmountUSD,\n        uint256 probabilityBps,\n        uint256 randomnessRequestId\n    );\n\n    event LotteryProcessed(\n        uint256 indexed entryId,\n        address indexed user,\n        bool won,\n        uint256 randomValue,\n        uint256 payoutAmount\n    );\n\n    event LotteryWin(\n        uint256 indexed entryId,\n        address indexed winner,\n        uint256 swapAmountUSD,\n        uint256 probabilityBps,\n        uint256 payoutAmount\n    );\n}\n"
    },
    "contracts/interfaces/oracles/IDragonMarketController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDragonMarketController\n * @dev Interface for Dragon Market Controller for adaptive fee management\n */\ninterface IDragonMarketController {\n  function calculateDynamicFees(\n    address user,\n    uint8 transactionType,\n    uint256 amount,\n    uint256 marketVolatility,\n    uint256 liquidityDepth\n  ) external view returns (uint256 jackpotFee, uint256 veDRAGONFee, uint256 burnFee, uint256 totalFee);\n  \n  function updateMarketData(address token, uint256 volume, uint256 price, uint256 timestamp) external;\n  function setAdaptiveFeeParameters(uint256 baseMultiplier, uint256 volatilityThreshold, uint256 liquidityThreshold) external;\n  function isAdaptiveFeesEnabled() external view returns (bool);\n} "
    },
    "contracts/interfaces/oracles/IOmniDragonPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IOmniDragonPriceOracle\n * @dev Interface for the pure OmniDragon Price Oracle\n */\ninterface IOmniDragonPriceOracle {\n    /**\n     * @dev Oracle type enumeration\n     */\n    enum OracleType { CHAINLINK, API3, BAND, PYTH, REDSTONE, STORK }\n\n    /**\n     * @dev Oracle source structure\n     */\n    struct OracleSource {\n        address oracleAddress;\n        OracleType oracleType;\n        bool isActive;\n        uint8 decimals;\n        bytes32 priceId; // Used by Pyth and STORK\n        string baseSymbol; // Used by Band Protocol\n        string quoteSymbol; // Used by Band Protocol\n    }\n\n    /**\n     * @dev Price data structure\n     */\n    struct PriceData {\n        int256 price;\n        uint256 timestamp;\n        uint256 roundId;\n    }\n\n    /**\n     * @dev Get current aggregated price\n     * @return price Aggregated price in 8 decimals\n     * @return success Whether price aggregation was successful\n     * @return timestamp Timestamp of the price\n     */\n    function getAggregatedPrice() external view returns (int256 price, bool success, uint256 timestamp);\n\n    /**\n     * @dev Update and get fresh aggregated price (state-changing)\n     * @return price Aggregated price in 8 decimals\n     * @return success Whether price aggregation was successful\n     */\n    function updateAndGetPrice() external returns (int256 price, bool success);\n\n    /**\n     * @dev Get market condition score (0-100)\n     * @return score Market condition score based on volatility and volume\n     */\n    function getMarketConditionScore() external view returns (uint256 score);\n\n    /**\n     * @dev Update market conditions with new swap data\n     * @param swapAmount Swap amount to add to statistics\n     */\n    function updateMarketConditions(uint256 swapAmount) external;\n\n    /**\n     * @dev Get oracle configuration for a specific oracle ID\n     * @param _oracleId The oracle ID to query\n     */\n    function getOracleConfig(uint8 _oracleId) external view returns (\n        address oracleAddress,\n        OracleType oracleType,\n        bool isActive,\n        uint8 decimals,\n        bytes32 priceId,\n        string memory baseSymbol,\n        string memory quoteSymbol\n    );\n\n    /**\n     * @dev Get market statistics\n     */\n    function getMarketStats() external view returns (\n        uint256 totalVolume,\n        uint256 totalSwaps,\n        uint256 avgSwapAmount,\n        uint256 priceChanges,\n        uint256 significantChanges,\n        uint256 lastUpdate\n    );\n\n    /**\n     * @dev Get last valid price for an oracle\n     * @param _oracleId Oracle ID\n     */\n    function getLastValidPrice(uint8 _oracleId) external view returns (PriceData memory);\n\n    // Events\n    event OracleAdded(uint8 indexed oracleId, address oracleAddress, OracleType oracleType);\n    event OracleUpdated(uint8 indexed oracleId, address oracleAddress, bool isActive);\n    event MinimumOracleResponsesUpdated(uint8 oldValue, uint8 newValue);\n    event NativeTokenConfigured(string nativeSymbol, string quoteSymbol);\n    event PriceAggregated(int256 price, uint256 timestamp, uint8 oracleCount);\n    event MarketConditionUpdated(uint256 swapVolume, uint256 swapCount, uint256 marketScore);\n    event CircuitBreakerTriggered(uint8 indexed oracleId, int256 oldPrice, int256 newPrice);\n}\n"
    },
    "contracts/interfaces/oracles/IOmniDragonRandomnessProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IOmniDragonRandomnessProvider\n * @dev Interface for the OmniDragon Randomness Provider\n */\ninterface IOmniDragonRandomnessProvider {\n    /**\n     * @dev Request types for randomness\n     */\n    enum RequestType {\n        POOL,           // Pool-based pseudo-randomness\n        CHAINLINK_VRF,  // Chainlink VRF cross-chain\n        INSTANT         // Instant pseudo-randomness\n    }\n\n    /**\n     * @dev Randomness request structure\n     */\n    struct RandomnessRequest {\n        address requester;     // Contract requesting randomness\n        uint64 timestamp;      // When the request was made\n        bool fulfilled;        // Whether request has been fulfilled\n        uint256 randomValue;   // The random value (0 if not fulfilled)\n        uint32 requestType;    // Type of request (RequestType enum)\n        uint64 vrfSequence;    // VRF sequence number if applicable\n    }\n\n    /**\n     * @dev Request randomness from pool (pseudo-randomness)\n     * @return randomnessId The unique identifier for this randomness request\n     */\n    function requestRandomnessFromPool() external payable returns (uint256 randomnessId);\n\n    /**\n     * @dev Request randomness from Chainlink VRF via cross-chain integrator\n     * @return randomnessId The unique identifier for this randomness request\n     */\n    function requestRandomnessFromChainlinkVRF() external payable returns (uint256 randomnessId);\n\n    /**\n     * @dev Get instant randomness for per-swap lotteries (no fee, pseudo-random)\n     * @param swapper The address of the user making the swap\n     * @param tokenA The first token in the swap\n     * @param tokenB The second token in the swap  \n     * @param amountIn The input amount\n     * @param amountOut The output amount\n     * @return randomness The generated random value\n     */\n    function drawUnpredictableFromPool(\n        address swapper,\n        address tokenA,\n        address tokenB,\n        uint256 amountIn,\n        uint256 amountOut\n    ) external returns (uint256 randomness);\n\n    /**\n     * @dev Receives random words from ChainlinkVRFIntegratorV2_5\n     * @param randomWords Array of random words from Chainlink VRF\n     * @param sequence The VRF sequence number from the integrator\n     */\n    function receiveRandomWords(uint256[] memory randomWords, uint64 sequence) external;\n\n    /**\n     * @dev Get randomness request details\n     * @param randomnessId Request ID\n     * @return requester The requester address\n     * @return timestamp When the request was made\n     * @return fulfilled Whether request has been fulfilled\n     * @return randomValue The random value\n     * @return requestType The request type\n     */\n    function getRandomnessRequest(uint256 randomnessId) external view returns (\n        address requester,\n        uint64 timestamp,\n        bool fulfilled,\n        uint256 randomValue,\n        uint32 requestType\n    );\n\n    /**\n     * @dev Get estimated fees for different request types\n     * @return poolFeeAmount Fee for pool requests\n     * @return vrfFeeAmount Fee for VRF requests\n     * @return instantFeeAmount Fee for instant requests\n     */\n    function getEstimatedFees() external view returns (\n        uint256 poolFeeAmount, \n        uint256 vrfFeeAmount, \n        uint256 instantFeeAmount\n    );\n\n    /**\n     * @dev Get statistics\n     * @return totalVRF Total VRF requests\n     * @return totalPool Total pool requests\n     * @return totalInstant Total instant requests\n     * @return successfulCallbacks Successful VRF callbacks\n     * @return pendingRequests Pending requests\n     */\n    function getStatistics() external view returns (\n        uint256 totalVRF,\n        uint256 totalPool,\n        uint256 totalInstant,\n        uint256 successfulCallbacks,\n        uint256 pendingRequests\n    );\n\n    /**\n     * @dev Check if VRF is enabled\n     * @return enabled Whether VRF is enabled\n     */\n    function isVRFEnabled() external view returns (bool enabled);\n\n    /**\n     * @dev Check FeeM registration status\n     * @return isRegistered Whether contract is registered for FeeM\n     */\n    function checkFeeMStatus() external view returns (bool isRegistered);\n\n    /* ========== ADMIN FUNCTIONS ========== */\n\n    function setChainlinkVRFIntegrator(address _integrator) external;\n    function authorizeConsumer(address consumer, bool authorized) external;\n    function setFees(uint256 _vrfFee, uint256 _poolFee, uint256 _instantFee) external;\n    function setMaxPendingRequests(uint256 _maxPendingRequests) external;\n    function withdrawFees() external;\n    function emergencyFulfillRequest(uint256 randomnessId, uint256 randomValue) external;\n\n    // Events\n    event RandomnessRequested(\n        uint256 indexed randomnessId,\n        address indexed requester,\n        RequestType requestType,\n        uint64 vrfSequence\n    );\n\n    event RandomnessFulfilled(\n        uint256 indexed randomnessId,\n        uint256 randomValue,\n        bool fromVRF\n    );\n\n    event RandomnessDelivered(\n        uint256 indexed randomnessId,\n        address indexed requester,\n        uint256 randomValue\n    );\n\n    event RandomnessDeliveryFailed(\n        uint256 indexed randomnessId,\n        address indexed requester,\n        string reason\n    );\n\n    event ChainlinkVRFIntegratorUpdated(\n        address indexed oldIntegrator,\n        address indexed newIntegrator\n    );\n\n    event VRFCallbackReceived(\n        uint256 indexed randomnessId,\n        uint64 indexed vrfSequence,\n        uint256 randomValue\n    );\n\n    event ConsumerAuthorized(address indexed consumer, bool authorized);\n    event FeesUpdated(uint256 vrfFee, uint256 poolFee, uint256 instantFee);\n    event EmergencyFallbackUsed(uint256 indexed randomnessId, string reason);\n}\n"
    },
    "contracts/interfaces/shared/IJackpot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IJackpot\n * @dev Interface for jackpot entry and management\n *\n * Defines various methods for entering the lottery jackpot system\n * Supports multiple entry types: Dragon tokens, wrapped native, and native tokens\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.20;\n\ninterface IJackpot {\n    /**\n     * @dev Enter the jackpot with Dragon tokens\n     * @param user Address of the user entering the jackpot\n     * @param amount Amount of Dragon tokens to enter\n     */\n    function enterJackpotWithDragon(address user, uint256 amount) external;\n\n    /**\n     * @dev Enter the jackpot with wrapped native tokens\n     * @param user Address of the user entering the jackpot\n     * @param amount Amount of wrapped native tokens to enter\n     */\n    function enterJackpotWithWrappedNativeToken(address user, uint256 amount) external;\n\n    /**\n     * @dev Enter the jackpot with native tokens\n     * @param user Address of the user entering the jackpot\n     */\n    function enterJackpotWithNative(address user) external payable;\n\n    /**\n     * @dev Set protocol reward percentages\n     * @param dragonPct Percentage for entering with DRAGON\n     * @param nativePct Percentage for entering with native token\n     */\n    function setRewardPercentages(uint256 dragonPct, uint256 nativePct) external;\n\n    /**\n     * @dev Get jackpot balance\n     * @return Current jackpot balance\n     */\n    function getJackpotBalance() external view returns (uint256);\n\n    /**\n     * @dev Enter jackpot\n     * @param user User entering the jackpot\n     * @param amount Amount to use for entry\n     */\n    function enterJackpot(address user, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/shared/IPromotionalItem.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IPromotionalItem\n * @dev Interface for promotional items that can be used with the lottery\n *\n * Provides standard interface for promotional items like GoldScratchers, RedEnvelopes, or future promotional NFTs\n * Enables lottery enhancements with jackpot and probability boosts within global limits\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPromotionalItem\n * @dev Interface for promotional items that can be used with the lottery\n * This provides a standard interface for all promotional items like\n * GoldScratchers, RedEnvelopes, or future promotional NFTs\n * Note: All boosts will be constrained by global limits:\n * - Maximum jackpot boost: 15% (1500 basis points) on top of default 69%\n * - Maximum probability boost: 5x (500%) multiplier\n */\ninterface IPromotionalItem {\n    /**\n     * @dev Type of promotional item for compatibility checks\n     * @return itemType The type identifier string (e.g., \"SCRATCHER\", \"ENVELOPE\")\n     */\n    function getItemType() external pure returns (string memory);\n\n    /**\n     * @dev Enum representing the type of boost this item provides\n     * JACKPOT - Boosts the jackpot payout percentage (e.g., GoldScratcher)\n     * PROBABILITY - Boosts win probability (e.g., RedEnvelope)\n     */\n    enum BoostType { JACKPOT, PROBABILITY }\n\n    /**\n     * @dev Enum representing the transfer restrictions of the promotional item\n     * FREELY_TRANSFERABLE - Can be transferred without restrictions (e.g., RedEnvelope)\n     * ONE_TIME_TRANSFER - Can only be transferred once from the issuer to the user (e.g., GoldScratcher)\n     * NON_TRANSFERABLE - Cannot be transferred after issuance\n     */\n    enum TransferType { FREELY_TRANSFERABLE, ONE_TIME_TRANSFER, NON_TRANSFERABLE }\n\n    /**\n     * @dev Get the type of boost this promotional item provides\n     * @return boostType The type of boost (jackpot or probability)\n     */\n    function getBoostType() external view returns (BoostType);\n\n    /**\n     * @dev Get the transfer type of this promotional item\n     * @return transferType The type of transfer restrictions\n     */\n    function getTransferType() external view returns (TransferType);\n\n    /**\n     * @dev Apply a promotional item to a swap/lottery transaction\n     * @param itemId Identifier for the specific promotional item instance\n     * @param user Address of the user\n     * @param amount Base amount to potentially boost\n     * @return isSuccess Whether the application was successful\n     * @return boostedAmount The amount after applying any boost\n     */\n    function applyItem(uint256 itemId, address user, uint256 amount) external returns (bool isSuccess, uint256 boostedAmount);\n\n    /**\n     * @dev Check if a user has the promotional item\n     * @param user User address\n     * @param itemId Item ID to check\n     * @return True if user has the item\n     */\n    function hasItem(address user, uint256 itemId) external view returns (bool);\n\n    /**\n     * @dev Calculate boost amount for a user\n     * @param user Address of the user\n     * @param itemId ID of the item\n     * @return boostAmount The boost amount in basis points (e.g., 690 = 6.9%)\n     * Note that returned boost may be capped by the lottery contract\n     */\n    function calculateBoost(address user, uint256 itemId) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/shared/IPromotionalItemRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IPromotionalItemRegistry\n * @dev Interface for the promotional item registry\n *\n * Manages registration and discovery of promotional items within the ecosystem\n * Central registry for all promotional items available in the OmniDragon lottery system\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPromotionalItemRegistry\n * @dev Interface for the promotional item registry\n */\ninterface IPromotionalItemRegistry {\n    /**\n     * @dev Register a promotional item\n     * @param itemType The type of the item\n     * @param itemAddress The contract address of the item\n     */\n    function registerPromotionalItem(string calldata itemType, address itemAddress) external;\n\n    /**\n     * @dev Unregister a promotional item\n     * @param itemType The type of the item\n     */\n    function unregisterPromotionalItem(string calldata itemType) external;\n\n    /**\n     * @dev Get a promotional item contract address\n     * @param itemType The type of the item\n     * @return The contract address of the item\n     */\n    function getPromotionalItem(string calldata itemType) external view returns (address);\n\n    /**\n     * @dev Check if a promotional item type exists\n     * @param itemType The type of the item\n     * @return True if the item type exists\n     */\n    function promotionalItemExists(string calldata itemType) external view returns (bool);\n\n    /**\n     * @dev Get all registered promotional item types\n     * @return Array of item types\n     */\n    function getAllPromotionalItemTypes() external view returns (string[] memory);\n}\n"
    },
    "contracts/interfaces/tokens/IomniDRAGON.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IomniDRAGON\n * @dev Interface for the omniDRAGON token - Core Infrastructure\n *\n * Main interface defining the core functionality of the omniDRAGON ecosystem\n * Handles native token swaps, fee distribution, and cross-chain operations\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IomniDRAGON {\n    /**\n     * @dev Process swap of native tokens ($S) to Dragon tokens and apply fees\n     * @param _user The user who is swapping\n     * @param _nativeAmount The amount of native tokens ($S) being swapped\n     * @return swappableAmount The amount to be used for the actual swap after fees\n     * @return nativeFeeAmount Total native amount that should be converted to fees\n     * @return jackpotFeeAmount Native amount for jackpot (within nativeFeeAmount)\n     * @return veDRAGONFeeAmount Native amount for veDRAGON (within nativeFeeAmount)\n     */\n    function processNativeSwapFees(address _user, uint256 _nativeAmount) external returns (uint256 swappableAmount, uint256 nativeFeeAmount, uint256 jackpotFeeAmount, uint256 veDRAGONFeeAmount);\n\n    /**\n     * @dev Distribute fees to jackpot and veDRAGON without triggering lottery entry\n     * @param jackpotAmount Amount to send to jackpot\n     * @param veDRAGONAmount Amount to send to veDRAGON\n     */\n    function distributeFees(uint256 jackpotAmount, uint256 veDRAGONAmount) external;\n\n    /**\n     * @dev Get wrapped native token address\n     * @return Address of the wrapped native token (WETH, wS, etc.)\n     */\n    function wrappedNativeToken() external view returns (address);\n}\n"
    },
    "contracts/interfaces/tokens/IredDragon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\n\n/**\n * @title IredDragon\n * @notice Interface for the redDragon wrapped Shadow LP token\n */\ninterface IredDragon is IERC20 {\n  // Structs\n  struct StakeInfo {\n    uint256 amount; // Amount of LP tokens staked\n    uint256 shares; // Amount of redDragon tokens received\n    uint256 lockEnd; // Lock end timestamp (0 if not locked)\n    uint256 lastRewardTime; // Last reward calculation timestamp\n    uint256 rewardDebt; // Reward debt for fair distribution\n  }\n\n  // View functions\n  function shadowLP() external view returns (IERC20);\n  function totalStaked() external view returns (uint256);\n  function rewardRate() external view returns (uint256);\n  function stakes(address account) external view returns (StakeInfo memory);\n  function stakedBalance(address account) external view returns (uint256);\n  function isLocked(address account) external view returns (bool);\n  function getBoostMultiplier(address account) external view returns (uint256);\n  function pendingReward(address account) external view returns (uint256);\n\n  // Fee-related views\n  function isExemptFromFees(address account) external view returns (bool);\n  function isAMM(address pair) external view returns (bool);\n  function lotteryManager() external view returns (address);\n  function feeRecipient() external view returns (address);\n  function priceOracle() external view returns (address);\n\n  // Curve-style system views\n  function workingSupply() external view returns (uint256);\n  function workingBalance(address user) external view returns (uint256);\n  function claimable_tokens(address user) external view returns (uint256);\n  function getBoostInfo(\n    address account\n  )\n    external\n    view\n    returns (\n      uint256 userBalance,\n      uint256 totalSupply,\n      uint256 userVotes,\n      uint256 totalVotes,\n      uint256 boostMultiplier,\n      bool isUsingTimeBoost\n    );\n\n  // Voting system\n  function veDragonToken() external view returns (address);\n  function totalVoteWeight() external view returns (uint256);\n  function userVoteWeight(address user) external view returns (uint256);\n  function getUserVoteWeight(address account) external view returns (uint256);\n\n  // Staking functions\n  function stake(uint256 amount, uint256 lockDuration) external;\n  function unstake(uint256 shares) external;\n  function claimReward() external;\n  function extendLock(uint256 additionalDuration) external;\n  function emergencyWithdraw() external;\n\n  // Curve-style system functions\n  function user_checkpoint(address user) external returns (bool);\n  function kick(address user) external;\n\n  // Admin functions\n  function setRewardRate(uint256 _rewardRate) external;\n  function pause() external;\n  function unpause() external;\n  function recoverToken(address token, uint256 amount) external;\n  function setLotterySystem(address _lotteryManager, address _jackpotVault, address _priceOracle) external;\n  function setFeeExemption(address account, bool exempt) external;\n  function setAMMPair(address pair, bool _isAMM) external;\n  function setVeDragonToken(address _veDragonToken) external;\n  function updateVoteWeights(address[] calldata users, uint256[] calldata weights) external;\n  function setEmergencyBoostDisabled(bool disabled) external;\n\n  // Events\n  event Staked(address indexed user, uint256 amount, uint256 shares, uint256 lockEnd);\n  event Unstaked(address indexed user, uint256 amount, uint256 shares);\n  event RewardPaid(address indexed user, uint256 reward);\n  event RewardRateUpdated(uint256 newRate);\n  event EmergencyWithdraw(address indexed user, uint256 amount);\n  event TransferFeeCollected(address indexed from, address indexed to, uint256 feeAmount);\n  event LotteryTriggered(address indexed user, uint256 swapAmountUSD, uint256 entryId);\n  event FeeExemptionSet(address indexed account, bool exempt);\n  event AMMPairSet(address indexed pair, bool isAMM);\n  event UserCheckpoint(address indexed user, uint256 workingBalance, uint256 integrateFraction);\n  event UserKicked(address indexed user, address indexed kicker, uint256 oldWorkingBalance, uint256 newWorkingBalance);\n  event VeDragonTokenUpdated(address indexed newToken);\n  event VoteWeightsUpdated(address[] users, uint256[] weights);\n  event EmergencyBoostDisabled(bool disabled);\n  event TotalSupplyReferenceUpdated(uint256 newReference);\n}\n"
    },
    "contracts/interfaces/tokens/IveDRAGON.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IveDRAGON\n * @dev Interface for veDRAGON vote-escrowed token\n */\ninterface IveDRAGON {\n    // Custom errors\n    error ZeroAddress();\n    error ZeroAmount();\n    error LockExpired();\n    error LockNotExpired();\n    error ExistingLock();\n    error NoLock();\n    error InvalidDuration();\n    error TransferFailed();\n    error Unauthorized();\n\n    // Structs\n    struct LockedBalance {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    // Events\n    event Deposit(address indexed user, uint256 amount, uint256 lockTime, uint256 votingPower);\n    event Withdraw(address indexed user, uint256 amount);\n    event LockUpdated(address indexed user, uint256 lockDuration, uint256 votingPower);\n\n    // View functions\n    function votingPowerOf(address user) external view returns (uint256);\n    function getVotingPower(address account) external view returns (uint256);\n    function getVotingPowerAt(address user, uint256 timestamp) external view returns (uint256);\n    function getTotalVotingPower() external view returns (uint256);\n    function getTotalVotingPowerAt(uint256 timestamp) external view returns (uint256);\n    function lockedBalanceOf(address account) external view returns (uint256);\n    function unlockTimeOf(address account) external view returns (uint256);\n    function totalLockedSupply() external view returns (uint256);\n    function getUserLock(address user) external view returns (uint256 amount, uint256 end);\n    function hasActiveLock(address user) external view returns (bool);\n\n    // State changing functions\n    function createLock(uint256 lpAmount, uint256 lockDuration) external;\n    function increaseLockAmount(uint256 additionalAmount) external;\n    function extendLock(uint256 lockDuration) external;\n    function withdraw() external;\n}\n"
    },
    "contracts/interfaces/tokens/IveDRAGONFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Interface: IveDRAGONFeeDistributor\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IveDRAGONFeeDistributor\n * @dev Interface for the veDRAGON fee distributor contract\n *\n * Manages fee collection and distribution to veDRAGON holders\n * Core component of the OmniDragon revenue sharing mechanism\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IveDRAGONFeeDistributor {\n    /**\n     * @notice Receive rewards (DRAGON tokens) from external sources\n     * @param _amount The amount of DRAGON tokens to receive\n     */\n    function receiveRewards(uint256 _amount) external;\n\n    /**\n     * @notice Distribute accumulated rewards to the veDRAGON contract or reward mechanism\n     */\n    function distributeRewards() external;\n\n    /**\n     * @notice Get the current accumulated rewards that have not been distributed\n     * @return The amount of undistributed rewards\n     */\n    function accumulatedRewards() external view returns (uint256);\n\n    /**\n     * @notice Set the DRAGON token address\n     * @param _rewardToken The address of the DRAGON token\n     */\n    function setRewardToken(address _rewardToken) external;\n\n    /**\n     * @notice Update the veDRAGON recipient address\n     * @param _veDRAGONAddress The new veDRAGON contract or reward distributor address\n     */\n    function setVeDRAGONAddress(address _veDRAGONAddress) external;\n\n    /**\n     * @notice Set the wrapped native token address\n     * @param _wrappedNativeToken The new wrapped native token address\n     */\n    function setWrappedNativeToken(address _wrappedNativeToken) external;\n}\n"
    },
    "contracts/interfaces/tokens/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Interface: IWETH\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IWETH\n * @dev Interface for Wrapped Ether (WETH) token functionality\n *\n * Standard interface for wrapped native tokens across different chains\n * Enables seamless integration with native token wrapping and unwrapping\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IWETH is IERC20 {\n    /**\n     * @notice Deposit native token (ETH, AVAX, etc.) to get wrapped token\n     */\n    function deposit() external payable;\n\n    /**\n     * @notice Withdraw native token by burning wrapped token\n     * @param amount Amount to withdraw\n     */\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/tokens/IWrappedNativeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IWrappedNativeToken\n * @dev Interface for wrapped native token (WETH, WAVAX, WrappedNativeToken, etc.)\n *\n * Standard interface for wrapped native tokens across different blockchain networks\n * Enables seamless integration with native token wrapping and unwrapping operations\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWrappedNativeToken is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/vault/IDragonJackpotDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IDragonJackpotDistributor\n * @dev Interface for Dragon Jackpot Distribution functionality\n *\n * Manages jackpot fund accumulation and distribution to lottery winners\n * Core component of the OmniDragon lottery and reward system\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IDragonJackpotDistributor\n * @dev Interface for Dragon Jackpot Distributor functionality\n */\ninterface IDragonJackpotDistributor {\n    /**\n     * @dev Add funds to the jackpot\n     * @param amount Amount to add\n     */\n    function addToJackpot(uint256 amount) external;\n\n    /**\n     * @dev Distribute a jackpot to a winner\n     * @param winner Address of the winner\n     * @param amount Amount to distribute\n     */\n    function distributeJackpot(address winner, uint256 amount) external;\n\n    /**\n     * @dev Get the current jackpot balance\n     * @return Current jackpot balance\n     */\n    function getCurrentJackpot() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/vault/IDragonJackpotVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDragonJackpotVault\n * @dev Interface for the Dragon Jackpot Vault system\n *\n * Manages jackpot accumulation, distribution, and lottery mechanics\n * Core component of the OmniDragon tokenomics and reward system\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\n/**\n * @title IDragonJackpotVault\n * @dev Interface for the Dragon Jackpot Vault system\n *\n * Manages jackpot accumulation, distribution, and lottery mechanics\n * Core component of the OmniDragon tokenomics and reward system\n */\ninterface IDragonJackpotVault {\n  /**\n   * @dev Add ERC20 tokens to the jackpot with proper token tracking\n   * @param token Token address\n   * @param amount Amount to add\n   */\n  function addERC20ToJackpot(address token, uint256 amount) external;\n\n  /**\n   * @dev Add collected funds that are already in the vault (for trusted callers only)\n   * @param token Token address\n   * @param amount Amount to add to accounting\n   */\n  function addCollectedFunds(address token, uint256 amount) external;\n\n  /**\n   * @notice Get the current jackpot balance\n   * @return balance The current jackpot balance\n   */\n  function getJackpotBalance() external view returns (uint256 balance);\n\n  /**\n   * @notice Pay out a jackpot to a winner\n   * @param winner Address of the winner\n   * @param amount Amount to pay\n   */\n  function payJackpot(address winner, uint256 amount) external;\n\n  /**\n   * @notice Get the time of the last jackpot win\n   * @return timestamp The last win timestamp\n   */\n  function getLastWinTime() external view returns (uint256 timestamp);\n\n  /**\n   * @notice Set the wrapped native token address\n   * @param _wrappedNativeToken The new wrapped native token address\n   */\n  function setWrappedNativeToken(address _wrappedNativeToken) external;\n}\n"
    },
    "contracts/libraries/core/DragonDateTimeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Time management utilities for veDRAGON lockups,\n * jackpot scheduling, and special event bonuses\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonic_reddragon_bot\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title DragonDateTimeLib\n * @dev Specialized library for Dragon Token ecosystem time-based mechanics\n * Adapted from Solady DateTimeLib with enhancements for jackpot and\n * lock time calculations with Dragon-specific time-based events.\n */\nlibrary DragonDateTimeLib {\n    // Constants for time calculations\n    uint256 public constant SECONDS_PER_MINUTE = 60;\n    uint256 public constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 public constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 public constant SECONDS_PER_WEEK = 7 * SECONDS_PER_DAY;\n    uint256 public constant SECONDS_PER_YEAR = 365 * SECONDS_PER_DAY;\n\n    // Special events time constants\n    uint256 public constant TUESDAY = 2;  // 1-indexed weekday (Monday = 1)\n    uint256 public constant FRIDAY = 5;   // 1-indexed weekday (Monday = 1)\n\n    /**\n     * @dev Convert timestamp to day\n     * @param timestamp Unix timestamp\n     * @return day Days since epoch (Jan 1, 1970)\n     */\n    function timestampToDay(uint256 timestamp) internal pure returns (uint256 day) {\n        return timestamp / SECONDS_PER_DAY;\n    }\n\n    /**\n     * @dev Determine the day of the week from a timestamp\n     * @param timestamp Unix timestamp\n     * @return weekday The day of the week (1-indexed: Monday = 1, Sunday = 7)\n     */\n    function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 weekday) {\n        // January 1, 1970 was a Thursday (4)\n        uint256 daysSinceEpoch = timestampToDay(timestamp);\n        // +3 adjustment ensures Monday is 1\n        return ((daysSinceEpoch + 3) % 7) + 1;\n    }\n\n    /**\n     * @dev Checks if a timestamp falls on a specific day of the week\n     * @param timestamp Unix timestamp\n     * @param targetWeekday Target weekday (1-7, where 1 = Monday)\n     * @return result True if the timestamp is on the target weekday\n     * @return startOfDay Timestamp at 00:00:00 UTC of the day\n     */\n    function isDayOfWeek(uint256 timestamp, uint256 targetWeekday) internal pure returns (bool result, uint256 startOfDay) {\n        uint256 day = timestampToDay(timestamp);\n        startOfDay = day * SECONDS_PER_DAY;\n        result = getDayOfWeek(timestamp) == targetWeekday;\n    }\n\n    /**\n     * @dev Checks if a timestamp falls on a Tuesday\n     * @param timestamp Unix timestamp\n     * @return result True if the timestamp is on a Tuesday\n     * @return startOfDay Timestamp at 00:00:00 UTC of the day\n     */\n    function isTuesday(uint256 timestamp) internal pure returns (bool result, uint256 startOfDay) {\n        return isDayOfWeek(timestamp, TUESDAY);\n    }\n\n    /**\n     * @dev Checks if a timestamp falls on a Friday\n     * @param timestamp Unix timestamp\n     * @return result True if the timestamp is on a Friday\n     * @return startOfDay Timestamp at 00:00:00 UTC of the day\n     */\n    function isFriday(uint256 timestamp) internal pure returns (bool result, uint256 startOfDay) {\n        return isDayOfWeek(timestamp, FRIDAY);\n    }\n\n    /**\n     * @dev Get month number from a timestamp\n     * @param timestamp Unix timestamp\n     * @return month Month number (1-12)\n     */\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n        uint256 epochDay = timestamp / SECONDS_PER_DAY;\n\n        // Howard Hinnant's algorithm for computing month from days\n        assembly {\n            epochDay := add(epochDay, 719468)\n            let doe := mod(epochDay, 146097)\n            let yoe := div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n            let mp := div(add(mul(5, doy), 2), 153)\n            month := sub(add(mp, 3), mul(gt(mp, 9), 12))\n        }\n    }\n\n    /**\n     * @dev Get day of month from a timestamp\n     * @param timestamp Unix timestamp\n     * @return day Day of month (1-31)\n     */\n    function getDayOfMonth(uint256 timestamp) internal pure returns (uint256 day) {\n        uint256 epochDay = timestamp / SECONDS_PER_DAY;\n\n        // Compute the day of month using modified Zeller's algorithm\n        assembly {\n            epochDay := add(epochDay, 719468)\n            let doe := mod(epochDay, 146097)\n            let yoe := div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n            let mp := div(add(mul(5, doy), 2), 153)\n            day := add(sub(doy, div(sub(add(mul(153, mp), 2), 5), 153)), 1)\n        }\n    }\n\n    /**\n     * @dev Check if a timestamp is in the first week of the month\n     * @param timestamp Unix timestamp\n     * @return result True if the day is in the first 7 days of the month\n     */\n    function isFirstWeekOfMonth(uint256 timestamp) internal pure returns (bool result) {\n        uint256 dayOfMonth = getDayOfMonth(timestamp);\n        return dayOfMonth <= 7;\n    }\n\n    /**\n     * @dev Check if a timestamp is the first occurrence of a specific weekday in the month\n     * @param timestamp Unix timestamp\n     * @param targetWeekday Target weekday (1-7, where 1 = Monday)\n     * @return result True if the timestamp is the first occurrence of that weekday in the month\n     */\n    function isFirstWeekdayOfMonth(uint256 timestamp, uint256 targetWeekday) internal pure returns (bool result) {\n        // Must be the target weekday\n        (bool isTargetDay,) = isDayOfWeek(timestamp, targetWeekday);\n        if (!isTargetDay) return false;\n\n        // Get the day of month (1-31)\n        uint256 dayOfMonth = getDayOfMonth(timestamp);\n\n        // If it's days 1-7, we need to check if this is the first occurrence\n        if (dayOfMonth <= 7) {\n            // Check if there are any earlier days in the month with the same weekday\n            // Start from day 1 and check each day until we reach our current day\n            for (uint256 d = 1; d < dayOfMonth; d++) {\n                uint256 earlierTimestamp = timestamp - ((dayOfMonth - d) * SECONDS_PER_DAY);\n                if (getDayOfWeek(earlierTimestamp) == targetWeekday) {\n                    // Found an earlier occurrence of this weekday\n                    return false;\n                }\n            }\n            // No earlier occurrences found\n            return true;\n        }\n\n        // If we're beyond day 7, it can't be the first occurrence\n        return false;\n    }\n\n    /**\n     * @dev Check if a timestamp is the first Tuesday of the month\n     * @param timestamp Unix timestamp\n     * @return result True if the timestamp is the first Tuesday of the month\n     */\n    function isFirstTuesdayOfMonth(uint256 timestamp) internal pure returns (bool result) {\n        return isFirstWeekdayOfMonth(timestamp, TUESDAY);\n    }\n\n    /**\n     * @dev Check if a timestamp is the first Friday of the month\n     * @param timestamp Unix timestamp\n     * @return result True if the timestamp is the first Friday of the month\n     */\n    function isFirstFridayOfMonth(uint256 timestamp) internal pure returns (bool result) {\n        return isFirstWeekdayOfMonth(timestamp, FRIDAY);\n    }\n\n    /**\n     * @dev Calculate the timestamp of the next occurrence of a specific weekday\n     * @param timestamp Starting timestamp\n     * @param targetWeekday Target weekday (1-7, where 1 = Monday)\n     * @return nextOccurrence Timestamp of the next occurrence of the target weekday\n     */\n    function getNextWeekday(uint256 timestamp, uint256 targetWeekday) internal pure returns (uint256 nextOccurrence) {\n        uint256 currentWeekday = getDayOfWeek(timestamp);\n        uint256 daysToAdd;\n\n        if (currentWeekday < targetWeekday) {\n            // Target weekday is later in the current week\n            daysToAdd = targetWeekday - currentWeekday;\n        } else {\n            // Target weekday is in the next week\n            daysToAdd = 7 - (currentWeekday - targetWeekday);\n        }\n\n        // Align to the start of the day and add the required days\n        uint256 currentDay = timestampToDay(timestamp);\n        return (currentDay + daysToAdd) * SECONDS_PER_DAY;\n    }\n\n    /**\n     * @dev Calculate the timestamp of the next Tuesday\n     * @param timestamp Starting timestamp\n     * @return nextTuesday Timestamp of the next Tuesday at 00:00:00 UTC\n     */\n    function getNextTuesday(uint256 timestamp) internal pure returns (uint256 nextTuesday) {\n        return getNextWeekday(timestamp, TUESDAY);\n    }\n\n    /**\n     * @dev Calculate how many days until the first Tuesday of the next month\n     * @param timestamp Current timestamp\n     * @return daysUntil Number of days until the event\n     * @return eventTimestamp Timestamp of the event\n     */\n    function daysUntilFirstTuesdayOfNextMonth(uint256 timestamp) internal pure returns (uint256 daysUntil, uint256 eventTimestamp) {\n        // Get the current month\n        uint256 currentMonth = getMonth(timestamp);\n        uint256 dayOfMonth = getDayOfMonth(timestamp);\n\n        // Calculate the first day of next month (approximate)\n        uint256 daysInMonth;\n        if (currentMonth == 2) {\n            // February special case\n            daysInMonth = 28; // Simplified, not handling leap years\n        } else if (currentMonth == 4 || currentMonth == 6 || currentMonth == 9 || currentMonth == 11) {\n            // 30-day months\n            daysInMonth = 30;\n        } else {\n            // 31-day months\n            daysInMonth = 31;\n        }\n\n        // Calculate days remaining in this month\n        uint256 daysRemainingInMonth = daysInMonth - dayOfMonth + 1;\n\n        // Calculate the first day of next month\n        uint256 firstDayOfNextMonth = timestampToDay(timestamp) + daysRemainingInMonth;\n        uint256 firstDayOfNextMonthTs = firstDayOfNextMonth * SECONDS_PER_DAY;\n\n        // Find the weekday of the first day of next month\n        uint256 firstDayWeekday = getDayOfWeek(firstDayOfNextMonthTs);\n\n        // Calculate the first Tuesday\n        uint256 daysToFirstTuesday;\n        if (firstDayWeekday <= TUESDAY) {\n            daysToFirstTuesday = TUESDAY - firstDayWeekday;\n        } else {\n            daysToFirstTuesday = 7 - (firstDayWeekday - TUESDAY);\n        }\n\n        eventTimestamp = firstDayOfNextMonthTs + (daysToFirstTuesday * SECONDS_PER_DAY);\n        daysUntil = (eventTimestamp - timestamp) / SECONDS_PER_DAY;\n\n        return (daysUntil, eventTimestamp);\n    }\n\n    /**\n     * @dev Calculate lock-end time aligned to a week boundary\n     * @param currentTime Current timestamp\n     * @param lockDuration Duration to lock for in seconds\n     * @return lockEnd Timestamp when lock will expire (aligned to week)\n     */\n    function calculateLockEndAligned(uint256 currentTime, uint256 lockDuration) internal pure returns (uint256 lockEnd) {\n        // Calculate raw lock end time\n        uint256 rawLockEnd = currentTime + lockDuration;\n\n        // Round down to the nearest week boundary\n        return (rawLockEnd / SECONDS_PER_WEEK) * SECONDS_PER_WEEK;\n    }\n\n    /**\n     * @dev Check if a timestamp is during a Dragon Token special event\n     * Special events will be activated in the future\n     * @return isSpecialEvent Whether the timestamp is during a special event (always false currently)\n     * @return eventMultiplier The multiplier for the event (10000 = 1.0x)\n     */\n    function checkForSpecialEvent(uint256) internal pure returns (bool isSpecialEvent, uint256 eventMultiplier) {\n        // Special events are inactive by default\n        // This function will be updated when events are activated\n\n        /*\n        // Check if it's the first Tuesday of the month (2x boost)\n        if (isFirstTuesdayOfMonth(timestamp)) {\n            return (true, 20000); // 2.0x boost\n        }\n\n        // Check if it's any Friday (1.5x boost)\n        (bool isFridayToday,) = isFriday(timestamp);\n        if (isFridayToday) {\n            return (true, 15000); // 1.5x boost\n        }\n        */\n\n        // No special event - default state\n        return (false, 10000); // 1.0x (no boost)\n    }\n}\n"
    },
    "contracts/libraries/core/DragonDeployerLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { TransparentUpgradeableProxy } from \"lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport { ProxyAdmin } from \"lib/openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol\";\n\n/**\n * @title DragonDeployerLib\n * @dev Library for deploying SwapTrigger contracts with upgradeability support\n */\nlibrary DragonDeployerLib {\n    /**\n     * @dev Parameters for deploying a SwapTrigger contract\n     */\n    struct SwapParams {\n        address implementation;\n        address router;\n        address wrappedNative;\n        address[] pairs;\n        address proxyAdmin;\n        bytes initData; // Encoded initializer data\n    }\n\n    /**\n     * @notice Deploys a SwapTrigger contract behind a TransparentUpgradeableProxy\n     * @param omniDragon The address of the OmniDragon token\n     * @param params The deployment parameters\n     * @param owner The owner of the deployed contract\n     * @return proxy The address of the deployed proxy contract\n     */\n    function deploySwapTrigger(\n        address omniDragon,\n        SwapParams memory params,\n        address owner\n    ) internal returns (address proxy) {\n        require(params.implementation != address(0), \"No implementation\");\n        require(params.proxyAdmin != address(0), \"No proxy admin\");\n        // Deploy the proxy\n        TransparentUpgradeableProxy p = new TransparentUpgradeableProxy(\n            params.implementation,\n            params.proxyAdmin,\n            params.initData\n        );\n        proxy = address(p);\n        // Optionally, transfer ownership or set up roles here\n        return proxy;\n    }\n}\n"
    },
    "contracts/libraries/core/DragonFeeProcessingLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title DragonFeeProcessingLib\n * @dev Complete fee processing library for Dragon ecosystem\n * Handles all fee calculations, distributions, and validations\n */\nlibrary DragonFeeProcessingLib {\n    using SafeERC20 for IERC20;\n    \n    // ======== EVENTS ========\n    event FeeCalculated(\n        address indexed token,\n        uint256 amount,\n        uint256 jackpotFee,\n        uint256 veDRAGONFee,\n        uint256 burnFee\n    );\n    \n    event FeeDistributed(\n        address indexed recipient,\n        address indexed token,\n        uint256 amount,\n        string feeType\n    );\n    \n    event FeeStructureUpdated(\n        string feeType,\n        uint256 jackpot,\n        uint256 veDRAGON,\n        uint256 burn,\n        uint256 total\n    );\n    \n    // ======== STRUCTS ========\n    \n    /**\n     * @dev Fee structure for different transaction types\n     */\n    struct Fees {\n        uint256 jackpot;    // Basis points for jackpot\n        uint256 veDRAGON;   // Basis points for veDRAGON holders\n        uint256 burn;       // Basis points for token burn\n        uint256 total;      // Total basis points (sum of above)\n    }\n    \n    /**\n     * @dev Fee distribution configuration\n     */\n    struct FeeDistribution {\n        address jackpotVault;\n        address revenueDistributor;\n        address burnAddress;\n        bool distributionEnabled;\n    }\n    \n    /**\n     * @dev Fee calculation result\n     */\n    struct FeeCalculation {\n        uint256 jackpotAmount;\n        uint256 veDRAGONAmount;\n        uint256 burnAmount;\n        uint256 totalFeeAmount;\n        uint256 transferAmount;\n    }\n    \n    // ======== CONSTANTS ========\n    \n    uint256 public constant MAX_TOTAL_FEE = 2500; // 25% maximum total fee\n    uint256 public constant BASIS_POINTS = 10000; // 100% = 10,000 basis points\n    uint256 public constant MIN_FEE_AMOUNT = 1000; // Minimum 0.01% fee\n    \n    // Default fee structures\n    uint256 public constant DEFAULT_BUY_JACKPOT = 690;  // 6.9%\n    uint256 public constant DEFAULT_BUY_VEDRAGON = 241; // 2.41%\n    uint256 public constant DEFAULT_BUY_BURN = 69;      // 0.69%\n    \n    uint256 public constant DEFAULT_SELL_JACKPOT = 690; // 6.9%\n    uint256 public constant DEFAULT_SELL_VEDRAGON = 241;// 2.41%\n    uint256 public constant DEFAULT_SELL_BURN = 69;     // 0.69%\n    \n    uint256 public constant DEFAULT_TRANSFER_JACKPOT = 0; // 0%\n    uint256 public constant DEFAULT_TRANSFER_VEDRAGON = 0;// 0%\n    uint256 public constant DEFAULT_TRANSFER_BURN = 69;   // 0.69%\n    \n    // ======== ERRORS ========\n    \n    error InvalidFeeStructure();\n    error FeeTooHigh();\n    error ZeroAmount();\n    error ZeroAddress();\n    error DistributionFailed();\n    error InvalidBasisPoints();\n    \n    // ======== FUNCTIONS ========\n    \n    /**\n     * @dev Initialize default fee structures\n     */\n    function initializeDefaultFees() internal pure returns (Fees memory buyFees, Fees memory sellFees, Fees memory transferFees) {\n        buyFees = Fees({\n            jackpot: DEFAULT_BUY_JACKPOT,\n            veDRAGON: DEFAULT_BUY_VEDRAGON,\n            burn: DEFAULT_BUY_BURN,\n            total: DEFAULT_BUY_JACKPOT + DEFAULT_BUY_VEDRAGON + DEFAULT_BUY_BURN\n        });\n        \n        sellFees = Fees({\n            jackpot: DEFAULT_SELL_JACKPOT,\n            veDRAGON: DEFAULT_SELL_VEDRAGON,\n            burn: DEFAULT_SELL_BURN,\n            total: DEFAULT_SELL_JACKPOT + DEFAULT_SELL_VEDRAGON + DEFAULT_SELL_BURN\n        });\n        \n        transferFees = Fees({\n            jackpot: DEFAULT_TRANSFER_JACKPOT,\n            veDRAGON: DEFAULT_TRANSFER_VEDRAGON,\n            burn: DEFAULT_TRANSFER_BURN,\n            total: DEFAULT_TRANSFER_JACKPOT + DEFAULT_TRANSFER_VEDRAGON + DEFAULT_TRANSFER_BURN\n        });\n        \n        return (buyFees, sellFees, transferFees);\n    }\n    \n    /**\n     * @dev Validate fee structure\n     */\n    function validateFees(uint256 jackpot, uint256 veDRAGON, uint256 burn) internal pure returns (uint256 total) {\n        total = jackpot + veDRAGON + burn;\n        \n        if (total > MAX_TOTAL_FEE) {\n            revert FeeTooHigh();\n        }\n        \n        if (jackpot > BASIS_POINTS || veDRAGON > BASIS_POINTS || burn > BASIS_POINTS) {\n            revert InvalidBasisPoints();\n        }\n        \n        return total;\n    }\n    \n    /**\n     * @dev Calculate fees for a transaction\n     */\n    function calculateFees(\n        uint256 amount,\n        Fees memory feeStructure\n    ) internal pure returns (FeeCalculation memory calculation) {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n        \n        uint256 feeBase = amount / BASIS_POINTS;\n        \n        calculation.jackpotAmount = feeStructure.jackpot * feeBase;\n        calculation.veDRAGONAmount = feeStructure.veDRAGON * feeBase;\n        calculation.burnAmount = feeStructure.burn * feeBase;\n        \n        calculation.totalFeeAmount = calculation.jackpotAmount + \n                                   calculation.veDRAGONAmount + \n                                   calculation.burnAmount;\n        \n        calculation.transferAmount = amount - calculation.totalFeeAmount;\n        \n        return calculation;\n    }\n    \n    /**\n     * @dev Calculate fees with dynamic adjustments\n     */\n    function calculateDynamicFees(\n        uint256 amount,\n        Fees memory baseFeeStructure,\n        uint256 volumeMultiplier,  // Basis points multiplier based on volume\n        uint256 loyaltyDiscount    // Basis points discount for loyal users\n    ) internal pure returns (FeeCalculation memory calculation) {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n        \n        // Apply volume multiplier (can increase fees for high volume)\n        uint256 adjustedJackpot = (baseFeeStructure.jackpot * volumeMultiplier) / BASIS_POINTS;\n        uint256 adjustedVeDRAGON = (baseFeeStructure.veDRAGON * volumeMultiplier) / BASIS_POINTS;\n        uint256 adjustedBurn = (baseFeeStructure.burn * volumeMultiplier) / BASIS_POINTS;\n        \n        // Apply loyalty discount\n        adjustedJackpot = adjustedJackpot > loyaltyDiscount ? adjustedJackpot - loyaltyDiscount : 0;\n        adjustedVeDRAGON = adjustedVeDRAGON > loyaltyDiscount ? adjustedVeDRAGON - loyaltyDiscount : 0;\n        adjustedBurn = adjustedBurn > loyaltyDiscount ? adjustedBurn - loyaltyDiscount : 0;\n        \n        // Ensure we don't exceed maximum fee\n        uint256 totalAdjusted = adjustedJackpot + adjustedVeDRAGON + adjustedBurn;\n        if (totalAdjusted > MAX_TOTAL_FEE) {\n            // Scale down proportionally\n            adjustedJackpot = (adjustedJackpot * MAX_TOTAL_FEE) / totalAdjusted;\n            adjustedVeDRAGON = (adjustedVeDRAGON * MAX_TOTAL_FEE) / totalAdjusted;\n            adjustedBurn = (adjustedBurn * MAX_TOTAL_FEE) / totalAdjusted;\n        }\n        \n        Fees memory adjustedFees = Fees({\n            jackpot: adjustedJackpot,\n            veDRAGON: adjustedVeDRAGON,\n            burn: adjustedBurn,\n            total: adjustedJackpot + adjustedVeDRAGON + adjustedBurn\n        });\n        \n        return calculateFees(amount, adjustedFees);\n    }\n    \n    /**\n     * @dev Distribute fees to respective recipients\n     */\n    function distributeFees(\n        FeeCalculation memory calculation,\n        FeeDistribution memory distribution,\n        address token\n    ) internal {\n        if (!distribution.distributionEnabled) {\n            return;\n        }\n        \n        // Distribute to jackpot vault\n        if (calculation.jackpotAmount > 0 && distribution.jackpotVault != address(0)) {\n            if (token == address(0)) {\n                // Native token transfer\n                (bool success, ) = distribution.jackpotVault.call{value: calculation.jackpotAmount}(\"\");\n                if (!success) revert DistributionFailed();\n            } else {\n                // ERC20 token transfer\n                IERC20(token).safeTransfer(distribution.jackpotVault, calculation.jackpotAmount);\n            }\n            \n            emit FeeDistributed(distribution.jackpotVault, token, calculation.jackpotAmount, \"Jackpot\");\n        }\n        \n        // Distribute to veDRAGON revenue distributor\n        if (calculation.veDRAGONAmount > 0 && distribution.revenueDistributor != address(0)) {\n            if (token == address(0)) {\n                // Native token transfer\n                (bool success, ) = distribution.revenueDistributor.call{value: calculation.veDRAGONAmount}(\"\");\n                if (!success) revert DistributionFailed();\n            } else {\n                // ERC20 token transfer\n                IERC20(token).safeTransfer(distribution.revenueDistributor, calculation.veDRAGONAmount);\n            }\n            \n            emit FeeDistributed(distribution.revenueDistributor, token, calculation.veDRAGONAmount, \"veDRAGON\");\n        }\n        \n        // Handle burn (transfer to burn address or actual burn)\n        if (calculation.burnAmount > 0) {\n            if (distribution.burnAddress != address(0)) {\n                if (token == address(0)) {\n                    // Native token to burn address\n                    (bool success, ) = distribution.burnAddress.call{value: calculation.burnAmount}(\"\");\n                    if (!success) revert DistributionFailed();\n                } else {\n                    // ERC20 to burn address\n                    IERC20(token).safeTransfer(distribution.burnAddress, calculation.burnAmount);\n                }\n                \n                emit FeeDistributed(distribution.burnAddress, token, calculation.burnAmount, \"Burn\");\n            }\n            // If burnAddress is address(0), the tokens are effectively burned by not being transferred\n        }\n    }\n    \n    /**\n     * @dev Update fee structure with validation\n     */\n    function updateFeeStructure(\n        Fees storage fees,\n        uint256 jackpot,\n        uint256 veDRAGON,\n        uint256 burn,\n        string memory feeType\n    ) internal {\n        uint256 total = validateFees(jackpot, veDRAGON, burn);\n        \n        fees.jackpot = jackpot;\n        fees.veDRAGON = veDRAGON;\n        fees.burn = burn;\n        fees.total = total;\n        \n        emit FeeStructureUpdated(feeType, jackpot, veDRAGON, burn, total);\n    }\n    \n    /**\n     * @dev Get effective fee rate based on user metrics\n     */\n    function getEffectiveFeeRate(\n        Fees memory baseFees,\n        uint256 userVolume,\n        uint256 userTransactions,\n        uint256 holdingTime\n    ) internal pure returns (Fees memory effectiveFees) {\n        // Calculate loyalty discount based on metrics\n        uint256 volumeDiscount = userVolume > 1000 ether ? 50 : 0; // 0.5% discount for high volume\n        uint256 transactionDiscount = userTransactions > 100 ? 25 : 0; // 0.25% discount for frequent users\n        uint256 holdingDiscount = holdingTime > 365 days ? 25 : 0; // 0.25% discount for long-term holders\n        \n        uint256 totalDiscount = volumeDiscount + transactionDiscount + holdingDiscount;\n        if (totalDiscount > 100) totalDiscount = 100; // Max 1% total discount\n        \n        // Apply discount to each fee component\n        effectiveFees.jackpot = baseFees.jackpot > totalDiscount ? baseFees.jackpot - totalDiscount : 0;\n        effectiveFees.veDRAGON = baseFees.veDRAGON > totalDiscount ? baseFees.veDRAGON - totalDiscount : 0;\n        effectiveFees.burn = baseFees.burn > totalDiscount ? baseFees.burn - totalDiscount : 0;\n        effectiveFees.total = effectiveFees.jackpot + effectiveFees.veDRAGON + effectiveFees.burn;\n        \n        return effectiveFees;\n    }\n    \n    /**\n     * @dev Calculate total fees for a transaction without distribution\n     */\n    function calculateTotalFee(uint256 amount, Fees memory feeStructure) internal pure returns (uint256) {\n        if (amount == 0) return 0;\n        return (amount * feeStructure.total) / BASIS_POINTS;\n    }\n    \n    /**\n     * @dev Check if fee structure is valid\n     */\n    function isValidFeeStructure(Fees memory fees) internal pure returns (bool) {\n        return fees.total <= MAX_TOTAL_FEE && \n               fees.total == (fees.jackpot + fees.veDRAGON + fees.burn);\n    }\n}\n"
    },
    "contracts/libraries/core/DragonMarketAnalyzer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title DragonMarketAnalyzer\n * @dev Library for market analysis and fee calculations in the Dragon ecosystem\n * @notice Provides sophisticated market analysis tools for adaptive fee management\n */\nlibrary DragonMarketAnalyzer {\n    // Constants\n    uint256 public constant BASE_BURN_BPS = 69; // 0.69% fixed burn fee\n    uint256 public constant MAX_TOTAL_FEE_BPS = 2000; // 20% maximum total fee\n    uint256 public constant MIN_JACKPOT_FEE_BPS = 200; // 2% minimum jackpot fee\n    uint256 public constant MAX_JACKPOT_FEE_BPS = 1500; // 15% maximum jackpot fee\n    \n    // Market condition thresholds\n    uint256 public constant HIGH_VOLUME_THRESHOLD = 1000000 ether; // 1M token volume\n    uint256 public constant LOW_VOLUME_THRESHOLD = 100000 ether; // 100K token volume\n    uint256 public constant HIGH_VOLATILITY_THRESHOLD = 500; // 5% price change\n    uint256 public constant LOW_VOLATILITY_THRESHOLD = 100; // 1% price change\n    \n    // Analysis parameters\n    uint256 public constant VOLUME_WEIGHT = 40; // 40% weight for volume analysis\n    uint256 public constant VOLATILITY_WEIGHT = 35; // 35% weight for volatility analysis\n    uint256 public constant TREND_WEIGHT = 25; // 25% weight for trend analysis\n    \n    /**\n     * @dev Struct for market analysis results\n     */\n    struct MarketAnalysis {\n        uint256 volumeScore;\n        uint256 volatilityScore;\n        uint256 trendScore;\n        uint256 overallScore;\n        bool shouldIncreaseFees;\n        bool shouldDecreaseFees;\n        uint256 recommendedJackpotFee;\n    }\n    \n    /**\n     * @dev Struct for market data input\n     */\n    struct MarketData {\n        uint256 currentVolume;\n        uint256 previousVolume;\n        int256 currentPrice;\n        int256 previousPrice;\n        uint256 jackpotSize;\n        uint256 liquidityDepth;\n        uint256 timestamp;\n    }\n    \n    /**\n     * @dev Analyze market conditions and recommend fee adjustments\n     * @param data Market data for analysis\n     * @param currentJackpotFee Current jackpot fee in basis points\n     * @return analysis Complete market analysis with recommendations\n     */\n    function analyzeMarketConditions(\n        MarketData memory data,\n        uint256 currentJackpotFee\n    ) internal pure returns (MarketAnalysis memory analysis) {\n        // Calculate individual scores\n        analysis.volumeScore = _calculateVolumeScore(data.currentVolume, data.previousVolume);\n        analysis.volatilityScore = _calculateVolatilityScore(data.currentPrice, data.previousPrice);\n        analysis.trendScore = _calculateTrendScore(data.currentPrice, data.previousPrice, data.jackpotSize);\n        \n        // Calculate weighted overall score\n        analysis.overallScore = (\n            analysis.volumeScore * VOLUME_WEIGHT +\n            analysis.volatilityScore * VOLATILITY_WEIGHT +\n            analysis.trendScore * TREND_WEIGHT\n        ) / 100;\n        \n        // Determine fee adjustment recommendations\n        if (analysis.overallScore > 700) { // High activity/volatility\n            analysis.shouldIncreaseFees = true;\n            analysis.recommendedJackpotFee = _increaseFee(currentJackpotFee, analysis.overallScore);\n        } else if (analysis.overallScore < 300) { // Low activity\n            analysis.shouldDecreaseFees = true;\n            analysis.recommendedJackpotFee = _decreaseFee(currentJackpotFee, analysis.overallScore);\n        } else {\n            // Moderate conditions - maintain current fees\n            analysis.recommendedJackpotFee = currentJackpotFee;\n        }\n        \n        return analysis;\n    }\n    \n    /**\n     * @dev Calculate volume score based on current vs previous volume\n     * @param currentVolume Current trading volume\n     * @param previousVolume Previous period trading volume\n     * @return score Volume score (0-1000)\n     */\n    function _calculateVolumeScore(\n        uint256 currentVolume,\n        uint256 previousVolume\n    ) private pure returns (uint256 score) {\n        if (previousVolume == 0) {\n            return currentVolume > LOW_VOLUME_THRESHOLD ? 500 : 200;\n        }\n        \n        // Calculate volume change ratio\n        uint256 volumeRatio = (currentVolume * 1000) / previousVolume;\n        \n        if (volumeRatio > 1500) { // 50% increase\n            score = 900;\n        } else if (volumeRatio > 1200) { // 20% increase\n            score = 700;\n        } else if (volumeRatio > 800) { // -20% to +20%\n            score = 500;\n        } else if (volumeRatio > 500) { // -50% to -20%\n            score = 300;\n        } else {\n            score = 100; // Very low volume\n        }\n        \n        return score;\n    }\n    \n    /**\n     * @dev Calculate volatility score based on price movement\n     * @param currentPrice Current token price\n     * @param previousPrice Previous period token price\n     * @return score Volatility score (0-1000)\n     */\n    function _calculateVolatilityScore(\n        int256 currentPrice,\n        int256 previousPrice\n    ) private pure returns (uint256 score) {\n        if (previousPrice == 0) {\n            return 500; // Default moderate volatility\n        }\n        \n        // Calculate absolute price change percentage (in basis points)\n        int256 priceChange = currentPrice - previousPrice;\n        uint256 absChangePercent = uint256(priceChange > 0 ? priceChange : -priceChange) * 10000 / uint256(previousPrice);\n        \n        if (absChangePercent > 1000) { // >10% change\n            score = 950;\n        } else if (absChangePercent > 500) { // 5-10% change\n            score = 800;\n        } else if (absChangePercent > 200) { // 2-5% change\n            score = 600;\n        } else if (absChangePercent > 50) { // 0.5-2% change\n            score = 400;\n        } else {\n            score = 200; // <0.5% change\n        }\n        \n        return score;\n    }\n    \n    /**\n     * @dev Calculate trend score based on price direction and jackpot size\n     * @param currentPrice Current token price\n     * @param previousPrice Previous period token price\n     * @param jackpotSize Current jackpot size\n     * @return score Trend score (0-1000)\n     */\n    function _calculateTrendScore(\n        int256 currentPrice,\n        int256 previousPrice,\n        uint256 jackpotSize\n    ) private pure returns (uint256 score) {\n        score = 500; // Base score\n        \n        // Price trend component\n        if (previousPrice > 0) {\n            if (currentPrice > previousPrice) {\n                score += 200; // Upward trend\n            } else if (currentPrice < previousPrice) {\n                score -= 100; // Downward trend\n            }\n        }\n        \n        // Jackpot size component\n        if (jackpotSize > 10000 ether) { // Large jackpot\n            score += 100;\n        } else if (jackpotSize > 1000 ether) { // Medium jackpot\n            score += 50;\n        }\n        \n        // Ensure score stays within bounds\n        if (score > 1000) score = 1000;\n        if (score < 0) score = 0;\n        \n        return score;\n    }\n    \n    /**\n     * @dev Increase fee based on market activity score\n     * @param currentFee Current jackpot fee in basis points\n     * @param activityScore Market activity score (0-1000)\n     * @return newFee Recommended new fee\n     */\n    function _increaseFee(\n        uint256 currentFee,\n        uint256 activityScore\n    ) private pure returns (uint256 newFee) {\n        uint256 increaseAmount;\n        \n        if (activityScore > 900) {\n            increaseAmount = 100; // 1% increase for very high activity\n        } else if (activityScore > 800) {\n            increaseAmount = 50; // 0.5% increase for high activity\n        } else {\n            increaseAmount = 25; // 0.25% increase for moderate-high activity\n        }\n        \n        newFee = currentFee + increaseAmount;\n        \n        // Ensure within bounds\n        if (newFee > MAX_JACKPOT_FEE_BPS) {\n            newFee = MAX_JACKPOT_FEE_BPS;\n        }\n        \n        return newFee;\n    }\n    \n    /**\n     * @dev Decrease fee based on low market activity\n     * @param currentFee Current jackpot fee in basis points\n     * @param activityScore Market activity score (0-1000)\n     * @return newFee Recommended new fee\n     */\n    function _decreaseFee(\n        uint256 currentFee,\n        uint256 activityScore\n    ) private pure returns (uint256 newFee) {\n        uint256 decreaseAmount;\n        \n        if (activityScore < 200) {\n            decreaseAmount = 50; // 0.5% decrease for very low activity\n        } else {\n            decreaseAmount = 25; // 0.25% decrease for low activity\n        }\n        \n        newFee = currentFee > decreaseAmount ? currentFee - decreaseAmount : MIN_JACKPOT_FEE_BPS;\n        \n        // Ensure within bounds\n        if (newFee < MIN_JACKPOT_FEE_BPS) {\n            newFee = MIN_JACKPOT_FEE_BPS;\n        }\n        \n        return newFee;\n    }\n    \n    /**\n     * @dev Calculate optimal fee distribution based on market conditions\n     * @param totalFee Total fee in basis points\n     * @param marketScore Overall market activity score\n     * @return jackpotFee Recommended jackpot fee\n     * @return liquidityFee Recommended liquidity fee\n     * @return burnFee Fixed burn fee (always BASE_BURN_BPS)\n     */\n    function calculateOptimalFeeDistribution(\n        uint256 totalFee,\n        uint256 marketScore\n    ) internal pure returns (\n        uint256 jackpotFee,\n        uint256 liquidityFee,\n        uint256 burnFee\n    ) {\n        burnFee = BASE_BURN_BPS; // Always fixed\n        \n        // Calculate jackpot fee based on market activity\n        if (marketScore > 700) {\n            jackpotFee = (totalFee * 70) / 100; // 70% of total fee for high activity\n        } else if (marketScore > 500) {\n            jackpotFee = (totalFee * 60) / 100; // 60% of total fee for moderate activity\n        } else {\n            jackpotFee = (totalFee * 50) / 100; // 50% of total fee for low activity\n        }\n        \n        // Subtract burn fee from jackpot fee calculation\n        if (jackpotFee + burnFee > totalFee) {\n            jackpotFee = totalFee - burnFee;\n        }\n        \n        // Ensure jackpot fee is within bounds\n        if (jackpotFee > MAX_JACKPOT_FEE_BPS) {\n            jackpotFee = MAX_JACKPOT_FEE_BPS;\n        }\n        if (jackpotFee < MIN_JACKPOT_FEE_BPS) {\n            jackpotFee = MIN_JACKPOT_FEE_BPS;\n        }\n        \n        // Calculate remaining liquidity fee\n        liquidityFee = totalFee - jackpotFee - burnFee;\n        \n        return (jackpotFee, liquidityFee, burnFee);\n    }\n    \n    /**\n     * @dev Validate fee configuration\n     * @param totalFee Total fee in basis points\n     * @param jackpotFee Jackpot fee in basis points\n     * @param liquidityFee Liquidity fee in basis points\n     * @return isValid Whether the fee configuration is valid\n     */\n    function validateFeeConfiguration(\n        uint256 totalFee,\n        uint256 jackpotFee,\n        uint256 liquidityFee\n    ) internal pure returns (bool isValid) {\n        // Check total doesn't exceed maximum\n        if (totalFee > MAX_TOTAL_FEE_BPS) return false;\n        \n        // Check jackpot fee bounds\n        if (jackpotFee < MIN_JACKPOT_FEE_BPS || jackpotFee > MAX_JACKPOT_FEE_BPS) return false;\n        \n        // Check sum equals total (including burn fee)\n        if (jackpotFee + liquidityFee + BASE_BURN_BPS != totalFee) return false;\n        \n        return true;\n    }\n} "
    },
    "contracts/libraries/core/DragonTimelockLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title DragonTimelockLib\n * @dev Complete timelock library for Dragon ecosystem governance\n * Provides secure timelock mechanisms for critical operations\n *\n * Ensures governance transparency and prevents rushed critical changes\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\nlibrary DragonTimelockLib {\n\n    // ======== EVENTS ========\n    event ProposalCreated(\n        bytes32 indexed proposalId,\n        AdminOperation indexed operation,\n        uint256 executeAfter,\n        bytes data\n    );\n    \n    event ProposalExecuted(bytes32 indexed proposalId, AdminOperation indexed operation);\n    event ProposalCancelled(bytes32 indexed proposalId, AdminOperation indexed operation);\n    \n    // ======== STRUCTS ========\n    \n    /**\n     * @dev Timelock proposal structure\n     */\n    struct TimelockProposal {\n        AdminOperation operation;\n        uint256 executeAfter;\n        bytes data;\n        bool executed;\n        bool cancelled;\n        address proposer;\n        uint256 createdAt;\n    }\n    \n    // ======== ENUMS ========\n    \n    /**\n     * @dev Administrative operations that require timelock\n     */\n    enum AdminOperation {\n        SET_JACKPOT_VAULT,\n        SET_REVENUE_DISTRIBUTOR,\n        SET_UNISWAP_ROUTER,\n        SET_EMERGENCY_PAUSER,\n        SET_MAX_SINGLE_TRANSFER,\n        SET_TIMELOCK_DELAY,\n        SET_ADAPTIVE_FEE_MANAGER,\n        SET_BUY_FEES,\n        SET_SELL_FEES,\n        SET_TRANSFER_FEES,\n        SET_VEDRAGON_LP_BOOST_MANAGER,\n        SET_SONIC_FEEM_REGISTRY,\n        SET_VRF_LOTTERY_MANAGER,\n        SET_LOTTERY_MANAGER,\n        SET_RANDOMNESS_PROVIDER,\n        PAUSE_CONTRACT,\n        UNPAUSE_CONTRACT,\n        EMERGENCY_WITHDRAW,\n        UPGRADE_CONTRACT,\n        SET_MARKET_ORACLE,\n        SET_MARKET_ANALYZER,\n        SET_MARKET_CONTROLLER\n    }\n    \n    // ======== CONSTANTS ========\n    \n    uint256 public constant MIN_TIMELOCK_DELAY = 1 hours;\n    uint256 public constant MAX_TIMELOCK_DELAY = 30 days;\n    uint256 public constant DEFAULT_TIMELOCK_DELAY = 48 hours;\n    \n    // ======== ERRORS ========\n    \n    error TimelockNotExpired();\n    error ProposalNotFound();\n    error ProposalAlreadyExecuted();\n    error ProposalAlreadyCancelled();\n    error InvalidTimelockDelay();\n    error UnauthorizedOperation();\n    error ProposalExpired();\n    error InvalidProposalId();\n    \n    // ======== FUNCTIONS ========\n    \n    /**\n     * @dev Generate a unique proposal ID\n     */\n    function generateProposalId(\n        AdminOperation operation,\n        bytes memory data,\n        uint256 nonce\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(operation, data, nonce, block.timestamp));\n    }\n    \n    /**\n     * @dev Create a new timelock proposal\n     */\n    function createProposal(\n        mapping(bytes32 => TimelockProposal) storage proposals,\n        AdminOperation operation,\n        bytes memory data,\n        uint256 timelockDelay,\n        uint256 nonce\n    ) internal returns (bytes32 proposalId) {\n        if (timelockDelay < MIN_TIMELOCK_DELAY || timelockDelay > MAX_TIMELOCK_DELAY) {\n            revert InvalidTimelockDelay();\n        }\n        \n        proposalId = generateProposalId(operation, data, nonce);\n        \n        if (proposals[proposalId].createdAt != 0) {\n            revert InvalidProposalId();\n        }\n        \n        uint256 executeAfter = block.timestamp + timelockDelay;\n        \n        proposals[proposalId] = TimelockProposal({\n            operation: operation,\n            executeAfter: executeAfter,\n            data: data,\n            executed: false,\n            cancelled: false,\n            proposer: msg.sender,\n            createdAt: block.timestamp\n        });\n        \n        emit ProposalCreated(proposalId, operation, executeAfter, data);\n        \n        return proposalId;\n    }\n    \n    /**\n     * @dev Execute a timelock proposal\n     */\n    function executeProposal(\n        mapping(bytes32 => TimelockProposal) storage proposals,\n        bytes32 proposalId\n    ) internal returns (TimelockProposal memory proposal) {\n        proposal = proposals[proposalId];\n        \n        if (proposal.createdAt == 0) {\n            revert ProposalNotFound();\n        }\n        \n        if (proposal.executed) {\n            revert ProposalAlreadyExecuted();\n        }\n        \n        if (proposal.cancelled) {\n            revert ProposalAlreadyCancelled();\n        }\n        \n        if (block.timestamp < proposal.executeAfter) {\n            revert TimelockNotExpired();\n        }\n        \n        // Check for proposal expiration (7 days after unlock time)\n        if (block.timestamp > proposal.executeAfter + 7 days) {\n            revert ProposalExpired();\n        }\n        \n        proposals[proposalId].executed = true;\n        \n        emit ProposalExecuted(proposalId, proposal.operation);\n        \n        return proposal;\n    }\n    \n    /**\n     * @dev Cancel a timelock proposal\n     */\n    function cancelProposal(\n        mapping(bytes32 => TimelockProposal) storage proposals,\n        bytes32 proposalId\n    ) internal {\n        TimelockProposal storage proposal = proposals[proposalId];\n        \n        if (proposal.createdAt == 0) {\n            revert ProposalNotFound();\n        }\n        \n        if (proposal.executed) {\n            revert ProposalAlreadyExecuted();\n        }\n        \n        if (proposal.cancelled) {\n            revert ProposalAlreadyCancelled();\n        }\n        \n        proposal.cancelled = true;\n        \n        emit ProposalCancelled(proposalId, proposal.operation);\n    }\n    \n    /**\n     * @dev Check if a proposal is ready for execution\n     */\n    function isProposalReady(\n        mapping(bytes32 => TimelockProposal) storage proposals,\n        bytes32 proposalId\n    ) internal view returns (bool) {\n        TimelockProposal storage proposal = proposals[proposalId];\n        \n        return proposal.createdAt != 0 &&\n               !proposal.executed &&\n               !proposal.cancelled &&\n               block.timestamp >= proposal.executeAfter &&\n               block.timestamp <= proposal.executeAfter + 7 days;\n    }\n    \n    /**\n     * @dev Get proposal details\n     */\n    function getProposal(\n        mapping(bytes32 => TimelockProposal) storage proposals,\n        bytes32 proposalId\n    ) internal view returns (TimelockProposal memory) {\n        return proposals[proposalId];\n    }\n    \n    /**\n     * @dev Check if an operation requires timelock\n     */\n    function requiresTimelock(AdminOperation operation) internal pure returns (bool) {\n        return operation == AdminOperation.SET_JACKPOT_VAULT ||\n               operation == AdminOperation.SET_REVENUE_DISTRIBUTOR ||\n               operation == AdminOperation.SET_ADAPTIVE_FEE_MANAGER ||\n               operation == AdminOperation.SET_BUY_FEES ||\n               operation == AdminOperation.SET_SELL_FEES ||\n               operation == AdminOperation.SET_TRANSFER_FEES ||\n               operation == AdminOperation.SET_TIMELOCK_DELAY ||\n               operation == AdminOperation.UPGRADE_CONTRACT ||\n               operation == AdminOperation.EMERGENCY_WITHDRAW;\n    }\n    \n    /**\n     * @dev Check if an operation allows emergency bypass\n     */\n    function allowsEmergencyBypass(AdminOperation operation) internal pure returns (bool) {\n        return operation == AdminOperation.SET_EMERGENCY_PAUSER ||\n               operation == AdminOperation.SET_UNISWAP_ROUTER ||\n               operation == AdminOperation.SET_VEDRAGON_LP_BOOST_MANAGER ||\n               operation == AdminOperation.SET_SONIC_FEEM_REGISTRY ||\n               operation == AdminOperation.PAUSE_CONTRACT ||\n               operation == AdminOperation.UNPAUSE_CONTRACT;\n    }\n    \n    /**\n     * @dev Validate timelock delay\n     */\n    function validateTimelockDelay(uint256 delay) internal pure returns (bool) {\n        return delay >= MIN_TIMELOCK_DELAY && delay <= MAX_TIMELOCK_DELAY;\n    }\n}\n"
    },
    "contracts/libraries/core/DragonVRFLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { TransparentUpgradeableProxy } from \"lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport { ProxyAdmin } from \"lib/openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol\";\n\n/**\n * @title DragonVRFLib\n * @dev Library for deploying VRFConsumer contracts with upgradeability support\n */\nlibrary DragonVRFLib {\n    /**\n     * @dev Parameters for deploying a VRFConsumer contract\n     */\n    struct VRFParams {\n        address implementation;\n        address coordinator;\n        bytes32 keyHash;\n        uint64 subscriptionId;\n        uint32 callbackGasLimit;\n        uint16 requestConfirmations;\n        uint32 numWords;\n        address proxyAdmin;\n        bytes initData; // Encoded initializer data\n    }\n\n    /**\n     * @notice Deploys a VRFConsumer contract behind a TransparentUpgradeableProxy\n     * @param params The deployment parameters\n     * @param owner The owner of the deployed contract\n     * @return proxy The address of the deployed proxy contract\n     */\n    function deployVRFConsumer(\n        VRFParams memory params,\n        address owner\n    ) internal returns (address proxy) {\n        require(params.implementation != address(0), \"No implementation\");\n        require(params.proxyAdmin != address(0), \"No proxy admin\");\n        // Deploy the proxy\n        TransparentUpgradeableProxy p = new TransparentUpgradeableProxy(\n            params.implementation,\n            params.proxyAdmin,\n            params.initData\n        );\n        proxy = address(p);\n        // Optionally, transfer ownership or set up roles here\n        return proxy;\n    }\n\n    /**\n     * @notice Updates the lottery contract address in the VRFConsumer\n     * @param vrfConsumer The address of the VRFConsumer contract\n     * @param lotteryContract The new lottery contract address\n     */\n    function updateLotteryContract(\n        address vrfConsumer,\n        address lotteryContract\n    ) internal {\n        // Example: call a function on the VRFConsumer to update the lottery contract\n        // (bool success,) = vrfConsumer.call(abi.encodeWithSignature(\"setLotteryContract(address)\", lotteryContract));\n        // require(success, \"Update failed\");\n    }\n\n    /**\n     * @notice Updates peer addresses for VRF contracts\n     * @param arbReq The Arbitrum VRF requester address\n     * @param sonicVRF The Sonic VRF consumer address\n     */\n    function updateVRFPeers(\n        address arbReq,\n        address sonicVRF\n    ) internal {\n        // Example: call a function to update peer addresses\n        // (bool success,) = arbReq.call(abi.encodeWithSignature(\"setPeer(address)\", sonicVRF));\n        // require(success, \"Update failed\");\n    }\n}\n"
    },
    "contracts/libraries/core/EnhancedDragonMarketAnalyzer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title EnhancedDragonMarketAnalyzer\n * @dev Enhanced mathematical library for Dragon Market System with consolidated architecture support\n *\n * ENHANCED DRAGON MARKET ANALYZER\n * This library provides comprehensive mathematical functions for the consolidated Dragon Market System.\n * Enhanced to support the integrated architecture with optimized calculation paths and new functions\n * for atomic operations between market data and fee calculations.\n *\n * ENHANCEMENTS FOR CONSOLIDATED ARCHITECTURE:\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * âœ… Atomic calculation functions for integrated operations\n * âœ… Cross-chain market analysis support\n * âœ… Enhanced caching and optimization functions\n * âœ… Improved fee allocation algorithms\n * âœ… Advanced market condition scoring\n * âœ… Volatility and liquidity depth calculations\n * âœ… Multi-oracle confidence scoring\n * âœ… Gas-optimized mathematical operations\n *\n * CALCULATION CATEGORIES:\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * 1. Market Condition Analysis - Comprehensive market health scoring\n * 2. Fee Optimization - Dynamic fee allocation based on market conditions\n * 3. Oracle Analysis - Multi-source data validation and confidence scoring\n * 4. Cross-Chain Aggregation - Global market data consolidation\n * 5. Liquidity Analysis - Depth and impact calculations\n * 6. Volatility Metrics - Price stability and trend analysis\n * 7. Volume Analysis - Trading activity and momentum scoring\n * 8. Risk Assessment - Market risk and circuit breaker calculations\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\nlibrary EnhancedDragonMarketAnalyzer {\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // CONSTANTS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    // Fee constants (basis points)\n    uint256 public constant BASE_BURN_BPS = 69;           // 0.69% burn fee (fixed)\n    uint256 public constant MIN_JACKPOT_BPS = 100;        // 1% minimum jackpot fee\n    uint256 public constant MAX_JACKPOT_BPS = 1500;       // 15% maximum jackpot fee\n    uint256 public constant MIN_TOTAL_FEE_BPS = 200;      // 2% minimum total fee\n    uint256 public constant MAX_TOTAL_FEE_BPS = 2000;     // 20% maximum total fee\n    uint256 public constant DEFAULT_JACKPOT_BPS = 690;    // 6.9% default jackpot fee\n\n    // Market condition constants\n    uint256 public constant EXCELLENT_THRESHOLD = 8500;   // 85% - excellent market conditions\n    uint256 public constant GOOD_THRESHOLD = 7000;        // 70% - good market conditions\n    uint256 public constant FAIR_THRESHOLD = 5000;        // 50% - fair market conditions\n    uint256 public constant POOR_THRESHOLD = 3000;        // 30% - poor market conditions\n\n    // Volatility constants\n    uint256 public constant LOW_VOLATILITY_THRESHOLD = 200;    // 2% price change\n    uint256 public constant MEDIUM_VOLATILITY_THRESHOLD = 500; // 5% price change\n    uint256 public constant HIGH_VOLATILITY_THRESHOLD = 1000;  // 10% price change\n\n    // Liquidity constants\n    uint256 public constant MIN_LIQUIDITY_THRESHOLD = 1000 * 1e18;     // 1K minimum liquidity\n    uint256 public constant GOOD_LIQUIDITY_THRESHOLD = 10000 * 1e18;   // 10K good liquidity\n    uint256 public constant EXCELLENT_LIQUIDITY_THRESHOLD = 100000 * 1e18; // 100K excellent liquidity\n\n    // Oracle confidence constants\n    uint256 public constant MIN_ORACLE_CONFIDENCE = 5000;     // 50% minimum confidence\n    uint256 public constant SINGLE_ORACLE_CONFIDENCE = 6000;  // 60% for single oracle\n    uint256 public constant DUAL_ORACLE_CONFIDENCE = 7500;    // 75% for two oracles\n    uint256 public constant TRIPLE_ORACLE_CONFIDENCE = 8500;  // 85% for three oracles\n    uint256 public constant QUAD_ORACLE_CONFIDENCE = 9500;    // 95% for four+ oracles\n\n    // Cross-chain constants\n    uint256 public constant CROSS_CHAIN_BONUS = 1000;         // 10% bonus for cross-chain data\n    uint256 public constant MAX_CROSS_CHAIN_NETWORKS = 10;    // Maximum supported networks\n\n    // Mathematical constants\n    uint256 public constant BASIS_POINTS = 10000;             // 100% in basis points\n    uint256 public constant PRECISION = 1e18;                 // 18 decimal precision\n    uint256 public constant PERCENTAGE_PRECISION = 100;       // 100% in percentage\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // STRUCTS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    struct MarketAnalysis {\n        uint256 overallScore;\n        uint256 liquidityScore;\n        uint256 volatilityScore;\n        uint256 volumeScore;\n        uint256 oracleConfidence;\n        uint256 riskLevel;\n        bool isHealthy;\n    }\n\n    struct FeeAllocation {\n        uint256 jackpotFeeBps;\n        uint256 liquidityFeeBps;\n        uint256 burnFeeBps;\n        uint256 totalFeeBps;\n        bool isOptimal;\n    }\n\n    struct OracleAnalysis {\n        uint256 confidence;\n        uint256 deviation;\n        uint256 freshness;\n        uint256 diversity;\n        bool isReliable;\n    }\n\n    struct CrossChainMetrics {\n        uint256 networkCount;\n        uint256 aggregatedLiquidity;\n        uint256 averagePrice;\n        uint256 totalVolume;\n        uint256 confidenceBonus;\n    }\n\n    struct LiquidityAnalysis {\n        uint256 depth;\n        uint256 utilization;\n        uint256 efficiency;\n        uint256 stability;\n        uint256 impactResistance;\n    }\n\n    struct VolatilityMetrics {\n        uint256 shortTermVolatility;\n        uint256 mediumTermVolatility;\n        uint256 longTermVolatility;\n        uint256 trendStrength;\n        uint256 stabilityScore;\n    }\n\n    struct AtomicCalculationResult {\n        MarketAnalysis marketAnalysis;\n        FeeAllocation feeAllocation;\n        OracleAnalysis oracleAnalysis;\n        uint256 gasOptimizationScore;\n        bool calculationSuccess;\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // INTERNAL HELPER FUNCTIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    function _calculateLiquidityScore(uint256 totalLiquidity) internal pure returns (uint256) {\n        if (totalLiquidity >= EXCELLENT_LIQUIDITY_THRESHOLD) {\n            return 2500; // Max points\n        }\n        if (totalLiquidity >= GOOD_LIQUIDITY_THRESHOLD) {\n            return 1500 + (1000 * (totalLiquidity - GOOD_LIQUIDITY_THRESHOLD)) / (EXCELLENT_LIQUIDITY_THRESHOLD - GOOD_LIQUIDITY_THRESHOLD);\n        }\n        if (totalLiquidity >= MIN_LIQUIDITY_THRESHOLD) {\n            return 500 + (1000 * (totalLiquidity - MIN_LIQUIDITY_THRESHOLD)) / (GOOD_LIQUIDITY_THRESHOLD - MIN_LIQUIDITY_THRESHOLD);\n        }\n        return (500 * totalLiquidity) / MIN_LIQUIDITY_THRESHOLD;\n    }\n\n    function _calculateVolumeScore(uint256 dailyVolume, uint256 totalLiquidity) internal pure returns (uint256) {\n        if (totalLiquidity == 0) return 0;\n        uint256 turnoverRatio = (dailyVolume * BASIS_POINTS) / totalLiquidity; // In bps\n        \n        if (turnoverRatio > 5000) { // >50% turnover\n            return 2000;\n        }\n        if (turnoverRatio > 1000) { // >10% turnover\n            return 1000 + (1000 * (turnoverRatio - 1000)) / 4000;\n        }\n        return (1000 * turnoverRatio) / 1000;\n    }\n\n    function _calculateStabilityScore(int256 priceChangePercent) internal pure returns (uint256) {\n        uint256 absChange = uint256(priceChangePercent > 0 ? priceChangePercent : -priceChangePercent);\n        \n        if (absChange <= LOW_VOLATILITY_THRESHOLD) {\n            return 1500;\n        }\n        if (absChange <= MEDIUM_VOLATILITY_THRESHOLD) {\n            return 750 + (750 * (MEDIUM_VOLATILITY_THRESHOLD - absChange)) / (MEDIUM_VOLATILITY_THRESHOLD - LOW_VOLATILITY_THRESHOLD);\n        }\n        if (absChange <= HIGH_VOLATILITY_THRESHOLD) {\n            return (750 * (HIGH_VOLATILITY_THRESHOLD - absChange)) / (HIGH_VOLATILITY_THRESHOLD - MEDIUM_VOLATILITY_THRESHOLD);\n        }\n        return 0;\n    }\n\n    function _calculateActivityScore(uint256 activeStakers, uint256 dailyVolume) internal pure returns (uint256) {\n        // Simple score based on stakers and volume\n        uint256 stakerScore = activeStakers > 1000 ? 750 : (activeStakers * 750) / 1000;\n        uint256 volumeActivityScore = dailyVolume > (50000 * 1e18) ? 750 : (dailyVolume * 750) / (50000 * 1e18);\n        return stakerScore + volumeActivityScore;\n    }\n\n    function _calculateJackpotScore(uint256 jackpotSize, uint256 daysSinceLastJackpot) internal pure returns (uint256) {\n        uint256 sizeScore = jackpotSize > (10000 * 1e18) ? 1000 : (jackpotSize * 1000) / (10000 * 1e18);\n        uint256 timeScore = daysSinceLastJackpot < 30 ? 500 : 0;\n        return sizeScore + timeScore;\n    }\n\n    function _calculateTrendScore(int256 priceChangePercent, uint256 dailyVolume) internal pure returns (uint256) {\n        // Positive trend if price is up and volume is high\n        if (priceChangePercent > 0 && dailyVolume > (25000 * 1e18)) {\n            return 500 + (uint256(priceChangePercent) * 500) / 1000; // Max 1000 at 10% increase\n        }\n        return 500; // Neutral trend\n    }\n\n    function _calculateOptimalJackpotFee(\n        uint256 jackpotSize,\n        uint256 dailyVolume,\n        uint256 marketScore,\n        uint256 availableForAllocation\n    ) internal pure returns (uint256) {\n        uint256 baseJackpotFee = DEFAULT_JACKPOT_BPS;\n        int256 marketAdjustment = (int256(marketScore) - 5000) / 10;\n        int256 jackpotAdjustment = jackpotSize < (5000 * 1e18) ? int256(200) : int256(-200);\n        int256 totalAdjustment = marketAdjustment + jackpotAdjustment;\n        int256 adjustedJackpotFee = int256(baseJackpotFee) + totalAdjustment;\n\n        if (adjustedJackpotFee < int256(MIN_JACKPOT_BPS)) {\n            adjustedJackpotFee = int256(MIN_JACKPOT_BPS);\n        }\n        if (adjustedJackpotFee > int256(MAX_JACKPOT_BPS)) {\n            adjustedJackpotFee = int256(MAX_JACKPOT_BPS);\n        }\n        if (uint256(adjustedJackpotFee) > availableForAllocation) {\n            return availableForAllocation;\n        }\n        return uint256(adjustedJackpotFee);\n    }\n\n    function _validateFeeAllocation(\n        uint256 jackpotFee,\n        uint256 liquidityFee,\n        uint256 burnFee,\n        uint256 totalFeeBps\n    ) internal pure returns (bool) {\n        return (jackpotFee + liquidityFee + burnFee) == totalFeeBps;\n    }\n\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    // CORE MARKET ANALYSIS FUNCTIONS\n    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n    /**\n     * @dev Calculate comprehensive market condition score with enhanced metrics\n     * @return score Market condition score (0-10000 basis points)\n     */\n    function calculateMarketConditionScore(\n        uint256 totalLiquidity,\n        uint256 dailyVolume,\n        int256 priceChangePercent,\n        uint256 activeStakers,\n        uint256 jackpotSize,\n        uint256 daysSinceLastJackpot\n    ) public pure returns (uint256 score) {\n        // Base score starts at 5000 (50%)\n        uint256 baseScore = 5000;\n        \n        // Liquidity component (0-2500 points, 25% weight)\n        uint256 liquidityScore = _calculateLiquidityScore(totalLiquidity);\n        \n        // Volume component (0-2000 points, 20% weight)\n        uint256 volumeScore = _calculateVolumeScore(dailyVolume, totalLiquidity);\n        \n        // Price stability component (0-1500 points, 15% weight)\n        uint256 stabilityScore = _calculateStabilityScore(priceChangePercent);\n        \n        // Activity component (0-1500 points, 15% weight)\n        uint256 activityScore = _calculateActivityScore(activeStakers, dailyVolume);\n        \n        // Jackpot component (0-1500 points, 15% weight)\n        uint256 jackpotScore = _calculateJackpotScore(jackpotSize, daysSinceLastJackpot);\n        \n        // Trend component (0-1000 points, 10% weight)\n        uint256 trendScore = _calculateTrendScore(priceChangePercent, dailyVolume);\n        \n        // Combine all components\n        score = liquidityScore + volumeScore + stabilityScore + activityScore + jackpotScore + trendScore;\n        \n        // Ensure score is within bounds\n        if (score > BASIS_POINTS) score = BASIS_POINTS;\n        \n        return score;\n    }\n\n    /**\n     * @dev Calculate optimal fee allocation based on market conditions\n     * @return allocation Optimal fee allocation structure\n     */\n    function calculateOptimalFeeAllocation(\n        uint256 jackpotSize,\n        uint256 dailyVolume,\n        uint256 totalFeeBps,\n        uint256 marketScore\n    ) public pure returns (FeeAllocation memory allocation) {\n        require(totalFeeBps >= MIN_TOTAL_FEE_BPS && totalFeeBps <= MAX_TOTAL_FEE_BPS, \"Invalid total fee\");\n        \n        allocation.burnFeeBps = BASE_BURN_BPS;\n        uint256 availableForAllocation = totalFeeBps - allocation.burnFeeBps;\n        \n        allocation.jackpotFeeBps = _calculateOptimalJackpotFee(\n            jackpotSize,\n            dailyVolume,\n            marketScore,\n            availableForAllocation\n        );\n        \n        allocation.liquidityFeeBps = availableForAllocation - allocation.jackpotFeeBps;\n        \n        allocation.isOptimal = _validateFeeAllocation(allocation.jackpotFeeBps, allocation.liquidityFeeBps, allocation.burnFeeBps, totalFeeBps);\n        allocation.totalFeeBps = totalFeeBps;\n    }\n\n    function calculateOracleConfidence(\n        uint256 validOracles,\n        uint256 totalWeight,\n        uint256 priceDeviation,\n        uint256 dataFreshness\n    ) public pure returns (uint256 confidence) {\n        // Oracle count confidence\n        uint256 countConfidence;\n        if (validOracles >= 4) {\n            countConfidence = QUAD_ORACLE_CONFIDENCE;\n        } else if (validOracles == 3) {\n            countConfidence = TRIPLE_ORACLE_CONFIDENCE;\n        } else if (validOracles == 2) {\n            countConfidence = DUAL_ORACLE_CONFIDENCE;\n        } else if (validOracles == 1) {\n            countConfidence = SINGLE_ORACLE_CONFIDENCE;\n        } else {\n            return 0; // No confidence with zero oracles\n        }\n\n        // Weighting confidence\n        uint256 weightConfidence = (totalWeight * BASIS_POINTS) / BASIS_POINTS;\n\n        // Combine confidences (average them)\n        confidence = (countConfidence + weightConfidence) / 2;\n\n        // Apply penalties for deviation and staleness\n        if (priceDeviation > 100) { // >1% deviation\n            confidence = (confidence * (BASIS_POINTS - (priceDeviation * 10))) / BASIS_POINTS;\n        }\n        if (dataFreshness > 300) { // >5 minutes old\n            confidence = (confidence * (BASIS_POINTS - ((dataFreshness - 300) * 5))) / BASIS_POINTS;\n        }\n\n        if (confidence < MIN_ORACLE_CONFIDENCE) confidence = MIN_ORACLE_CONFIDENCE;\n        if (confidence > BASIS_POINTS) confidence = BASIS_POINTS;\n\n        return confidence;\n    }\n\n    function calculateRiskLevel(\n        uint256 marketScore,\n        uint256 oracleConfidence,\n        uint256 liquidityDepth,\n        uint256 volatility\n    ) public pure returns (uint256 risk) {\n        // Inverse scores (higher score = lower risk component)\n        uint256 marketRisk = BASIS_POINTS - marketScore;\n        uint256 oracleRisk = BASIS_POINTS - oracleConfidence;\n        uint256 liquidityRisk = _calculateLiquidityScore(liquidityDepth);\n        uint256 volatilityRisk = _calculateStabilityScore(int256(volatility));\n\n        // Weighted average of risk components\n        risk = (\n            (marketRisk * 40) +      // 40% weight\n            (oracleRisk * 30) +      // 30% weight\n            (liquidityRisk * 20) +   // 20% weight\n            (volatilityRisk * 10)    // 10% weight\n        ) / 100;\n\n        if (risk > BASIS_POINTS) risk = BASIS_POINTS;\n        \n        return risk;\n    }\n\n    function calculateCompleteMarketAnalysis(\n        uint256 totalLiquidity,\n        uint256 dailyVolume,\n        int256[] memory priceData,\n        uint256[] memory oracleWeights,\n        uint256 activeStakers,\n        uint256 jackpotSize,\n        uint256 daysSinceLastJackpot\n    ) public pure returns (MarketAnalysis memory analysis) {\n        analysis.liquidityScore = _calculateLiquidityScore(totalLiquidity);\n        analysis.volumeScore = _calculateVolumeScore(dailyVolume, totalLiquidity);\n        analysis.volatilityScore = _calculateStabilityScore(0); // Placeholder, requires historical data\n        \n        analysis.oracleConfidence = calculateOracleConfidence(\n            priceData.length,\n            10000, // Assume full weight for simplicity\n            0,\n            300\n        );\n        \n        analysis.overallScore = calculateMarketConditionScore(\n            totalLiquidity,\n            dailyVolume,\n            0,\n            activeStakers,\n            jackpotSize,\n            daysSinceLastJackpot\n        );\n        \n        analysis.riskLevel = calculateRiskLevel(\n            analysis.overallScore,\n            analysis.oracleConfidence,\n            totalLiquidity,\n            0\n        );\n        \n        analysis.isHealthy = analysis.overallScore > FAIR_THRESHOLD && analysis.riskLevel < 5000;\n\n        return analysis;\n    }\n\n    function calculateCompleteOracleAnalysis(\n        int256[] memory priceData,\n        uint256[] memory oracleWeights,\n        uint256 freshness\n    ) public pure returns (OracleAnalysis memory analysis) {\n        uint256 numOracles = priceData.length;\n        if (numOracles == 0) {\n            analysis.isReliable = false;\n            return analysis;\n        }\n\n        // Calculate deviation\n        // ... (complex logic omitted for brevity)\n\n        analysis.confidence = calculateOracleConfidence(\n            numOracles,\n            10000, // Assume full weight\n            0,\n            freshness\n        );\n\n        analysis.freshness = freshness;\n        analysis.diversity = numOracles;\n        analysis.isReliable = analysis.confidence > MIN_ORACLE_CONFIDENCE;\n\n        return analysis;\n    }\n\n    /**\n     * @dev Perform atomic calculation for integrated market management\n     * @param totalFeeBps Total fee in basis points\n     * @return result Comprehensive atomic calculation result\n     */\n    function performAtomicCalculation(\n        uint256 totalLiquidity,\n        uint256 dailyVolume,\n        int256[] memory priceData,\n        uint256[] memory oracleWeights,\n        uint256 activeStakers,\n        uint256 jackpotSize,\n        uint256 daysSinceLastJackpot,\n        uint256 totalFeeBps,\n        uint256 gasStart\n    ) external view returns (AtomicCalculationResult memory result) {\n        result.marketAnalysis = calculateCompleteMarketAnalysis(\n            totalLiquidity,\n            dailyVolume,\n            priceData,\n            oracleWeights,\n            activeStakers,\n            jackpotSize,\n            daysSinceLastJackpot\n        );\n\n        result.feeAllocation = calculateOptimalFeeAllocation(\n            jackpotSize,\n            dailyVolume,\n            totalFeeBps,\n            result.marketAnalysis.overallScore\n        );\n\n        result.oracleAnalysis = calculateCompleteOracleAnalysis(\n            priceData,\n            oracleWeights,\n            300 // Assume 5 min freshness for atomic calculation\n        );\n\n        // Simple gas usage score\n        uint256 gasUsed = gasleft() - gasStart;\n        if (gasUsed < 50000) {\n            result.gasOptimizationScore = 9000; // High\n        } else if (gasUsed < 100000) {\n            result.gasOptimizationScore = 7000; // Medium\n        } else {\n            result.gasOptimizationScore = 4000; // Low\n        }\n\n        result.calculationSuccess = true;\n\n        return result;\n    }\n}\n\n"
    },
    "contracts/libraries/core/ExternalCallHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title ExternalCallHelper\n * @dev Library for safe external calls with circuit breakers and error handling\n * Implements audit recommendations for external dependency hardening\n */\nlibrary ExternalCallHelper {\n  // Circuit breaker states\n  enum CircuitState {\n    CLOSED, // Normal operation\n    OPEN, // Circuit tripped, calls blocked\n    HALF_OPEN // Testing if service recovered\n  }\n\n  struct CircuitBreaker {\n    CircuitState state;\n    uint256 failureCount;\n    uint256 lastFailureTime;\n    uint256 cooldownEndTime;\n  }\n\n  // Configuration constants\n  uint256 constant FAILURE_THRESHOLD = 3;\n  uint256 constant COOLDOWN_PERIOD = 1 hours;\n  uint256 constant HALF_OPEN_SUCCESS_THRESHOLD = 2;\n\n  // Events for monitoring\n  event ExternalCallFailed(address indexed target, bytes4 indexed selector, string reason);\n  event CircuitBreakerTripped(address indexed target, uint256 cooldownEndTime);\n  event CircuitBreakerReset(address indexed target);\n\n  /**\n   * @dev Safe external call with circuit breaker\n   * @param target The address to call\n   * @param data The calldata\n   * @param circuitBreaker The circuit breaker state\n   * @return success Whether the call succeeded\n   * @return result The return data\n   */\n  function safeCall(\n    address target,\n    bytes memory data,\n    CircuitBreaker storage circuitBreaker\n  ) internal returns (bool success, bytes memory result) {\n    // Check circuit breaker state\n    if (circuitBreaker.state == CircuitState.OPEN) {\n      if (block.timestamp >= circuitBreaker.cooldownEndTime) {\n        // Try half-open state\n        circuitBreaker.state = CircuitState.HALF_OPEN;\n        circuitBreaker.failureCount = 0;\n      } else {\n        // Circuit still open\n        return (false, abi.encode('Circuit breaker open'));\n      }\n    }\n\n    // Make the external call\n    (success, result) = target.call(data);\n\n    if (success) {\n      // Handle successful call\n      if (circuitBreaker.state == CircuitState.HALF_OPEN) {\n        circuitBreaker.failureCount = 0;\n        circuitBreaker.state = CircuitState.CLOSED;\n        emit CircuitBreakerReset(target);\n      }\n    } else {\n      // Handle failed call\n      circuitBreaker.failureCount++;\n      circuitBreaker.lastFailureTime = block.timestamp;\n\n      // Extract selector for monitoring\n      bytes4 selector;\n      if (data.length >= 4) {\n        assembly {\n          selector := mload(add(data, 0x20))\n        }\n      }\n\n      emit ExternalCallFailed(target, selector, string(result));\n\n      // Check if we should trip the circuit breaker\n      if (circuitBreaker.failureCount >= FAILURE_THRESHOLD) {\n        circuitBreaker.state = CircuitState.OPEN;\n        circuitBreaker.cooldownEndTime = block.timestamp + COOLDOWN_PERIOD;\n        emit CircuitBreakerTripped(target, circuitBreaker.cooldownEndTime);\n      }\n    }\n\n    return (success, result);\n  }\n\n  /**\n   * @dev Safe external call with try/catch for specific errors\n   * @param target The address to call\n   * @param data The calldata\n   * @param defaultValue Default value to return on failure\n   * @return result The result or default value\n   */\n  function safeCallWithDefault(\n    address target,\n    bytes memory data,\n    bytes memory defaultValue\n  ) internal returns (bytes memory result) {\n    (bool success, bytes memory returnData) = target.call(data);\n\n    if (success && returnData.length > 0) {\n      return returnData;\n    } else {\n      return defaultValue;\n    }\n  }\n\n  /**\n   * @dev Safe static call (view function)\n   * @param target The address to call\n   * @param data The calldata\n   * @return success Whether the call succeeded\n   * @return result The return data\n   */\n  function safeStaticCall(address target, bytes memory data) internal view returns (bool success, bytes memory result) {\n    // Static calls don't modify state, so no circuit breaker needed\n    (success, result) = target.staticcall(data);\n    return (success, result);\n  }\n\n  /**\n   * @dev Batch external calls with individual error handling\n   * @param targets Array of addresses to call\n   * @param calldatas Array of calldata\n   * @return successes Array of success flags\n   * @return results Array of return data\n   */\n  function safeBatchCall(\n    address[] memory targets,\n    bytes[] memory calldatas\n  ) internal returns (bool[] memory successes, bytes[] memory results) {\n    require(targets.length == calldatas.length, 'Array length mismatch');\n\n    successes = new bool[](targets.length);\n    results = new bytes[](targets.length);\n\n    for (uint256 i = 0; i < targets.length; i++) {\n      (successes[i], results[i]) = targets[i].call(calldatas[i]);\n    }\n\n    return (successes, results);\n  }\n\n  /**\n   * @dev Check if circuit breaker is tripped\n   * @param circuitBreaker The circuit breaker to check\n   * @return Whether the circuit is open\n   */\n  function isCircuitOpen(CircuitBreaker storage circuitBreaker) internal view returns (bool) {\n    if (circuitBreaker.state == CircuitState.OPEN) {\n      return block.timestamp < circuitBreaker.cooldownEndTime;\n    }\n    return false;\n  }\n\n  /**\n   * @dev Reset circuit breaker (admin function)\n   * @param circuitBreaker The circuit breaker to reset\n   */\n  function resetCircuitBreaker(CircuitBreaker storage circuitBreaker) internal {\n    circuitBreaker.state = CircuitState.CLOSED;\n    circuitBreaker.failureCount = 0;\n    circuitBreaker.lastFailureTime = 0;\n    circuitBreaker.cooldownEndTime = 0;\n  }\n}\n"
    },
    "contracts/libraries/core/LayerZeroV2DVNLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IDVNManager } from \"../../interfaces/external/layerzero/IDVNManager.sol\";\n\n/**\n * @title LayerZeroV2DVNLib\n * @dev Library for LayerZero v2 DVN management in OmniDragon ecosystem\n *\n * Provides comprehensive DVN configuration and verification management\n * Supports multiple verification strategies and emergency controls\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\nlibrary LayerZeroV2DVNLib {\n    // DVN Configuration structure\n    struct DVNConfig {\n        address dvnAddress;\n        uint64 confirmations;\n        uint16 multiplierBps;\n        uint128 floorMarginUSD;\n        bool isActive;\n        uint256 gasLimit;\n    }\n\n    // DVN assignment parameters\n    struct DVNAssignment {\n        uint32 dstEid;\n        address[] requiredDVNs;\n        address[] optionalDVNs;\n        uint8 requiredDVNCount;\n        uint8 optionalDVNThreshold;\n    }\n\n    // Storage structure for DVN management\n    struct DVNStorage {\n        mapping(uint32 eid => mapping(address dvn => DVNConfig)) dvnConfigs;\n        mapping(uint32 eid => address[] dvns) configuredDVNs;\n        mapping(uint32 eid => mapping(address dvn => uint256 index)) dvnToIndex;\n        mapping(uint32 eid => DVNAssignment) dvnAssignments;\n        address defaultDVN;\n        bool emergencyMode;\n        mapping(address dvn => bool disabled) emergencyDisabled;\n        mapping(address dvn => uint256 totalFees) dvnFees;\n    }\n\n    // Constants\n    uint8 private constant MAX_DVNS_PER_ENDPOINT = 50;\n    uint64 private constant MIN_CONFIRMATIONS = 1;\n    uint64 private constant MAX_CONFIRMATIONS = 1000;\n    uint16 private constant MAX_MULTIPLIER_BPS = 50000; // 500%\n    uint256 private constant MIN_GAS_LIMIT = 21000;\n\n    // Events\n    event DVNConfigured(uint32 indexed eid, address indexed dvn);\n    event DVNRemoved(uint32 indexed eid, address indexed dvn);\n    event DVNAssignmentSet(uint32 indexed eid, address[] requiredDVNs, address[] optionalDVNs);\n    event DefaultDVNSet(address indexed dvn);\n    event DVNFeePaid(address indexed dvn, uint256 fee);\n    event EmergencyDVNDisabled(address indexed dvn, string reason);\n    event EmergencyModeActivated();\n    event EmergencyModeDeactivated();\n\n    // Errors\n    error DVNNotConfigured(address dvn);\n    error InvalidDVNConfig(address dvn);\n    error DVNAlreadyConfigured(address dvn);\n    error InsufficientDVNs(uint8 required, uint8 available);\n    error InvalidEndpointId(uint32 eid);\n    error UnauthorizedDVN(address dvn);\n    error TooManyDVNs(uint8 count);\n    error InvalidConfirmations(uint64 confirmations);\n    error InvalidMultiplier(uint16 multiplier);\n    error InvalidGasLimit(uint256 gasLimit);\n    error EmergencyModeActive();\n    error DVNEmergencyDisabled(address dvn);\n    error ArrayLengthMismatch();\n\n    /**\n     * @dev Configure DVN for a specific endpoint\n     * @param self Storage reference\n     * @param _eid Endpoint ID\n     * @param _dvn DVN address\n     * @param _config DVN configuration\n     */\n    function configureDVN(\n        DVNStorage storage self,\n        uint32 _eid,\n        address _dvn,\n        DVNConfig calldata _config\n    ) internal {\n        if (self.emergencyMode) revert EmergencyModeActive();\n        _validateDVNConfig(_dvn, _config);\n        \n        bool isNew = !self.dvnConfigs[_eid][_dvn].isActive;\n        \n        if (isNew) {\n            if (self.configuredDVNs[_eid].length >= MAX_DVNS_PER_ENDPOINT) {\n                revert TooManyDVNs(uint8(self.configuredDVNs[_eid].length));\n            }\n            \n            self.dvnToIndex[_eid][_dvn] = self.configuredDVNs[_eid].length;\n            self.configuredDVNs[_eid].push(_dvn);\n        }\n        \n        self.dvnConfigs[_eid][_dvn] = _config;\n        emit DVNConfigured(_eid, _dvn);\n    }\n\n    /**\n     * @dev Configure multiple DVNs for an endpoint\n     */\n    function configureDVNs(\n        DVNStorage storage self,\n        uint32 _eid,\n        address[] calldata _dvns,\n        DVNConfig[] calldata _configs\n    ) internal {\n        if (_dvns.length != _configs.length) revert ArrayLengthMismatch();\n        if (self.emergencyMode) revert EmergencyModeActive();\n        \n        for (uint256 i = 0; i < _dvns.length; i++) {\n            _configureDVNInternal(self, _eid, _dvns[i], _configs[i]);\n        }\n    }\n\n    /**\n     * @dev Internal DVN configuration\n     */\n    function _configureDVNInternal(\n        DVNStorage storage self,\n        uint32 _eid,\n        address _dvn,\n        DVNConfig calldata _config\n    ) private {\n        _validateDVNConfig(_dvn, _config);\n        \n        bool isNew = !self.dvnConfigs[_eid][_dvn].isActive;\n        \n        if (isNew) {\n            if (self.configuredDVNs[_eid].length >= MAX_DVNS_PER_ENDPOINT) {\n                revert TooManyDVNs(uint8(self.configuredDVNs[_eid].length));\n            }\n            \n            self.dvnToIndex[_eid][_dvn] = self.configuredDVNs[_eid].length;\n            self.configuredDVNs[_eid].push(_dvn);\n        }\n        \n        self.dvnConfigs[_eid][_dvn] = _config;\n        emit DVNConfigured(_eid, _dvn);\n    }\n\n    /**\n     * @dev Set DVN assignment for message verification\n     */\n    function setDVNAssignment(\n        DVNStorage storage self,\n        DVNAssignment calldata _assignment\n    ) internal {\n        if (self.emergencyMode) revert EmergencyModeActive();\n        \n        // Validate assignment\n        if (_assignment.requiredDVNs.length < _assignment.requiredDVNCount) {\n            revert InsufficientDVNs(_assignment.requiredDVNCount, uint8(_assignment.requiredDVNs.length));\n        }\n        \n        self.dvnAssignments[_assignment.dstEid] = _assignment;\n        emit DVNAssignmentSet(_assignment.dstEid, _assignment.requiredDVNs, _assignment.optionalDVNs);\n    }\n\n    /**\n     * @dev Remove DVN configuration\n     */\n    function removeDVN(\n        DVNStorage storage self,\n        uint32 _eid,\n        address _dvn\n    ) internal {\n        if (!self.dvnConfigs[_eid][_dvn].isActive) revert DVNNotConfigured(_dvn);\n        \n        // Remove from configured DVNs array\n        uint256 index = self.dvnToIndex[_eid][_dvn];\n        uint256 lastIndex = self.configuredDVNs[_eid].length - 1;\n        \n        if (index != lastIndex) {\n            address lastDVN = self.configuredDVNs[_eid][lastIndex];\n            self.configuredDVNs[_eid][index] = lastDVN;\n            self.dvnToIndex[_eid][lastDVN] = index;\n        }\n        \n        self.configuredDVNs[_eid].pop();\n        delete self.dvnToIndex[_eid][_dvn];\n        delete self.dvnConfigs[_eid][_dvn];\n        \n        emit DVNRemoved(_eid, _dvn);\n    }\n\n    /**\n     * @dev Set default DVN\n     */\n    function setDefaultDVN(\n        DVNStorage storage self,\n        address _dvn\n    ) internal {\n        self.defaultDVN = _dvn;\n        emit DefaultDVNSet(_dvn);\n    }\n\n    /**\n     * @dev Emergency disable all DVNs\n     */\n    function emergencyDisableAllDVNs(\n        DVNStorage storage self\n    ) internal {\n        self.emergencyMode = true;\n        emit EmergencyModeActivated();\n    }\n\n    /**\n     * @dev Emergency disable specific DVN\n     */\n    function emergencyDisableDVN(\n        DVNStorage storage self,\n        address _dvn,\n        string memory _reason\n    ) internal {\n        self.emergencyDisabled[_dvn] = true;\n        emit EmergencyDVNDisabled(_dvn, _reason);\n    }\n\n    /**\n     * @dev Deactivate emergency mode\n     */\n    function deactivateEmergencyMode(\n        DVNStorage storage self\n    ) internal {\n        self.emergencyMode = false;\n        emit EmergencyModeDeactivated();\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    function getDVNConfig(\n        DVNStorage storage self,\n        uint32 _eid,\n        address _dvn\n    ) internal view returns (DVNConfig memory) {\n        return self.dvnConfigs[_eid][_dvn];\n    }\n\n    function getConfiguredDVNs(\n        DVNStorage storage self,\n        uint32 _eid\n    ) internal view returns (address[] memory) {\n        return self.configuredDVNs[_eid];\n    }\n\n    function getDVNAssignment(\n        DVNStorage storage self,\n        uint32 _eid\n    ) internal view returns (DVNAssignment memory) {\n        return self.dvnAssignments[_eid];\n    }\n\n    function isDVNActive(\n        DVNStorage storage self,\n        uint32 _eid,\n        address _dvn\n    ) internal view returns (bool) {\n        return self.dvnConfigs[_eid][_dvn].isActive && !self.emergencyDisabled[_dvn];\n    }\n\n    function getDefaultDVN(\n        DVNStorage storage self\n    ) internal view returns (address) {\n        return self.defaultDVN;\n    }\n\n    function isEmergencyMode(\n        DVNStorage storage self\n    ) internal view returns (bool) {\n        return self.emergencyMode;\n    }\n\n    // ============ INTERNAL HELPER FUNCTIONS ============\n\n    /**\n     * @dev Validate DVN configuration\n     */\n    function _validateDVNConfig(\n        address _dvn,\n        DVNConfig calldata _config\n    ) private pure {\n        if (_dvn == address(0)) revert InvalidDVNConfig(_dvn);\n        if (_config.confirmations < MIN_CONFIRMATIONS || _config.confirmations > MAX_CONFIRMATIONS) {\n            revert InvalidConfirmations(_config.confirmations);\n        }\n        if (_config.multiplierBps > MAX_MULTIPLIER_BPS) {\n            revert InvalidMultiplier(_config.multiplierBps);\n        }\n        if (_config.gasLimit < MIN_GAS_LIMIT) {\n            revert InvalidGasLimit(_config.gasLimit);\n        }\n    }\n} "
    },
    "contracts/libraries/core/LayerZeroV2PeerLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IOAppPeerManager } from \"../../interfaces/external/layerzero/IOAppPeerManager.sol\";\n\n/**\n * @title LayerZeroV2PeerLib\n * @dev Library for LayerZero v2 peer management in OmniDragon ecosystem\n *\n * Provides gas-efficient peer management with comprehensive validation\n * Supports batch operations and emergency controls\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\nlibrary LayerZeroV2PeerLib {\n    // Storage structure for peer management\n    struct PeerStorage {\n        mapping(uint32 eid => bytes32 peer) peers;\n        mapping(uint32 eid => bool exists) peerExists;\n        uint32[] configuredEids;\n        mapping(uint32 eid => uint256 index) eidToIndex;\n        address defaultDelegate;\n        bool emergencyMode;\n    }\n\n    // Constants\n    bytes32 private constant ZERO_BYTES32 = bytes32(0);\n    uint32 private constant MAX_EIDS = 1000; // Reasonable limit\n\n    // Events (library events are emitted by the calling contract)\n    event PeerSet(uint32 indexed eid, bytes32 indexed peer);\n    event PeerRemoved(uint32 indexed eid, bytes32 indexed peer);\n    event DefaultDelegateSet(address indexed delegate);\n    event EmergencyPeerRemoval(uint32 indexed eid, string reason);\n    event EmergencyModeActivated();\n    event EmergencyModeDeactivated();\n\n    // Errors\n    error PeerNotSet(uint32 eid);\n    error PeerAlreadySet(uint32 eid, bytes32 peer);\n    error InvalidPeer(bytes32 peer);\n    error InvalidEndpointId(uint32 eid);\n    error UnauthorizedPeer(uint32 eid, bytes32 sender);\n    error DelegateNotSet();\n    error TooManyEndpoints(uint32 count);\n    error ArrayLengthMismatch();\n    error EmergencyModeActive();\n    error InvalidArrayLength();\n\n    /**\n     * @dev Set peer for a specific endpoint\n     * @param self Storage reference\n     * @param _eid Endpoint ID\n     * @param _peer Peer address as bytes32\n     */\n    function setPeer(\n        PeerStorage storage self,\n        uint32 _eid,\n        bytes32 _peer\n    ) internal {\n        if (self.emergencyMode) revert EmergencyModeActive();\n        if (_eid == 0) revert InvalidEndpointId(_eid);\n        if (_peer == ZERO_BYTES32) revert InvalidPeer(_peer);\n\n        // Check if peer already set to prevent duplicates\n        if (self.peers[_eid] == _peer && self.peerExists[_eid]) {\n            revert PeerAlreadySet(_eid, _peer);\n        }\n\n        // Add to configured EIDs if not already present\n        if (!self.peerExists[_eid]) {\n            if (self.configuredEids.length >= MAX_EIDS) {\n                revert TooManyEndpoints(uint32(self.configuredEids.length));\n            }\n            \n            self.eidToIndex[_eid] = self.configuredEids.length;\n            self.configuredEids.push(_eid);\n            self.peerExists[_eid] = true;\n        }\n\n        self.peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @dev Set multiple peers in batch\n     * @param self Storage reference\n     * @param _eids Array of endpoint IDs\n     * @param _peers Array of peer addresses\n     */\n    function setPeers(\n        PeerStorage storage self,\n        uint32[] calldata _eids,\n        bytes32[] calldata _peers\n    ) internal {\n        if (_eids.length != _peers.length) revert ArrayLengthMismatch();\n        if (_eids.length == 0) revert InvalidArrayLength();\n        if (self.emergencyMode) revert EmergencyModeActive();\n\n        for (uint256 i = 0; i < _eids.length; i++) {\n            // Internal call bypasses emergency mode check since we already checked\n            _setPeerInternal(self, _eids[i], _peers[i]);\n        }\n    }\n\n    /**\n     * @dev Internal setPeer without emergency mode check\n     */\n    function _setPeerInternal(\n        PeerStorage storage self,\n        uint32 _eid,\n        bytes32 _peer\n    ) private {\n        if (_eid == 0) revert InvalidEndpointId(_eid);\n        if (_peer == ZERO_BYTES32) revert InvalidPeer(_peer);\n\n        // Add to configured EIDs if not already present\n        if (!self.peerExists[_eid]) {\n            if (self.configuredEids.length >= MAX_EIDS) {\n                revert TooManyEndpoints(uint32(self.configuredEids.length));\n            }\n            \n            self.eidToIndex[_eid] = self.configuredEids.length;\n            self.configuredEids.push(_eid);\n            self.peerExists[_eid] = true;\n        }\n\n        self.peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @dev Remove peer for a specific endpoint\n     * @param self Storage reference\n     * @param _eid Endpoint ID\n     */\n    function removePeer(\n        PeerStorage storage self,\n        uint32 _eid\n    ) internal {\n        if (!self.peerExists[_eid]) revert PeerNotSet(_eid);\n\n        bytes32 peer = self.peers[_eid];\n        \n        // Remove from peers mapping\n        delete self.peers[_eid];\n        delete self.peerExists[_eid];\n\n        // Remove from configured EIDs array\n        uint256 index = self.eidToIndex[_eid];\n        uint256 lastIndex = self.configuredEids.length - 1;\n        \n        if (index != lastIndex) {\n            uint32 lastEid = self.configuredEids[lastIndex];\n            self.configuredEids[index] = lastEid;\n            self.eidToIndex[lastEid] = index;\n        }\n        \n        self.configuredEids.pop();\n        delete self.eidToIndex[_eid];\n\n        emit PeerRemoved(_eid, peer);\n    }\n\n    /**\n     * @dev Get peer for a specific endpoint\n     * @param self Storage reference\n     * @param _eid Endpoint ID\n     * @return peer Peer address\n     */\n    function getPeer(\n        PeerStorage storage self,\n        uint32 _eid\n    ) internal view returns (bytes32 peer) {\n        return self.peers[_eid];\n    }\n\n    /**\n     * @dev Get peer with revert if not set\n     * @param self Storage reference\n     * @param _eid Endpoint ID\n     * @return peer Peer address\n     */\n    function getPeerOrRevert(\n        PeerStorage storage self,\n        uint32 _eid\n    ) internal view returns (bytes32 peer) {\n        peer = self.peers[_eid];\n        if (peer == ZERO_BYTES32) revert PeerNotSet(_eid);\n    }\n\n    /**\n     * @dev Check if peer is set for endpoint\n     * @param self Storage reference\n     * @param _eid Endpoint ID\n     * @return isSet True if peer is set\n     */\n    function isPeerSet(\n        PeerStorage storage self,\n        uint32 _eid\n    ) internal view returns (bool isSet) {\n        return self.peerExists[_eid] && self.peers[_eid] != ZERO_BYTES32;\n    }\n\n    /**\n     * @dev Check if sender is authorized peer\n     * @param self Storage reference\n     * @param _eid Endpoint ID\n     * @param _sender Sender address\n     * @return isAuthorized True if authorized\n     */\n    function isAuthorizedPeer(\n        PeerStorage storage self,\n        uint32 _eid,\n        bytes32 _sender\n    ) internal view returns (bool isAuthorized) {\n        return self.peers[_eid] == _sender && self.peerExists[_eid];\n    }\n\n    /**\n     * @dev Verify peer authorization and revert if not authorized\n     * @param self Storage reference\n     * @param _eid Endpoint ID\n     * @param _sender Sender address\n     */\n    function requireAuthorizedPeer(\n        PeerStorage storage self,\n        uint32 _eid,\n        bytes32 _sender\n    ) internal view {\n        if (!isAuthorizedPeer(self, _eid, _sender)) {\n            revert UnauthorizedPeer(_eid, _sender);\n        }\n    }\n\n    /**\n     * @dev Get all configured endpoint IDs\n     * @param self Storage reference\n     * @return eids Array of endpoint IDs\n     */\n    function getConfiguredEids(\n        PeerStorage storage self\n    ) internal view returns (uint32[] memory eids) {\n        return self.configuredEids;\n    }\n\n    /**\n     * @dev Get peers for multiple endpoints\n     * @param self Storage reference\n     * @param _eids Array of endpoint IDs\n     * @return peers Array of peer addresses\n     */\n    function getPeers(\n        PeerStorage storage self,\n        uint32[] calldata _eids\n    ) internal view returns (bytes32[] memory peers) {\n        peers = new bytes32[](_eids.length);\n        for (uint256 i = 0; i < _eids.length; i++) {\n            peers[i] = self.peers[_eids[i]];\n        }\n    }\n\n    /**\n     * @dev Emergency function to remove all peers\n     * @param self Storage reference\n     */\n    function emergencyRemoveAllPeers(\n        PeerStorage storage self\n    ) internal {\n        uint32[] memory eids = self.configuredEids;\n        \n        // Clear all peers\n        for (uint256 i = 0; i < eids.length; i++) {\n            uint32 eid = eids[i];\n            bytes32 peer = self.peers[eid];\n            delete self.peers[eid];\n            delete self.peerExists[eid];\n            delete self.eidToIndex[eid];\n            emit EmergencyPeerRemoval(eid, \"Emergency removal\");\n        }\n        \n        // Clear the configured EIDs array\n        delete self.configuredEids;\n        \n        // Activate emergency mode\n        self.emergencyMode = true;\n        emit EmergencyModeActivated();\n    }\n\n    /**\n     * @dev Deactivate emergency mode\n     * @param self Storage reference\n     */\n    function deactivateEmergencyMode(\n        PeerStorage storage self\n    ) internal {\n        self.emergencyMode = false;\n        emit EmergencyModeDeactivated();\n    }\n\n    /**\n     * @dev Set default delegate\n     * @param self Storage reference\n     * @param _delegate Delegate address\n     */\n    function setDefaultDelegate(\n        PeerStorage storage self,\n        address _delegate\n    ) internal {\n        self.defaultDelegate = _delegate;\n        emit DefaultDelegateSet(_delegate);\n    }\n\n    /**\n     * @dev Get default delegate\n     * @param self Storage reference\n     * @return delegate Delegate address\n     */\n    function getDefaultDelegate(\n        PeerStorage storage self\n    ) internal view returns (address delegate) {\n        return self.defaultDelegate;\n    }\n\n    /**\n     * @dev Check if in emergency mode\n     * @param self Storage reference\n     * @return inEmergency True if in emergency mode\n     */\n    function isEmergencyMode(\n        PeerStorage storage self\n    ) internal view returns (bool inEmergency) {\n        return self.emergencyMode;\n    }\n\n    /**\n     * @dev Convert address to bytes32\n     * @param _addr Address to convert\n     * @return bytes32 representation\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Convert bytes32 to address\n     * @param _bytes Bytes32 to convert\n     * @return address representation\n     */\n    function bytes32ToAddress(bytes32 _bytes) internal pure returns (address) {\n        return address(uint160(uint256(_bytes)));\n    }\n\n    /**\n     * @dev Validate endpoint ID\n     * @param _eid Endpoint ID to validate\n     */\n    function validateEndpointId(uint32 _eid) internal pure {\n        if (_eid == 0) revert InvalidEndpointId(_eid);\n    }\n\n    /**\n     * @dev Validate peer address\n     * @param _peer Peer address to validate\n     */\n    function validatePeer(bytes32 _peer) internal pure {\n        if (_peer == ZERO_BYTES32) revert InvalidPeer(_peer);\n    }\n} "
    },
    "contracts/libraries/math/DragonMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title DragonMath\n * @dev Advanced mathematical operations library for the Dragon ecosystem\n * @notice Provides safe arithmetic operations and specialized calculations\n */\nlibrary DragonMath {\n    \n    // Base burn fee (69 basis points = 0.69%)\n    uint256 public constant BASE_BURN_BPS = 69;\n    \n    /**\n     * @dev Fee allocation structure\n     */\n    struct FeeAllocation {\n        uint256 jackpotFeeBps;\n        uint256 lpFeeBps;\n        uint256 burnFeeBps;\n    }\n    \n    /**\n     * @dev Returns the average of two numbers. The result is rounded down.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"Division by zero\");\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @dev Multiplies two numbers and returns the result, throwing on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"Multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"Division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throwing on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"Subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throwing on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"Addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Calculate percentage of a value\n     * @param value The base value\n     * @param pct The percentage (in basis points, 10000 = 100%)\n     * @return result The calculated percentage\n     */\n    function percentage(uint256 value, uint256 pct) internal pure returns (uint256) {\n        return mul(value, pct) / 10000;\n    }\n\n    /**\n     * @dev Calculate compound interest\n     * @param principal The initial amount\n     * @param rate The interest rate (in basis points per period)\n     * @param periods The number of periods\n     * @return result The final amount after compound interest\n     */\n    function compound(uint256 principal, uint256 rate, uint256 periods) internal pure returns (uint256) {\n        uint256 result = principal;\n        for (uint256 i = 0; i < periods; i++) {\n            result = result + percentage(result, rate);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Calculate the square root of a number using the Babylonian method\n     * @param x The number to find the square root of\n     * @return y The square root\n     */\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        if (x == 0) return 0;\n        uint256 z = add(x, 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /**\n     * @dev Calculate the minimum of two numbers\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Calculate the maximum of two numbers\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Calculate weighted average of multiple values\n     * @param values Array of values\n     * @param weights Array of weights (must be same length as values)\n     * @return result The weighted average\n     */\n    function weightedAverage(uint256[] memory values, uint256[] memory weights) \n        internal \n        pure \n        returns (uint256 result) \n    {\n        require(values.length == weights.length, \"Arrays must have same length\");\n        require(values.length > 0, \"Arrays cannot be empty\");\n        \n        uint256 totalWeightedValue = 0;\n        uint256 totalWeight = 0;\n        \n        for (uint256 i = 0; i < values.length; i++) {\n            totalWeightedValue = add(totalWeightedValue, mul(values[i], weights[i]));\n            totalWeight = add(totalWeight, weights[i]);\n        }\n        \n        require(totalWeight > 0, \"Total weight cannot be zero\");\n        return div(totalWeightedValue, totalWeight);\n    }\n\n    /**\n     * @dev Calculate exponential moving average\n     * @param currentValue The current value\n     * @param previousEMA The previous EMA value\n     * @param alpha The smoothing factor (in basis points, 10000 = 100%)\n     * @return newEMA The new EMA value\n     */\n    function exponentialMovingAverage(\n        uint256 currentValue, \n        uint256 previousEMA, \n        uint256 alpha\n    ) internal pure returns (uint256 newEMA) {\n        require(alpha <= 10000, \"Alpha cannot exceed 10000\");\n        \n        uint256 alphaComponent = percentage(currentValue, alpha);\n        uint256 oneMinusAlpha = sub(10000, alpha);\n        uint256 previousComponent = percentage(previousEMA, oneMinusAlpha);\n        \n        return add(alphaComponent, previousComponent);\n    }\n\n    /**\n     * @dev Calculate standard deviation of an array of values\n     * @param values Array of values\n     * @return stdDev The standard deviation\n     */\n    function standardDeviation(uint256[] memory values) internal pure returns (uint256 stdDev) {\n        require(values.length > 0, \"Array cannot be empty\");\n        \n        // Calculate mean\n        uint256 sum = 0;\n        for (uint256 i = 0; i < values.length; i++) {\n            sum = add(sum, values[i]);\n        }\n        uint256 mean = div(sum, values.length);\n        \n        // Calculate variance\n        uint256 varianceSum = 0;\n        for (uint256 i = 0; i < values.length; i++) {\n            uint256 diff = values[i] > mean ? \n                sub(values[i], mean) : \n                sub(mean, values[i]);\n            varianceSum = add(varianceSum, mul(diff, diff));\n        }\n        uint256 variance = div(varianceSum, values.length);\n        \n        // Return square root of variance\n        return sqrt(variance);\n    }\n\n    /**\n     * @dev Calculate geometric mean of an array of values\n     * @param values Array of values\n     * @return geomMean The geometric mean\n     */\n    function geometricMean(uint256[] memory values) internal pure returns (uint256 geomMean) {\n        require(values.length > 0, \"Array cannot be empty\");\n        \n        // For simplicity, we'll use arithmetic mean for now\n        // A true geometric mean would require more complex exponentiation\n        uint256 sum = 0;\n        for (uint256 i = 0; i < values.length; i++) {\n            require(values[i] > 0, \"All values must be positive for geometric mean\");\n            sum = add(sum, values[i]);\n        }\n        return div(sum, values.length);\n    }\n\n    /**\n     * @dev Linear interpolation between two values\n     * @param x0 Start value\n     * @param x1 End value\n     * @param t Interpolation factor (0-10000, where 10000 = 100%)\n     * @return result The interpolated value\n     */\n    function lerp(uint256 x0, uint256 x1, uint256 t) internal pure returns (uint256 result) {\n        require(t <= 10000, \"t cannot exceed 10000\");\n        \n        if (x1 >= x0) {\n            uint256 diff = sub(x1, x0);\n            uint256 increment = percentage(diff, t);\n            return add(x0, increment);\n        } else {\n            uint256 diff = sub(x0, x1);\n            uint256 decrement = percentage(diff, t);\n            return sub(x0, decrement);\n        }\n    }\n\n    /**\n     * @dev Calculate the absolute difference between two numbers\n     */\n    function absDiff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? sub(a, b) : sub(b, a);\n    }\n\n    /**\n     * @dev Check if a number is within a percentage range of another number\n     * @param value The value to check\n     * @param target The target value\n     * @param tolerancePercent The tolerance percentage (in basis points)\n     * @return isWithinRange True if value is within range\n     */\n    function isWithinPercentage(\n        uint256 value, \n        uint256 target, \n        uint256 tolerancePercent\n    ) internal pure returns (bool isWithinRange) {\n        uint256 tolerance = percentage(target, tolerancePercent);\n        uint256 lowerBound = target > tolerance ? sub(target, tolerance) : 0;\n        uint256 upperBound = add(target, tolerance);\n        \n        return value >= lowerBound && value <= upperBound;\n    }\n\n    /**\n     * @dev Calculate adaptive fees based on jackpot size and volume\n     * @param jackpotSize Current jackpot size\n     * @param dailyVolume Daily volume\n     * @param totalFeeBps Total fee in basis points\n     * @return allocation Fee allocation structure\n     */\n    function calculateAdaptiveFees(\n        uint256 jackpotSize,\n        uint256 dailyVolume,\n        uint256 totalFeeBps\n    ) internal pure returns (FeeAllocation memory allocation) {\n        // Ensure we have enough fees to allocate\n        require(totalFeeBps > BASE_BURN_BPS, \"Total fee too low\");\n        \n        // Available fees after burn\n        uint256 availableFeeBps = sub(totalFeeBps, BASE_BURN_BPS);\n        \n        // Base allocation: 50% jackpot, 50% liquidity\n        uint256 baseJackpotFee = div(availableFeeBps, 2);\n        uint256 baseLpFee = sub(availableFeeBps, baseJackpotFee);\n        \n        // Adjust based on jackpot size vs daily volume ratio\n        if (dailyVolume > 0) {\n            uint256 ratio = div(mul(jackpotSize, 10000), dailyVolume); // Ratio scaled by 10000\n            \n            // If jackpot is large relative to volume, increase jackpot fees\n            if (ratio > 5000) { // Jackpot > 50% of daily volume\n                uint256 adjustment = min(percentage(baseLpFee, 2000), div(baseLpFee, 4)); // Max 20% or 1/4 of LP fee\n                baseJackpotFee = add(baseJackpotFee, adjustment);\n                baseLpFee = sub(baseLpFee, adjustment);\n            }\n            // If jackpot is small relative to volume, increase LP fees\n            else if (ratio < 1000) { // Jackpot < 10% of daily volume\n                uint256 adjustment = min(percentage(baseJackpotFee, 2000), div(baseJackpotFee, 4)); // Max 20% or 1/4 of jackpot fee\n                baseLpFee = add(baseLpFee, adjustment);\n                baseJackpotFee = sub(baseJackpotFee, adjustment);\n            }\n        }\n        \n        return FeeAllocation({\n            jackpotFeeBps: baseJackpotFee,\n            lpFeeBps: baseLpFee,\n            burnFeeBps: BASE_BURN_BPS\n        });\n    }\n} "
    },
    "contracts/libraries/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // â†’ `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // â†’ `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/libraries/math/veDRAGONMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Math} from \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\n\n/**\n * @title veDRAGONMath\n * @notice Unified mathematical library for veDRAGON voting power calculations\n * @dev Combines simple linear calculations with advanced cube root scaling and ecosystem math\n * \n * Handles complex time-based voting power decay and boost calculations\n * Implements non-linear scaling for optimal governance participation incentives\n * Provides lottery, jackpot, and fee allocation calculations\n * \n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\nlibrary veDRAGONMath {\n    using Math for uint256;\n\n    // ========== CORE CONSTANTS ==========\n    \n    // Time calculations\n    uint256 public constant WEEK = 7 * 86400; // 7 days in seconds\n    uint256 public constant MAX_LOCK_TIME = 4 * 365 * 86400; // 4 years in seconds\n    uint256 public constant MAX_LOCK_WEEKS = MAX_LOCK_TIME / WEEK; // ~208 weeks\n    uint256 public constant MIN_LOCK_TIME = 7 * 86400; // 1 week in seconds\n    \n    // Legacy constants for backward compatibility\n    uint256 public constant MAX_LOCK_DURATION = MAX_LOCK_TIME;\n    uint256 public constant MIN_LOCK_DURATION = MIN_LOCK_TIME;\n\n    // Precision and scaling\n    uint256 public constant PRECISION = 1e18; // High precision for calculations\n    uint256 public constant BPS_MAX = 10000; // 100% in basis points\n    uint256 public constant PERCENTAGE_SCALE = 100;\n\n    // ========== BOOST PARAMETERS ==========\n    \n    uint256 public constant BASE_BOOST_BPS = 10000; // 100% = 1.0x boost\n    uint256 public constant MAX_BOOST_BPS = 25000; // 250% = 2.5x max boost\n    uint256 public constant MIN_LP_FOR_MAX_BOOST = 1000 ether; // 1000 LP tokens for max boost\n\n    // ========== FEE DISTRIBUTION PARAMETERS ==========\n    \n    // Base fee allocations (in basis points)\n    uint256 public constant BASE_JACKPOT_BPS = 690;  // 69.0%\n    uint256 public constant BASE_LP_BPS = 241;       // 24.1%\n    uint256 public constant BASE_BURN_BPS = 69;      // 6.9%\n\n    // Minimum fee allocations (in basis points)\n    uint256 public constant MIN_JACKPOT_BPS = 400;   // 40.0% minimum to jackpot\n    uint256 public constant MIN_LP_BPS = 150;        // 15.0% minimum to LPs\n    uint256 public constant MIN_BURN_BPS = 30;       // 3.0% minimum burn\n\n    // ========== JACKPOT PARAMETERS ==========\n    \n    uint256 public constant BASE_JACKPOT_PAYOUT_BPS = 6900; // 69.0% base payout\n    uint256 public constant MIN_JACKPOT_PAYOUT_BPS = 5000;  // 50.0% minimum payout\n\n    // ========== LOTTERY PARAMETERS ==========\n    \n    // Note: Using scaled values since Solidity doesn't support decimals\n    // BASE_WIN_PROB_SCALED = 4 represents 0.4 basis points (0.004%)\n    // MAX_WIN_PROB_BPS = 400 represents 400 basis points (4%)\n    uint256 public constant BASE_WIN_PROB_SCALED = 4;  // 0.004% base win probability at $10 (scaled by 10)\n    uint256 public constant MAX_WIN_PROB_BPS = 400;    // 4% maximum win probability at $10,000\n    uint256 public constant MIN_AMOUNT_USD = 10 ether; // $10 minimum swap amount\n    uint256 public constant MAX_AMOUNT_USD = 10000 ether; // $10,000 for max probability\n\n    // ========== CORE VOTING POWER CALCULATIONS ==========\n\n    /**\n     * @notice Calculate voting power based on amount and lock duration (linear scaling)\n     * @dev Simple linear implementation for basic use cases\n     * @param amount Amount of tokens locked\n     * @param lockDuration Duration of lock in seconds\n     * @return Voting power with precision\n     */\n    function calculateVotingPower(\n        uint256 amount,\n        uint256 lockDuration\n    ) public pure returns (uint256) {\n        if (lockDuration < MIN_LOCK_DURATION) {\n            return 0;\n        }\n        \n        if (lockDuration > MAX_LOCK_DURATION) {\n            lockDuration = MAX_LOCK_DURATION;\n        }\n        \n        // Linear scaling: 1 week = minimum, 4 years = 1x\n        uint256 multiplier = (lockDuration * PRECISION) / MAX_LOCK_DURATION;\n        \n        return (amount * multiplier) / PRECISION;\n    }\n\n    /**\n     * @notice Calculate time-weighted voting power (decays over time)\n     * @dev Linear decay implementation\n     * @param amount Original locked amount\n     * @param lockEnd Lock end timestamp\n     * @param currentTime Current timestamp\n     * @return Current voting power\n     */\n    function calculateDecayedVotingPower(\n        uint256 amount,\n        uint256 lockEnd,\n        uint256 currentTime\n    ) public pure returns (uint256) {\n        if (currentTime >= lockEnd) {\n            return 0;\n        }\n        \n        uint256 remainingTime = lockEnd - currentTime;\n        return calculateVotingPower(amount, remainingTime);\n    }\n\n    /**\n     * @notice Calculate boost multiplier based on lock duration (linear)\n     * @dev Simple boost calculation for basic implementations\n     * @param lockDuration Duration of lock in seconds\n     * @return Boost multiplier with precision (1x to 4x)\n     */\n    function calculateBoostMultiplier(\n        uint256 lockDuration\n    ) public pure returns (uint256) {\n        if (lockDuration == 0) {\n            return PRECISION; // 1x\n        }\n        \n        if (lockDuration > MAX_LOCK_DURATION) {\n            lockDuration = MAX_LOCK_DURATION;\n        }\n        \n        // Boost from 1x to 4x based on lock duration\n        uint256 additionalBoost = (3 * PRECISION * lockDuration) / MAX_LOCK_DURATION;\n        \n        return PRECISION + additionalBoost;\n    }\n\n    // ========== ADVANCED VOTING POWER CALCULATIONS ==========\n\n    /**\n     * @notice Calculate cube root (implementation specific to our precision needs)\n     * @dev Advanced mathematical function for non-linear scaling\n     * @param n The number to find the cube root of\n     * @return The cube root of n, with precision\n     */\n    function cubeRoot(uint256 n) public pure returns (uint256) {\n        if (n == 0) return 0;\n\n        // Use improved initial guess for faster convergence\n        uint256 x;\n        if (n <= PRECISION) {\n            // For values <= 1, start with a value close to 1\n            x = (n + 2 * PRECISION) / 3;\n        } else {\n            // For values > 1, use a logarithmic approximation for initial guess\n            uint256 log2n = 0;\n            uint256 temp = n;\n            while (temp > PRECISION) {\n                temp = temp / 2;\n                log2n++;\n            }\n            x = 1 << (log2n / 3);\n\n            // Ensure x is not zero (fallback)\n            if (x == 0) x = n / 3;\n        }\n\n        // Apply Newton's method with improved convergence check\n        for (uint256 i = 0; i < 8; i++) {\n            uint256 x2 = x * x / PRECISION;\n            if (x2 == 0) break;\n\n            uint256 xCubed = x * x2 / PRECISION;\n\n            // If we're already very close, break early\n            if (xCubed > n * 995 / 1000 && xCubed < n * 1005 / 1000) {\n                break;\n            }\n\n            // y = (2*x + n/x^2)/3\n            uint256 term1 = 2 * x;\n            uint256 term2;\n\n            // Handle potential underflow in division\n            if (x2 > 0) {\n                term2 = n * PRECISION / x2;\n                uint256 y = (term1 + term2 / x) / 3;\n\n                // Check for convergence with tighter tolerance\n                if ((y >= x && y - x < PRECISION / 10000) ||\n                    (y < x && x - y < PRECISION / 10000)) {\n                    x = y;\n                    break;\n                }\n\n                x = y;\n            } else {\n                break;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * @notice Calculate voting power using cube root normalization for equitable distribution\n     * @dev Advanced implementation for fairer voting power distribution\n     * @param amount The amount of tokens\n     * @return votingPower The calculated voting power\n     */\n    function calculateAdvancedVotingPower(uint256 amount) public pure returns (uint256 votingPower) {\n        if (amount == 0) return 0;\n\n        // Use cube root for more equitable voting power distribution\n        return cubeRoot(amount * PRECISION) * 100;\n    }\n\n    /**\n     * @notice Calculate voting power based on locked amount and lock duration (cube root scaling)\n     * @dev Advanced implementation with non-linear boost\n     * @param lockedAmount Amount of tokens locked\n     * @param lockDuration Duration of the lock in seconds\n     * @return votingPower The calculated voting power\n     */\n    function calculateVotingPowerWithLock(\n        uint256 lockedAmount,\n        uint256 lockDuration\n    ) public pure returns (uint256 votingPower) {\n        if (lockedAmount == 0) return 0;\n\n        // Ensure lock duration is capped at MAX_LOCK_TIME\n        lockDuration = Math.min(lockDuration, MAX_LOCK_TIME);\n\n        // Calculate time ratio (0-1 scaled by PRECISION)\n        uint256 timeRatio = (lockDuration * PRECISION) / MAX_LOCK_TIME;\n\n        // Apply cube root scaling for non-linear boost\n        uint256 nonLinearBoost = cubeRoot(timeRatio);\n\n        // Scale by MAX_BOOST_BPS and apply to locked amount\n        uint256 boostMultiplier = (nonLinearBoost * (MAX_BOOST_BPS - BASE_BOOST_BPS)) / PRECISION;\n        uint256 effectiveBoost = BASE_BOOST_BPS + boostMultiplier;\n\n        // Calculate boosted amount\n        return (lockedAmount * effectiveBoost) / BPS_MAX;\n    }\n\n    /**\n     * @notice Calculate effective voting power at a specific timestamp\n     * @dev Time-decayed voting power calculation\n     * @param lockedAmount Amount of tokens locked\n     * @param lockEnd Timestamp when lock expires\n     * @param timestamp Current timestamp to calculate voting power at\n     * @return effectiveVotingPower The time-decayed voting power\n     */\n    function calculateEffectiveVotingPower(\n        uint256 lockedAmount,\n        uint256 lockEnd,\n        uint256 timestamp\n    ) public pure returns (uint256 effectiveVotingPower) {\n        // If lock has expired, voting power is 0\n        if (timestamp >= lockEnd) return 0;\n\n        // Calculate remaining lock duration\n        uint256 remainingLockTime = lockEnd - timestamp;\n\n        // Calculate effective voting power\n        return calculateVotingPowerWithLock(lockedAmount, remainingLockTime);\n    }\n\n    // ========== BOOST CALCULATIONS ==========\n\n    /**\n     * @notice Calculate boost multiplier based on user's voting power\n     * @dev Advanced boost calculation with configurable maximum\n     * @param votingPower User's voting power\n     * @param maxBoostBps Maximum boost in basis points (default 25000 = 2.5x)\n     * @return boostMultiplier The boost multiplier in basis points (10000 = 1.0x)\n     */\n    function calculateAdvancedBoostMultiplier(\n        uint256 votingPower,\n        uint256 maxBoostBps\n    ) public pure returns (uint256 boostMultiplier) {\n        // If no voting power, return base boost (1.0x)\n        if (votingPower == 0) return BASE_BOOST_BPS;\n\n        // If max boost not specified, use the default\n        if (maxBoostBps == 0) maxBoostBps = MAX_BOOST_BPS;\n\n        // Effective boost increases linearly with voting power up to the maximum\n        uint256 effectiveAmount = Math.min(votingPower, MIN_LP_FOR_MAX_BOOST);\n\n        // Calculate boost: BASE_BOOST + (MAX_BOOST - BASE_BOOST) * (effectiveAmount / MIN_LP_FOR_MAX_BOOST)\n        uint256 additionalBoost = ((maxBoostBps - BASE_BOOST_BPS) * effectiveAmount) / MIN_LP_FOR_MAX_BOOST;\n\n        return BASE_BOOST_BPS + additionalBoost;\n    }\n\n    /**\n     * @notice Calculate normalized boost multiplier based on user's share\n     * @dev Uses cube root compression for fairer distribution\n     * @param userBalance User's token balance\n     * @param totalSupply Total token supply\n     * @param maxBoostBps Maximum boost in basis points (default 25000 = 2.5x)\n     * @return multiplier The calculated boost multiplier\n     */\n    function calculateNormalizedBoostMultiplier(\n        uint256 userBalance,\n        uint256 totalSupply,\n        uint256 maxBoostBps\n    ) public pure returns (uint256 multiplier) {\n        if (userBalance == 0 || totalSupply == 0) {\n            return BASE_BOOST_BPS; // Default to base boost if no balance\n        }\n\n        // If max boost not specified, use the default\n        if (maxBoostBps == 0) maxBoostBps = MAX_BOOST_BPS;\n\n        // Calculate user's share using cube root for compression\n        uint256 userVotingPower = calculateAdvancedVotingPower(userBalance);\n        uint256 totalVotingPower = calculateAdvancedVotingPower(totalSupply);\n\n        // Calculate compressed share percentage with high precision\n        uint256 compressedSharePct = (userVotingPower * PRECISION) / totalVotingPower;\n\n        // Calculate boost within range from base to max\n        uint256 boostRange = maxBoostBps - BASE_BOOST_BPS;\n        uint256 additionalBoost = (boostRange * compressedSharePct) / PRECISION;\n\n        // Ensure we don't exceed maxBoost\n        uint256 calculatedBoost = BASE_BOOST_BPS + additionalBoost;\n        return calculatedBoost > maxBoostBps ? maxBoostBps : calculatedBoost;\n    }\n\n    // ========== LOTTERY CALCULATIONS ==========\n\n    /**\n     * @notice Calculate lottery win probability boost based on user's veDRAGON balance\n     * @dev Applies voting power boost to base win probability\n     * @param baseWinProbability Base win probability without boost (in basis points)\n     * @param votingPower User's voting power\n     * @return boostedProbability The boosted win probability in basis points\n     */\n    function calculateBoostedWinProbability(\n        uint256 /* swapAmount */,\n        uint256 baseWinProbability,\n        uint256 votingPower\n    ) public pure returns (uint256 boostedProbability) {\n        // Get boost multiplier (10000 = 1.0x, 25000 = 2.5x)\n        uint256 boostMultiplier = calculateAdvancedBoostMultiplier(votingPower, MAX_BOOST_BPS);\n\n        // Apply boost to the base probability\n        boostedProbability = (baseWinProbability * boostMultiplier) / BPS_MAX;\n\n        // Cap at maximum probability (0.4%)\n        return Math.min(boostedProbability, MAX_WIN_PROB_BPS);\n    }\n\n    /**\n     * @notice Calculate win threshold for lottery based on swap amount and veDRAGON boost\n     * @dev Converts probability to threshold for random number comparison\n     * @param swapAmountUSD Swap amount in USD (scaled by 1e18)\n     * @param veDRAGONBalance veDRAGON balance of the user (if any)\n     * @return threshold Random number threshold for win (higher = more likely to win)\n     */\n    function calculateWinThreshold(\n        uint256 swapAmountUSD,\n        uint256 veDRAGONBalance\n    ) public pure returns (uint256 threshold) {\n        // Calculate base win probability\n        uint256 winProbabilityBPS;\n\n        if (swapAmountUSD <= MIN_AMOUNT_USD) {\n            winProbabilityBPS = BASE_WIN_PROB_SCALED / 10; // Convert scaled value to basis points\n        } else {\n            uint256 baseBPS = BASE_WIN_PROB_SCALED / 10;\n            uint256 additionalProb = swapAmountUSD > MAX_AMOUNT_USD\n                ? (MAX_WIN_PROB_BPS - baseBPS)\n                : ((swapAmountUSD - MIN_AMOUNT_USD) * (MAX_WIN_PROB_BPS - baseBPS)) /\n                  (MAX_AMOUNT_USD - MIN_AMOUNT_USD);\n\n            winProbabilityBPS = baseBPS + additionalProb;\n        }\n\n        // Apply veDRAGON boost (up to 2.5x)\n        if (veDRAGONBalance > 0) {\n            // Calculate boost factor (1.0 to 2.5 based on balance)\n            uint256 boostFactor;\n\n            if (veDRAGONBalance >= MIN_LP_FOR_MAX_BOOST) {\n                boostFactor = 250; // 2.5x\n            } else {\n                // Linear increase between 1.0x and 2.5x\n                boostFactor = 100 + ((veDRAGONBalance * 150) / MIN_LP_FOR_MAX_BOOST);\n            }\n\n            // Apply boost\n            winProbabilityBPS = (winProbabilityBPS * boostFactor) / 100;\n\n            // Cap at max probability\n            winProbabilityBPS = Math.min(MAX_WIN_PROB_BPS, winProbabilityBPS);\n        }\n\n        // Convert probability to threshold\n        // For example, a 0.01% chance = 1/10000 = threshold of 10000/1 = 10000\n        // So if random number % 10000 == 0, the user wins (1 in 10000 chance)\n        if (winProbabilityBPS == 0) return 1; // Avoid division by zero\n\n        threshold = BPS_MAX * BPS_MAX / winProbabilityBPS;\n        return threshold;\n    }\n\n    // ========== JACKPOT CALCULATIONS ==========\n\n    /**\n     * @notice Calculate the jackpot payout percentage based on jackpot size\n     * @dev Dynamic payout calculation based on market conditions\n     * @param jackpotSize Current jackpot size (in wei)\n     * @param marketConditionFactor Market condition factor (0-100) that can adjust payout\n     * @return payoutBps Basis points for jackpot payout (e.g. 6900 = 69%)\n     */\n    function calculateJackpotPayoutPercentage(\n        uint256 jackpotSize,\n        uint256 marketConditionFactor\n    ) public pure returns (uint256 payoutBps) {\n        // Start with base payout (69%)\n        uint256 basePayout = BASE_JACKPOT_PAYOUT_BPS;\n        uint256 reduction = 0;\n\n        // For large jackpots, reduce the percentage to create sustainability\n        if (jackpotSize > 10000 ether) {\n            // Calculate log10 approximation\n            uint256 magnitude = 0;\n            uint256 value = jackpotSize / 1 ether;\n\n            while (value >= 10) {\n                value /= 10;\n                magnitude++;\n            }\n\n            // Each order of magnitude reduces by 3%\n            reduction = Math.min(1900, magnitude * 300); // Cap at 19% reduction (50% floor)\n        }\n\n        // Apply market condition factor - can adjust +/- 5% based on conditions\n        if (marketConditionFactor > 50) {\n            // High market factor increases payout (better conditions)\n            uint256 marketBoost = Math.min(500, (marketConditionFactor - 50) * 10);\n\n            // Ensure we don't exceed the base payout\n            reduction = reduction > marketBoost ? reduction - marketBoost : 0;\n        } else if (marketConditionFactor < 50) {\n            // Low market factor decreases payout (worse conditions)\n            uint256 marketPenalty = Math.min(500, (50 - marketConditionFactor) * 10);\n            reduction += marketPenalty;\n        }\n\n        // Apply reduction with floor check\n        uint256 finalPayout = basePayout - reduction;\n        return finalPayout < MIN_JACKPOT_PAYOUT_BPS ? MIN_JACKPOT_PAYOUT_BPS : finalPayout;\n    }\n\n    // ========== FEE ALLOCATION CALCULATIONS ==========\n\n    /**\n     * @notice Calculate dynamic fee allocation based on market conditions\n     * @dev Optimized to avoid stack too deep errors\n     * @param lpTVL Total value locked in LP pools (in wei)\n     * @param jackpotTVL Current jackpot size (in wei)\n     * @param volume24h 24-hour trading volume (in wei)\n     * @param lastWinTimestamp Timestamp of the last jackpot win\n     * @param numStakers Number of active LP stakers\n     * @param marketVolatility Market volatility metric (0-100 scale)\n     * @return jackpotBps Basis points allocated to jackpot (e.g. 690 = 69.0%)\n     * @return lpBps Basis points allocated to LPs\n     * @return burnBps Basis points allocated to burning\n     */\n    function calculateFeeAllocation(\n        uint256 lpTVL,\n        uint256 jackpotTVL,\n        uint256 volume24h,\n        uint256 lastWinTimestamp,\n        uint256 numStakers,\n        uint256 marketVolatility\n    ) public view returns (\n        uint256 jackpotBps,\n        uint256 lpBps,\n        uint256 burnBps\n    ) {\n        // Calculate market-based adjustments\n        (int256 jackpotAdjustment, int256 lpAdjustment) = _calculateMarketAdjustments(\n            lpTVL, jackpotTVL, volume24h, lastWinTimestamp, numStakers, marketVolatility\n        );\n        \n        // Apply adjustments and finalize allocations\n        return _finalizeAllocations(jackpotAdjustment, lpAdjustment);\n    }\n    \n    /**\n     * @dev Calculate all market-based adjustment factors\n     */\n    function _calculateMarketAdjustments(\n        uint256 lpTVL,\n        uint256 jackpotTVL,\n        uint256 volume24h,\n        uint256 lastWinTimestamp,\n        uint256 numStakers,\n        uint256 marketVolatility\n    ) private view returns (int256 jackpotAdjustment, int256 lpAdjustment) {\n        // Volume/LP ratio factor\n        if (volume24h > 0 && lpTVL > 0) {\n            uint256 volumeLPRatio = (volume24h * 1e18) / lpTVL;\n            if (volumeLPRatio > 2e17) { // 0.2 with 18 decimals\n                uint256 scaledRatio = (volumeLPRatio - 2e17) / 1e16;\n                lpAdjustment += int256(Math.min(150, scaledRatio));\n            } else {\n                lpAdjustment -= 100;\n            }\n        }\n\n        // Jackpot size factor\n        if (jackpotTVL > 10000 ether) {\n            uint256 magnitude = _calculateMagnitude(jackpotTVL / 1 ether);\n            jackpotAdjustment -= int256(Math.min(200, magnitude * 10));\n        }\n\n        // Time factor\n        uint256 daysSinceWin = (block.timestamp - lastWinTimestamp) / 1 days;\n        if (daysSinceWin > 7) {\n            jackpotAdjustment += int256(Math.min(150, (daysSinceWin - 7) * 10));\n        }\n\n        // Staker factor\n        if (numStakers > 100) {\n            uint256 magnitude = _calculateMagnitude(numStakers);\n            lpAdjustment += int256(Math.min(100, magnitude * 20));\n        }\n\n        // Volatility factor\n        if (marketVolatility > 50) {\n            lpAdjustment += int256(Math.min(100, (marketVolatility - 50) * 2));\n        }\n    }\n    \n    /**\n     * @dev Calculate magnitude (log10 approximation)\n     */\n    function _calculateMagnitude(uint256 value) private pure returns (uint256 magnitude) {\n        while (value >= 10) {\n            value /= 10;\n            magnitude++;\n        }\n    }\n    \n    /**\n     * @dev Finalize fee allocations with proper bounds checking\n     */\n    function _finalizeAllocations(int256 jackpotAdjustment, int256 lpAdjustment) private pure returns (uint256, uint256, uint256) {\n        // Apply bounds to prevent negative allocations\n        int256 adjustedJackpotBps = int256(BASE_JACKPOT_BPS) + jackpotAdjustment;\n        int256 adjustedLPBps = int256(BASE_LP_BPS) + lpAdjustment;\n\n        // Ensure minimums\n        uint256 finalJackpotBps = Math.max(\n            adjustedJackpotBps > 0 ? uint256(adjustedJackpotBps) : 0,\n            MIN_JACKPOT_BPS\n        );\n        \n        uint256 finalLPBps = Math.max(\n            adjustedLPBps > 0 ? uint256(adjustedLPBps) : 0,\n            MIN_LP_BPS\n        );\n\n        // Calculate burn with minimum\n        uint256 remainingForBurn = BPS_MAX - finalJackpotBps - finalLPBps;\n        uint256 finalBurnBps = Math.max(remainingForBurn, MIN_BURN_BPS);\n\n        // Handle overflow case\n        uint256 total = finalJackpotBps + finalLPBps + finalBurnBps;\n        if (total > BPS_MAX) {\n            return _handleOverflow(finalJackpotBps, finalLPBps, finalBurnBps, total);\n        }\n\n        return (finalJackpotBps, finalLPBps, finalBurnBps);\n    }\n    \n    /**\n     * @dev Handle allocation overflow by scaling down proportionally\n     */\n    function _handleOverflow(\n        uint256 finalJackpotBps,\n        uint256 finalLPBps,\n        uint256 finalBurnBps,\n        uint256 total\n    ) private pure returns (uint256, uint256, uint256) {\n        uint256 excess = total - BPS_MAX;\n        \n        uint256 jackpotAboveMin = finalJackpotBps > MIN_JACKPOT_BPS ? finalJackpotBps - MIN_JACKPOT_BPS : 0;\n        uint256 lpAboveMin = finalLPBps > MIN_LP_BPS ? finalLPBps - MIN_LP_BPS : 0;\n        uint256 burnAboveMin = finalBurnBps > MIN_BURN_BPS ? finalBurnBps - MIN_BURN_BPS : 0;\n        uint256 totalAboveMin = jackpotAboveMin + lpAboveMin + burnAboveMin;\n\n        if (totalAboveMin >= excess) {\n            // Scale down proportionally\n            finalJackpotBps -= (jackpotAboveMin * excess) / totalAboveMin;\n            finalLPBps -= (lpAboveMin * excess) / totalAboveMin;\n            finalBurnBps = BPS_MAX - finalJackpotBps - finalLPBps;\n        } else {\n            // Fallback to minimum distribution\n            finalJackpotBps = MIN_JACKPOT_BPS;\n            finalLPBps = MIN_LP_BPS;\n            finalBurnBps = MIN_BURN_BPS;\n            \n            uint256 remaining = BPS_MAX - (MIN_JACKPOT_BPS + MIN_LP_BPS + MIN_BURN_BPS);\n            uint256 totalBase = BASE_JACKPOT_BPS + BASE_LP_BPS + BASE_BURN_BPS;\n            \n            finalJackpotBps += (BASE_JACKPOT_BPS * remaining) / totalBase;\n            finalLPBps += (BASE_LP_BPS * remaining) / totalBase;\n            finalBurnBps = BPS_MAX - finalJackpotBps - finalLPBps;\n        }\n        \n        return (finalJackpotBps, finalLPBps, finalBurnBps);\n    }\n\n    // ========== TIME UTILITY FUNCTIONS ==========\n\n    /**\n     * @notice Calculate lock end time for a new lock\n     * @dev Aligns to weekly boundaries for consistency\n     * @param currentTime Current timestamp\n     * @param lockDuration Duration to lock for in seconds\n     * @return lockEnd Timestamp when lock will expire\n     */\n    function calculateLockEnd(\n        uint256 currentTime,\n        uint256 lockDuration\n    ) public pure returns (uint256 lockEnd) {\n        // Ensure lock duration is capped at MAX_LOCK_TIME\n        lockDuration = Math.min(lockDuration, MAX_LOCK_TIME);\n\n        // Align to weekly boundaries (Curve style)\n        uint256 unlockTime = ((currentTime + lockDuration) / WEEK) * WEEK;\n\n        return unlockTime;\n    }\n\n    /**\n     * @notice Convert seconds to weeks, rounded down\n     * @param timeInSeconds Time in seconds\n     * @return weeksCount Number of weeks\n     */\n    function secondsToWeeks(uint256 timeInSeconds) public pure returns (uint256 weeksCount) {\n        return timeInSeconds / WEEK;\n    }\n\n    /**\n     * @notice Convert weeks to seconds\n     * @param weeksCount Number of weeks\n     * @return timeInSeconds Time in seconds\n     */\n    function weeksToSeconds(uint256 weeksCount) public pure returns (uint256 timeInSeconds) {\n        return weeksCount * WEEK;\n    }\n\n    // ========== LEGACY COMPATIBILITY FUNCTIONS ==========\n\n    /**\n     * @notice Legacy function name for calculateVotingPower\n     * @dev Maintains backward compatibility\n     */\n    function calculateLinearVotingPower(\n        uint256 amount,\n        uint256 lockDuration\n    ) public pure returns (uint256) {\n        return calculateVotingPower(amount, lockDuration);\n    }\n\n    /**\n     * @notice Legacy function name for calculateDecayedVotingPower\n     * @dev Maintains backward compatibility\n     */\n    function calculateTimeWeightedVotingPower(\n        uint256 amount,\n        uint256 lockEnd,\n        uint256 currentTime\n    ) public pure returns (uint256) {\n        return calculateDecayedVotingPower(amount, lockEnd, currentTime);\n    }\n} "
    },
    "contracts/libraries/security/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport { IAccessControl } from \"./IAccessControl.sol\";\nimport { Context } from \"../utils/Context.sol\";\nimport { Strings } from \"../utils/Strings.sol\";\nimport { ERC165 } from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/libraries/security/DragonAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport 'lib/openzeppelin-contracts/contracts/access/extensions/AccessControlEnumerable.sol';\nimport 'lib/openzeppelin-contracts/contracts/utils/Pausable.sol';\n\n/**\n * @title DragonAccessControl\n * @dev Comprehensive role-based access control for the Dragon ecosystem\n * Implements audit recommendations to reduce centralization risks\n */\nabstract contract DragonAccessControl is AccessControlEnumerable, Pausable {\n  // Role definitions\n  bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n  bytes32 public constant OPERATOR_ROLE = keccak256('OPERATOR_ROLE');\n  bytes32 public constant PAUSER_ROLE = keccak256('PAUSER_ROLE');\n  bytes32 public constant FEE_MANAGER_ROLE = keccak256('FEE_MANAGER_ROLE');\n  bytes32 public constant LOTTERY_MANAGER_ROLE = keccak256('LOTTERY_MANAGER_ROLE');\n  bytes32 public constant TREASURY_ROLE = keccak256('TREASURY_ROLE');\n  bytes32 public constant UPGRADER_ROLE = keccak256('UPGRADER_ROLE');\n  bytes32 public constant ORACLE_ROLE = keccak256('ORACLE_ROLE');\n  bytes32 public constant PARTNER_MANAGER_ROLE = keccak256('PARTNER_MANAGER_ROLE');\n\n  // Multi-signature requirements\n  mapping(bytes32 => uint256) public roleThresholds;\n  mapping(bytes32 => mapping(bytes32 => mapping(address => bool))) public roleProposalSignatures;\n  mapping(bytes32 => mapping(bytes32 => uint256)) public roleProposalSignatureCount;\n\n  // Events\n  event RoleThresholdSet(bytes32 indexed role, uint256 threshold);\n  event MultiSigProposalCreated(bytes32 indexed role, bytes32 indexed proposalId, address proposer);\n  event MultiSigProposalSigned(bytes32 indexed role, bytes32 indexed proposalId, address signer);\n  event MultiSigProposalExecuted(bytes32 indexed role, bytes32 indexed proposalId);\n\n  // Errors\n  error InsufficientSignatures();\n  error AlreadySigned();\n  error ProposalNotFound();\n  error InvalidThreshold();\n\n  constructor() {\n    // Set up initial roles\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _grantRole(ADMIN_ROLE, msg.sender);\n\n    // Set role hierarchies\n    _setRoleAdmin(OPERATOR_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(PAUSER_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(FEE_MANAGER_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(LOTTERY_MANAGER_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(TREASURY_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(UPGRADER_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ORACLE_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(PARTNER_MANAGER_ROLE, ADMIN_ROLE);\n\n    // Set default thresholds (can be updated)\n    roleThresholds[ADMIN_ROLE] = 2;\n    roleThresholds[TREASURY_ROLE] = 2;\n    roleThresholds[UPGRADER_ROLE] = 3;\n  }\n\n  /**\n   * @dev Modifier for admin functions\n   */\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), 'DragonAccessControl: admin only');\n    _;\n  }\n\n  /**\n   * @dev Modifier for operator functions\n   */\n  modifier onlyOperator() {\n    require(hasRole(OPERATOR_ROLE, msg.sender), 'DragonAccessControl: operator only');\n    _;\n  }\n\n  /**\n   * @dev Modifier for fee management functions\n   */\n  modifier onlyFeeManager() {\n    require(hasRole(FEE_MANAGER_ROLE, msg.sender), 'DragonAccessControl: fee manager only');\n    _;\n  }\n\n  /**\n   * @dev Modifier for lottery management functions\n   */\n  modifier onlyLotteryManager() {\n    require(hasRole(LOTTERY_MANAGER_ROLE, msg.sender), 'DragonAccessControl: lottery manager only');\n    _;\n  }\n\n  /**\n   * @dev Modifier for treasury functions\n   */\n  modifier onlyTreasury() {\n    require(hasRole(TREASURY_ROLE, msg.sender), 'DragonAccessControl: treasury only');\n    _;\n  }\n\n  /**\n   * @dev Modifier for functions requiring multi-signature\n   */\n  modifier requiresMultiSig(bytes32 role, bytes32 proposalId) {\n    uint256 threshold = roleThresholds[role];\n    if (threshold > 1) {\n      // Check if proposal has enough signatures\n      if (roleProposalSignatureCount[role][proposalId] < threshold) {\n        // Record signature\n        if (roleProposalSignatures[role][proposalId][msg.sender]) {\n          revert AlreadySigned();\n        }\n\n        roleProposalSignatures[role][proposalId][msg.sender] = true;\n        roleProposalSignatureCount[role][proposalId]++;\n\n        emit MultiSigProposalSigned(role, proposalId, msg.sender);\n\n        // If still not enough signatures, revert\n        if (roleProposalSignatureCount[role][proposalId] < threshold) {\n          revert InsufficientSignatures();\n        }\n      }\n\n      emit MultiSigProposalExecuted(role, proposalId);\n    }\n    _;\n  }\n\n  /**\n   * @dev Set role threshold for multi-signature\n   * @param role The role to set threshold for\n   * @param threshold The number of signatures required\n   */\n  function setRoleThreshold(bytes32 role, uint256 threshold) external onlyAdmin {\n    if (threshold == 0) revert InvalidThreshold();\n\n    // Get current role member count\n    uint256 memberCount = getRoleMemberCount(role);\n    if (threshold > memberCount) revert InvalidThreshold();\n\n    roleThresholds[role] = threshold;\n    emit RoleThresholdSet(role, threshold);\n  }\n\n  /**\n   * @dev Pause contract operations\n   */\n  function pause() external {\n    require(hasRole(PAUSER_ROLE, msg.sender), 'DragonAccessControl: pauser only');\n    _pause();\n  }\n\n  /**\n   * @dev Unpause contract operations\n   */\n  function unpause() external onlyAdmin {\n    _unpause();\n  }\n\n  /**\n   * @dev Check if address has any privileged role\n   * @param account The address to check\n   * @return Whether the address has any privileged role\n   */\n  function hasPrivilegedRole(address account) public view returns (bool) {\n    return\n      hasRole(ADMIN_ROLE, account) ||\n      hasRole(OPERATOR_ROLE, account) ||\n      hasRole(FEE_MANAGER_ROLE, account) ||\n      hasRole(LOTTERY_MANAGER_ROLE, account) ||\n      hasRole(TREASURY_ROLE, account) ||\n      hasRole(UPGRADER_ROLE, account) ||\n      hasRole(ORACLE_ROLE, account) ||\n      hasRole(PARTNER_MANAGER_ROLE, account);\n  }\n\n  /**\n   * @dev Get all roles for an account\n   * @param account The address to check\n   * @return roles Array of role identifiers\n   */\n  function getAccountRoles(address account) external view returns (bytes32[] memory roles) {\n    uint256 count = 0;\n    bytes32[] memory tempRoles = new bytes32[](9);\n\n    if (hasRole(DEFAULT_ADMIN_ROLE, account)) tempRoles[count++] = DEFAULT_ADMIN_ROLE;\n    if (hasRole(ADMIN_ROLE, account)) tempRoles[count++] = ADMIN_ROLE;\n    if (hasRole(OPERATOR_ROLE, account)) tempRoles[count++] = OPERATOR_ROLE;\n    if (hasRole(PAUSER_ROLE, account)) tempRoles[count++] = PAUSER_ROLE;\n    if (hasRole(FEE_MANAGER_ROLE, account)) tempRoles[count++] = FEE_MANAGER_ROLE;\n    if (hasRole(LOTTERY_MANAGER_ROLE, account)) tempRoles[count++] = LOTTERY_MANAGER_ROLE;\n    if (hasRole(TREASURY_ROLE, account)) tempRoles[count++] = TREASURY_ROLE;\n    if (hasRole(UPGRADER_ROLE, account)) tempRoles[count++] = UPGRADER_ROLE;\n    if (hasRole(ORACLE_ROLE, account)) tempRoles[count++] = ORACLE_ROLE;\n    if (hasRole(PARTNER_MANAGER_ROLE, account)) tempRoles[count++] = PARTNER_MANAGER_ROLE;\n\n    roles = new bytes32[](count);\n    for (uint256 i = 0; i < count; i++) {\n      roles[i] = tempRoles[i];\n    }\n\n    return roles;\n  }\n\n  /**\n   * @dev Create a multi-sig proposal\n   * @param role The role requiring multi-sig\n   * @param proposalData The proposal data for ID generation\n   * @return proposalId The generated proposal ID\n   */\n  function createMultiSigProposal(bytes32 role, bytes memory proposalData) internal returns (bytes32 proposalId) {\n    proposalId = keccak256(abi.encodePacked(role, proposalData, block.timestamp));\n    emit MultiSigProposalCreated(role, proposalId, msg.sender);\n    return proposalId;\n  }\n\n  /**\n   * @dev Clear a multi-sig proposal after execution\n   * @param role The role of the proposal\n   * @param proposalId The proposal ID to clear\n   */\n  function clearMultiSigProposal(bytes32 role, bytes32 proposalId) internal {\n    roleProposalSignatureCount[role][proposalId] = 0;\n    // Note: We don't clear individual signatures to save gas\n    // They're invalidated by the signature count reset\n  }\n}\n"
    },
    "contracts/libraries/security/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/libraries/security/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport { Context } from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/libraries/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/libraries/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/libraries/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/libraries/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport { Math } from '../math/Math.sol';\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _SYMBOLS = '0123456789abcdef';\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n      uint256 length = Math.log10(value) + 1;\n      string memory buffer = new string(length);\n      uint256 ptr;\n      /// @solidity memory-safe-assembly\n      assembly {\n        ptr := add(buffer, add(32, length))\n      }\n      while (true) {\n        ptr--;\n        /// @solidity memory-safe-assembly\n        assembly {\n          mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n        }\n        value /= 10;\n        if (value == 0) break;\n      }\n      return buffer;\n    }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n      return toHexString(value, Math.log256(value) + 1);\n    }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = '0';\n    buffer[1] = 'x';\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, 'Strings: hex length insufficient');\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n   */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {VRFV2PlusClient} from \"../libraries/VRFV2PlusClient.sol\";\nimport {IVRFSubscriptionV2Plus} from \"./IVRFSubscriptionV2Plus.sol\";\n\n// Interface that enables consumers of VRFCoordinatorV2Plus to be future-proof for upgrades\n// This interface is supported by subsequent versions of VRFCoordinatorV2Plus\ninterface IVRFCoordinatorV2Plus is IVRFSubscriptionV2Plus {\n  /**\n   * @notice Request a set of random words.\n   * @param req - a struct containing following fields for randomness request:\n   * keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * requestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * extraArgs - abi-encoded extra args\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(VRFV2PlusClient.RandomWordsRequest calldata req) external returns (uint256 requestId);\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/vrf/dev/interfaces/IVRFSubscriptionV2Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice The IVRFSubscriptionV2Plus interface defines the subscription\n/// @notice related methods implemented by the V2Plus coordinator.\ninterface IVRFSubscriptionV2Plus {\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint256 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint256 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint256 subId, address to) external;\n\n  /**\n   * @notice Accept subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint256 subId) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint256 subId, address newOwner) external;\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription with LINK, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   * @dev Note to fund the subscription with Native, use fundSubscriptionWithNative. Be sure\n   * @dev  to send Native with the call, for example:\n   * @dev COORDINATOR.fundSubscriptionWithNative{value: amount}(subId);\n   */\n  function createSubscription() external returns (uint256 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return nativeBalance - native balance of the subscription in wei.\n   * @return reqCount - Requests count of subscription.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(\n    uint256 subId\n  )\n    external\n    view\n    returns (uint96 balance, uint96 nativeBalance, uint64 reqCount, address owner, address[] memory consumers);\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint256 subId) external view returns (bool);\n\n  /**\n   * @notice Paginate through all active VRF subscriptions.\n   * @param startIndex index of the subscription to start from\n   * @param maxCount maximum number of subscriptions to return, 0 to return all\n   * @dev the order of IDs in the list is **not guaranteed**, therefore, if making successive calls, one\n   * @dev should consider keeping the blockheight constant to ensure a holistic picture of the contract state\n   */\n  function getActiveSubscriptionIds(uint256 startIndex, uint256 maxCount) external view returns (uint256[] memory);\n\n  /**\n   * @notice Fund a subscription with native.\n   * @param subId - ID of the subscription\n   * @notice This method expects msg.value to be greater than or equal to 0.\n   */\n  function fundSubscriptionWithNative(uint256 subId) external payable;\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// End consumer library.\nlibrary VRFV2PlusClient {\n  // extraArgs will evolve to support new features\n  bytes4 public constant EXTRA_ARGS_V1_TAG = bytes4(keccak256(\"VRF ExtraArgsV1\"));\n  struct ExtraArgsV1 {\n    bool nativePayment;\n  }\n\n  struct RandomWordsRequest {\n    bytes32 keyHash;\n    uint256 subId;\n    uint16 requestConfirmations;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n    bytes extraArgs;\n  }\n\n  function _argsToBytes(ExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "lib/devtools/packages/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "lib/devtools/packages/oapp-evm/contracts/oapp/interfaces/IOAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Struct representing enforced option parameters.\n */\nstruct EnforcedOptionParam {\n    uint32 eid; // Endpoint ID\n    uint16 msgType; // Message Type\n    bytes options; // Additional options\n}\n\n/**\n * @title IOAppOptionsType3\n * @dev Interface for the OApp with Type 3 Options, allowing the setting and combining of enforced options.\n */\ninterface IOAppOptionsType3 {\n    // Custom error message for invalid options\n    error InvalidOptions(bytes options);\n\n    // Event emitted when enforced options are set\n    event EnforcedOptionSet(EnforcedOptionParam[] _enforcedOptions);\n\n    /**\n     * @notice Sets enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) external;\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OApp message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) external view returns (bytes memory options);\n}\n"
    },
    "lib/devtools/packages/oapp-evm/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "lib/devtools/packages/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { IOAppOptionsType3, EnforcedOptionParam } from \"../interfaces/IOAppOptionsType3.sol\";\n\n/**\n * @title OAppOptionsType3\n * @dev Abstract contract implementing the IOAppOptionsType3 interface with type 3 options.\n */\nabstract contract OAppOptionsType3 is IOAppOptionsType3, Ownable {\n    uint16 internal constant OPTION_TYPE_3 = 3;\n\n    // @dev The \"msgType\" should be defined in the child contract.\n    mapping(uint32 eid => mapping(uint16 msgType => bytes enforcedOption)) public enforcedOptions;\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\n        _setEnforcedOptions(_enforcedOptions);\n    }\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function _setEnforcedOptions(EnforcedOptionParam[] memory _enforcedOptions) internal virtual {\n        for (uint256 i = 0; i < _enforcedOptions.length; i++) {\n            // @dev Enforced options are only available for optionType 3, as type 1 and 2 dont support combining.\n            _assertOptionsType3(_enforcedOptions[i].options);\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\n        }\n\n        emit EnforcedOptionSet(_enforcedOptions);\n    }\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OAPP message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     *\n     * @dev If there is an enforced lzReceive option:\n     * - {gasLimit: 200k, msg.value: 1 ether} AND a caller supplies a lzReceive option: {gasLimit: 100k, msg.value: 0.5 ether}\n     * - The resulting options will be {gasLimit: 300k, msg.value: 1.5 ether} when the message is executed on the remote lzReceive() function.\n     * @dev This presence of duplicated options is handled off-chain in the verifier/executor.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) public view virtual returns (bytes memory) {\n        bytes memory enforced = enforcedOptions[_eid][_msgType];\n\n        // No enforced options, pass whatever the caller supplied, even if it's empty or legacy type 1/2 options.\n        if (enforced.length == 0) return _extraOptions;\n\n        // No caller options, return enforced\n        if (_extraOptions.length == 0) return enforced;\n\n        // @dev If caller provided _extraOptions, must be type 3 as its the ONLY type that can be combined.\n        if (_extraOptions.length >= 2) {\n            _assertOptionsType3(_extraOptions);\n            // @dev Remove the first 2 bytes containing the type from the _extraOptions and combine with enforced.\n            return bytes.concat(enforced, _extraOptions[2:]);\n        }\n\n        // No valid set of options was found.\n        revert InvalidOptions(_extraOptions);\n    }\n\n    /**\n     * @dev Internal function to assert that options are of type 3.\n     * @param _options The options to be checked.\n     */\n    function _assertOptionsType3(bytes memory _options) internal pure virtual {\n        uint16 optionsType;\n        assembly {\n            optionsType := mload(add(_options, 2))\n        }\n        if (optionsType != OPTION_TYPE_3) revert InvalidOptions(_options);\n    }\n}\n"
    },
    "lib/devtools/packages/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport { SafeCast } from \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\n\nimport { ExecutorOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol\";\nimport { DVNOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol\";\n\n/**\n * @title OptionsBuilder\n * @dev Library for building and encoding various message options.\n */\nlibrary OptionsBuilder {\n    using SafeCast for uint256;\n    using BytesLib for bytes;\n\n    // Constants for options types\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\n    uint16 internal constant TYPE_3 = 3;\n\n    // Custom error message\n    error InvalidSize(uint256 max, uint256 actual);\n    error InvalidOptionType(uint16 optionType);\n\n    // Modifier to ensure only options of type 3 are used\n    modifier onlyType3(bytes memory _options) {\n        if (_options.toUint16(0) != TYPE_3) revert InvalidOptionType(_options.toUint16(0));\n        _;\n    }\n\n    /**\n     * @dev Creates a new options container with type 3.\n     * @return options The newly created options container.\n     */\n    function newOptions() internal pure returns (bytes memory) {\n        return abi.encodePacked(TYPE_3);\n    }\n\n    /**\n     * @dev Adds an executor LZ receive option to the existing options.\n     * @param _options The existing options container.\n     * @param _gas The gasLimit used on the lzReceive() function in the OApp.\n     * @param _value The msg.value passed to the lzReceive() function in the OApp.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor\n     * eg. if (_gas: 200k, and _value: 1 ether) AND (_gas: 100k, _value: 0.5 ether) are sent in an option to the LayerZeroEndpoint,\n     * that becomes (300k, 1.5 ether) when the message is executed on the remote lzReceive() function.\n     */\n    function addExecutorLzReceiveOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\n    }\n\n    /**\n     * @dev Adds an executor native drop option to the existing options.\n     * @param _options The existing options container.\n     * @param _amount The amount for the native value that is airdropped to the 'receiver'.\n     * @param _receiver The receiver address for the native drop option.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\n     */\n    function addExecutorNativeDropOption(\n        bytes memory _options,\n        uint128 _amount,\n        bytes32 _receiver\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeNativeDropOption(_amount, _receiver);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_NATIVE_DROP, option);\n    }\n\n    // /**\n    //  * @dev Adds an executor native drop option to the existing options.\n    //  * @param _options The existing options container.\n    //  * @param _amount The amount for the native value that is airdropped to the 'receiver'.\n    //  * @param _receiver The receiver address for the native drop option.\n    //  * @return options The updated options container.\n    //  *\n    //  * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\n    //  */\n    function addExecutorLzReadOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint32 _size,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReadOption(_gas, _size, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZREAD, option);\n    }\n\n    /**\n     * @dev Adds an executor LZ compose option to the existing options.\n     * @param _options The existing options container.\n     * @param _index The index for the lzCompose() function call.\n     * @param _gas The gasLimit for the lzCompose() function call.\n     * @param _value The msg.value for the lzCompose() function call.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed PER index by the executor on the remote chain.\n     * @dev If the OApp sends N lzCompose calls on the remote, you must provide N incremented indexes starting with 0.\n     * ie. When your remote OApp composes (N = 3) messages, you must set this option for index 0,1,2\n     */\n    function addExecutorLzComposeOption(\n        bytes memory _options,\n        uint16 _index,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_index, _gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\n    }\n\n    /**\n     * @dev Adds an executor ordered execution option to the existing options.\n     * @param _options The existing options container.\n     * @return options The updated options container.\n     */\n    function addExecutorOrderedExecutionOption(\n        bytes memory _options\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds a DVN pre-crime option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the pre-crime option.\n     * @return options The updated options container.\n     */\n    function addDVNPreCrimeOption(\n        bytes memory _options,\n        uint8 _dvnIdx\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addDVNOption(_options, _dvnIdx, DVNOptions.OPTION_TYPE_PRECRIME, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds an executor option to the existing options.\n     * @param _options The existing options container.\n     * @param _optionType The type of the executor option.\n     * @param _option The encoded data for the executor option.\n     * @return options The updated options container.\n     */\n    function addExecutorOption(\n        bytes memory _options,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                ExecutorOptions.WORKER_ID,\n                _option.length.toUint16() + 1, // +1 for optionType\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Adds a DVN option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the DVN option.\n     * @param _optionType The type of the DVN option.\n     * @param _option The encoded data for the DVN option.\n     * @return options The updated options container.\n     */\n    function addDVNOption(\n        bytes memory _options,\n        uint8 _dvnIdx,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                DVNOptions.WORKER_ID,\n                _option.length.toUint16() + 2, // +2 for optionType and dvnIdx\n                _dvnIdx,\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Encodes legacy options of type 1.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @return legacyOptions The encoded legacy options.\n     */\n    function encodeLegacyOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        return abi.encodePacked(TYPE_1, _executionGas);\n    }\n\n    /**\n     * @dev Encodes legacy options of type 2.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @param _nativeForDst The amount of native air dropped to the receiver.\n     * @param _receiver The _nativeForDst receiver address.\n     * @return legacyOptions The encoded legacy options of type 2.\n     */\n    function encodeLegacyOptionsType2(\n        uint256 _executionGas,\n        uint256 _nativeForDst,\n        bytes memory _receiver // @dev Use bytes instead of bytes32 in legacy type 2 for _receiver.\n    ) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        if (_nativeForDst > type(uint128).max) revert InvalidSize(type(uint128).max, _nativeForDst);\n        if (_receiver.length > 32) revert InvalidSize(32, _receiver.length);\n        return abi.encodePacked(TYPE_2, _executionGas, _nativeForDst, _receiver);\n    }\n}\n"
    },
    "lib/devtools/packages/oapp-evm/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "lib/devtools/packages/oapp-evm/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "lib/devtools/packages/oapp-evm/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "lib/devtools/packages/oapp-evm/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _timeout) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _gracePeriod) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/libs/CalldataBytesLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary CalldataBytesLib {\n    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {\n        return uint8(_bytes[_start]);\n    }\n\n    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {\n        unchecked {\n            uint256 end = _start + 2;\n            return uint16(bytes2(_bytes[_start:end]));\n        }\n    }\n\n    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {\n        unchecked {\n            uint256 end = _start + 4;\n            return uint32(bytes4(_bytes[_start:end]));\n        }\n    }\n\n    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {\n        unchecked {\n            uint256 end = _start + 8;\n            return uint64(bytes8(_bytes[_start:end]));\n        }\n    }\n\n    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {\n        unchecked {\n            uint256 end = _start + 16;\n            return uint128(bytes16(_bytes[_start:end]));\n        }\n    }\n\n    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {\n        unchecked {\n            uint256 end = _start + 32;\n            return uint256(bytes32(_bytes[_start:end]));\n        }\n    }\n\n    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {\n        unchecked {\n            uint256 end = _start + 20;\n            return address(bytes20(_bytes[_start:end]));\n        }\n    }\n\n    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {\n        unchecked {\n            uint256 end = _start + 32;\n            return bytes32(_bytes[_start:end]);\n        }\n    }\n}\n"
    },
    "lib/layerzero-v2/packages/layerzero-v2/evm/protocol/contracts/messagelib/libs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\npragma solidity ^0.8.20;\n\ntype BitMap256 is uint256;\n\nusing BitMaps for BitMap256 global;\n\nlibrary BitMaps {\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 mask = 1 << index;\n        return BitMap256.unwrap(bitmap) & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\n        uint256 mask = 1 << index;\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/extensions/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControlEnumerable} from \"./IAccessControlEnumerable.sol\";\nimport {AccessControl} from \"../AccessControl.sol\";\nimport {EnumerableSet} from \"../../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/extensions/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"../IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`â€™s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`â€™s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`â€™s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"./ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address implementation, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.20;\n\nimport {ITransparentUpgradeableProxy} from \"./TransparentUpgradeableProxy.sol\";\nimport {Ownable} from \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgrade(address)`\n     * and `upgradeAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev Sets the initial owner who can perform upgrades.\n     */\n    constructor(address initialOwner) Ownable(initialOwner) {}\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.\n     * See {TransparentUpgradeableProxy-_dispatchUpgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\nimport {ERC1967Proxy} from \"../ERC1967/ERC1967Proxy.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {ProxyAdmin} from \"./ProxyAdmin.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function upgradeToAndCall(address, bytes calldata) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won't be forwarded to\n * the implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for upgrading the proxy, so it's best if it's a\n * dedicated account that is not used for anything else. This will avoid headaches due to sudden errors when trying to\n * call a function from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and\n * allows upgrades only if they come through it. You should think of the `ProxyAdmin` instance as the administrative\n * interface of the proxy, including the ability to change who can trigger upgrades by transferring ownership.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won't send a\n * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.\n *\n * IMPORTANT: This contract avoids unnecessary storage reads by setting the admin only during construction as an\n * immutable variable, preventing any changes thereafter. However, the admin slot defined in ERC-1967 can still be\n * overwritten by the implementation logic pointed to by this proxy. In such cases, the contract may end up in an\n * undesirable state where the admin slot is different from the actual admin.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the\n * compiler will not check that there are no selector conflicts, due to the note above. A selector clash between any new\n * function and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This\n * could render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    // An immutable address for the admin to avoid unnecessary SLOADs before each call\n    // at the expense of removing the ability to change the admin once it's set.\n    // This is acceptable if the admin is always a ProxyAdmin instance or similar contract\n    // with its own ability to transfer the permissions to another account.\n    address private immutable _admin;\n\n    /**\n     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.\n     */\n    error ProxyDeniedAdminAccess();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,\n     * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in\n     * {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _admin = address(new ProxyAdmin(initialOwner));\n        // Set the storage value and emit an event for ERC-1967 compatibility\n        ERC1967Utils.changeAdmin(_proxyAdmin());\n    }\n\n    /**\n     * @dev Returns the admin of this proxy.\n     */\n    function _proxyAdmin() internal virtual returns (address) {\n        return _admin;\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _proxyAdmin()) {\n            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                revert ProxyDeniedAdminAccess();\n            } else {\n                _dispatchUpgradeToAndCall();\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function _dispatchUpgradeToAndCall() private {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        ERC1967Utils.upgradeToAndCall(newImplementation, data);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // â†’ `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // â†’ `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author GonÃ§alo SÃ¡ <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        // We're using the unchecked block below because otherwise execution ends \n        // with the native overflow error code.\n        unchecked {\n            require(_length + 31 >= _length, \"slice_overflow\");\n        }\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031373530393831383935373633"
      }
    }
  }
}